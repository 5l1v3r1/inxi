================================================================================
INXI FRAGMENTS
================================================================================
FILE:    inxi-fragmentsg.txt
VERSION: 1.2
DATE:    2018-08-15

----------------------------------------
See: optimization.txt
See: perl-setup.txt
See: perl-version_support.txt

----------------------------------------
Comments:

These fragments were in inxi / pinxi, but were removed because they are no 
longer needed or used in this form. Or they are legacy logic that might come
in handy one day.

================================================================================

Sections:
1. FRAGMENTS

================================================================================
FRAGMENTS
--------------------------------------------------------------------------------

========================================
AudioData
----------------------------------------

sub usb_data {
	eval $start if $b_log;
	my (@rows,@data,@ids,$driver,$path_id,$product,$product2,
	@temp2,$vendor,$vendor2);
	my ($j,$num) = (0,1);
	if (-d '/proc/asound') {
		# note: this will double the data, but it's easier this way.
		# inxi tested for -L in the /proc/asound files, and used only those.
		my @files = main::globber('/proc/asound/*/usbid');
		foreach (@files){
			my $id = (main::reader($_))[0];
			push @ids, $id if ($id && ! grep {/$id/} @ids);
		}
		# lsusb is a very expensive operation
		if (@ids){
			if (!$bsd_type && !$b_usb_check){
				main::set_usb_data();
			}
		}
		main::log_data('dump','@ids',\@ids) if $b_log;
		return if !@usb;
		foreach my $id (@ids){
			$j = scalar @rows;
			foreach my $ref (@usb){
				my @row = @$ref;
				# a device will always be the second or > device on the bus
				if ($row[1] > 1 && $row[2] eq $id){
					$num = 1;
					# makre sure to reset, or second device trips last flag
					($driver,$path_id,$product,$product2,$vendor,$vendor2) = ('','','','','','');
					if ($usb_level == 1){
						$product = main::cleaner($row[3]);
						if ($row[4]){
							$row[4] =~ s/^driver://;
							$driver = $row[4];
						}
						if ($row[5]){
							$row[5] =~ s/^path_id://;
							$path_id = $row[5];
						}
					}
					else {
						foreach my $line (@row){
							my @working = split /:/, $line;
							if ($working[0] eq 'idVendor' && $working[2]){
								$vendor = main::cleaner($working[2]);
							}
							if ($working[0] eq 'idProduct' && $working[2]){
								$product = main::cleaner($working[2]);
							}
							if ($working[0] eq 'iManufacturer' && $working[2]){
								$vendor2 = main::cleaner($working[2]);
							}
							if ($working[0] eq 'iProduct' && $working[2]){
								$product2 = main::cleaner($working[2]);
							}
							if ($working[0] eq 'driver' && $working[1]){
								$driver = $working[1];
							}
							if ($working[0] eq 'path_id' && $working[1]){
								$path_id = $working[1];
							}
							#if ($working[0] eq 'Descriptor_Configuration'){
								# last;
							#}
						}
					}
					if ($vendor && $product){
						$product = ($product =~ /$vendor/) ? $product: "$vendor $product" ;
					}
					elsif (!$product) {
						if ($vendor && $product2){
							$product = ($product2 =~ /$vendor/) ? $product2: "$vendor $product2" ;
						}
						elsif ($vendor2 && $product2){
							$product = ($product2 =~ /$vendor2/) ? $product2: "$vendor2 $product2" ;
						}
						elsif ($vendor){
							$product = $vendor;
						}
						elsif ($vendor2){
							$product = $vendor2;
						}
						else {
							$product = 'N/A';
						}
					}
					$driver ||= 'snd-usb-audio';
					@data = ({
					main::key($num++,'Device') => $product,
					main::key($num++,'type') => 'USB',
					main::key($num++,'driver') => $driver,
					},);
					@rows = (@rows,@data);
					if ($extra > 0){
						$rows[$j]{main::key($num++,'bus ID')} = "$path_id:$row[1]";
					}
					if ($extra > 1){
						$rows[$j]{main::key($num++,'chip ID')} = $row[2];
					}
				}
			}
		}
	}
	eval $end if $b_log;
	return @rows;
}

========================================
NetworkData
----------------------------------------

sub usb_data {
	eval $start if $b_log;
	my (@data,@rows,@temp2,$b_wifi,$driver,
	$path,$path_id,$product,$product2,$test,$vendor,$vendor2);
	my ($j,$num) = (0,1);
	return if !@usb;
	foreach my $ref (@usb){
		my @row = @$ref;
		# a device will always be the second or > device on the bus
		if ($row[1] > 1){
			$num = 1;
			($driver,$path,$path_id,$product,$product2,
			$test,$vendor,$vendor2) = ('','','','','','','','');
			if ($usb_level == 1){
				$product = main::cleaner($row[3]);
			}
			else {
				foreach my $line (@row){
					my @working = split /:/, $line;
					if ($working[0] eq 'idVendor' && $working[2]){
						$vendor = main::cleaner($working[2]);
					}
					if ($working[0] eq 'idProduct' && $working[2]){
						$product = main::cleaner($working[2]);
					}
					if ($working[0] eq 'iVendor' && $working[2]){
						$product2 = main::cleaner($working[2]);
					}
					if ($working[0] eq 'iProduct' && $working[2]){
						$product2 = main::cleaner($working[2]);
					}
					if ($working[0] eq 'Descriptor_Configuration'){
						#last;
					}
					if ($working[0] eq 'driver' && $working[1]){
						$driver = $working[1];
					}
					if ($working[0] eq 'path' && $working[1]){
						$path = $working[1];
					}
					if ($working[0] eq 'path_id' && $working[1]){
						$path_id = $working[1];
					}
				}
				if ($vendor && $product){
					$product = ($product =~ /$vendor/) ? $product: "$vendor $product";
				}
				elsif ($vendor && $product2){
					$product = ($product2 =~ /$vendor/) ? $product2: "$vendor $product2";
				}
				elsif ($vendor2 && $product){
					$product = ($product =~ /$vendor2/) ? $product: "$vendor2 $product";
				}
				elsif ($vendor2 && $product2){
					$product = ($product2 =~ /$vendor2/) ? $product2: "$vendor2 $product2";
				}
				elsif ($vendor){
					$product = $vendor;
				}
				elsif ($vendor2){
					$product = $vendor2;
				}
				$test = "$vendor $product $vendor2 $vendor2";
			}
			if ($product && network_device($test)){
				$driver ||= 'usb-network';
				@data = ({
				main::key($num++,'Device') => $product,
				main::key($num++,'type') => 'USB',
				main::key($num++,'driver') => $driver,
				},);
				$b_wifi = check_wifi($product);
				@rows = (@rows,@data);
				if ($extra > 0){
					$rows[$j]{main::key($num++,'bus ID')} = "$path_id:$row[1]";
				}
				if ($extra > 1){
					$rows[$j]{main::key($num++,'chip ID')} = $row[2];
				}
				if ($show{'network-advanced'}){
					if (!$bsd_type){
						my (@temp,$vendor,$chip);
						@temp = split (/:/, $row[2]) if $row[2];
						($vendor,$chip) = ($temp[0],$temp[1]) if @temp;
						@data = advanced_data_sys($vendor,$chip,0,$b_wifi,$path);
					}
					# NOTE: we need the driver.number, like wlp0 to get a match, and 
					# we can't get that from usb data, so we have to let it fall back down 
					# to the check function for BSDs.
					#else {
					#	@data = advanced_data_bsd($row[2],$b_wifi);
					#}
					@rows = (@rows,@data) if @data;
				}
				$j = scalar @rows;
			}
		}
	}
	eval $end if $b_log;
	return @rows;
}

========================================
get_env_de_data()
----------------------------------------

This was completely rewritten in version 3.0.19, but I want to keep this logic 
in case something goes wrong with the matches of the new looping method.

sub get_env_de_data {
	eval $start if $b_log;
	my ($program,@version_data);
	main::set_ps_gui() if ! $b_ps_gui;
	if ($desktop_session eq 'trinity' || $xdg_desktop eq 'trinity' || (grep {/^tde/} @ps_gui) ){
		$desktop[0] = 'Trinity';
		if ($program = main::check_program('kdesktop')){
			@version_data = main::grabber("$program --version 2>/dev/null");
			$desktop[1] = main::awk(\@version_data,'^TDE:',2,'\s+') if @version_data;
		}
		if ($extra > 1 && @version_data){
			$desktop[2] = 'Qt';
			$desktop[3] = main::awk(\@version_data,'^Qt:',2,'\s+') if @version_data;
		}
	}
	elsif ($xdg_desktop eq 'unity'){
		@data = main::program_values('unity');
		$desktop[0] = $data[3];
		$desktop[0] ||= 'Unity';
		$desktop[1] = main::program_version('cinnamon',$data[0],$data[1],$data[2],$data[5],$data[6]);
		#set_gtk_data() if $extra > 1;
	}
	elsif ( $xdg_desktop =~ /budgie/ ){
		@data = main::program_values('budgie');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('budgie-desktop',$data[0],$data[1],$data[2],$data[5],$data[6]);
	}
	# debian package: lxde-core. 
	# NOTE: some distros fail to set XDG data for root
	elsif ( $xdg_desktop =~ /^(lxde|razor|lxqt)$/ || (grep {/^(razor-session|lxsession|lxqt-session)$/} @ps_gui)){
		# note: openbox-lxde --version may be present, but returns openbox data
		if ($xdg_desktop eq 'lxde' || (grep {/^lxsession$/} @ps_gui )){
			@data = main::program_values('lxde');
			$desktop[0] = $data[3];
			$desktop[1] = main::program_version('lxpanel',$data[0],$data[1],$data[2],$data[5],$data[6]);
		}
		# NOTE: lxqt-about opens a gui dialog
		elsif ($xdg_desktop eq 'razor' || $xdg_desktop eq 'lxqt' || (grep {/^(razor-desktop|lxqt-session)$/} @ps_gui)) {
			if (grep {/^lxqt-session$/} @ps_gui){
				@data = main::program_values('lxqt');
				$desktop[0] = $data[3];
				# BAD: lxqt-about opens dialogue, sigh
				$desktop[1] = main::program_version('lxqt-panel',$data[0],$data[1],$data[2],$data[5],$data[6]);
			}
			elsif (grep {/^razor-session$/} @ps_gui){
				$desktop[0] = 'Razor-Qt';
			}
			else {
				$desktop[0] = 'LX-Qt-Variant';
			}
			set_qt_data() if $extra > 1;
		}
	}
	# note, X-Cinnamon value strikes me as highly likely to change, so just 
	# search for the last part
	elsif ( $xdg_desktop =~ /cinnamon/ ){
		@data = main::program_values('cinnamon');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('cinnamon',$data[0],$data[1],$data[2],$data[5],$data[6]);
		#set_gtk_data() if $extra > 1;
	}
	elsif ($xdg_desktop eq 'pantheon' || $desktop_session eq 'pantheon'){
		@data = main::program_values('pantheon');
		$desktop[0] = $data[3];
		#$desktop[1] = main::program_version('pantheon',$data[0],$data[1],$data[2],$data[5],$data[6]);
		#set_gtk_data() if $extra > 1;
	}
	eval $end if $b_log;
}

========================================
get_gtk_version()
----------------------------------------

Because this test was absurdly slow, and almost always fails on newer systems,
I believe it used to work but this is such a hack, and so slow, that I removed 
it completely in 3.0.19, and all calls to it were removed in 3.0.18 

I left in a stub that is commented out in case we want to have real gtk toolkit.

This was located in DesktopData 

sub set_gtk_data {
	eval $start if $b_log;
	my ($version,$program,@data);
	# this is a hack, and has to be changed with every toolkit version change, and 
	# only dev systems 	# have this installed, but it's a cross distro command try it.
	if ($program = main::check_program('pkg-config')){
		@data = main::grabber("$program --modversion gtk+-4.0 2>/dev/null");
		$version = main::awk(\@data,'\S');
		# note: opensuse gets null output here, we need the command to get version and output sample
		if ( !$version ){
			@data = main::grabber("$program --modversion gtk+-3.0 2>/dev/null");
			$version = main::awk(\@data,'\S');
		}
		if ( !$version ){
			@data = main::grabber("$program --modversion gtk+-2.0 2>/dev/null");
			$version = main::awk(\@data,'\S');
		}
	}
	# now let's go to more specific version tests, this will never cover everything and that's fine.
	if (!$version){
		# we'll try some known package managers next. dpkg will handle a lot of distros 
		# this is the most likely order as of: 2014-01-13. Not going to try to support all 
		# package managers too much work, just the very biggest ones.
		if ($program = main::check_program('dpkg')){
			@data = main::grabber("$program -s libgtk-3-0 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s+');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -s libgtk-4-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s+');
			}
			if (!$version){
				@data = main::grabber("$program -s libgtk2.0-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s+');
			}
		}
		elsif ($program = main::check_program('pacman')){
			@data = main::grabber("$program -Qi gtk3 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -Qi gtk4 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
			if (!$version){
				@data = main::grabber("$program -Qi gtk2 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
		}
		elsif ($program = main::check_program('rpm')){
			@data = main::grabber("$program -qi libgtk-3-0 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -qi libgtk-4-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
			if (!$version){
				@data = main::grabber("$program -qi libgtk-3-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
		}
	}
	$desktop[2] = 'Gtk';
	eval $end if $b_log;
}

========================================
set_lsusb_data() set_lsusb_data_v() 
----------------------------------------

sub set_lsusb_data {
	eval $start if $b_log;
	my ($content,@data);
	my $b_live = 1;
	if ($b_live){
		my $path = check_program('lsusb');
		@data = grabber("$path 2>/dev/null") if $path;
	}
	else {
		open my $fh, '<', "$ENV{'HOME'}/bin/scripts/inxi/data/lsusb/mdmarmer-lsusb.txt" or die $!;
		chomp(@data = <$fh>);
	}
	foreach (@data){
		next if /^\s*$|^Couldn't/; # expensive second call: || /UNAVAIL/
		my @working = split /\s+/, $_;
		$working[3] =~ s/:$//;
		my $id = int($working[3]);
		if ($id > 1){
			my $bus = int($working[1]);
			my $chip = $working[5];
			my @temp = @working[6..$#working];
			my $name = join ' ', @temp;
			if ($name !~ /hub/i){
				@usb = (@usb,[$bus,$id,$chip,$name]);
			}
		}
	}
	UsbSysData::set('lsusb') if @usb;
	print Dumper \@usb if $test[6];
	main::log_data('dump','@usb: plain',\@usb) if $b_log;
	eval $end if $b_log;
}

sub set_lsusb_data_v {
	eval $start if $b_log;
	my ($content,@data,@working,$bus_id,$device_id,$id,$b_skip);
	my $j = 0;
	my $b_live = 1;
	if ($b_live){
		my $path = check_program('lsusb');
		@data = grabber("$path -v 2>/dev/null") if $path;
	}
	else {
		my $file;
		#$file = "$ENV{'HOME'}/bin/scripts/inxi/data/lsusb/mdmarmer-lsusb-v.txt";
		#$file = "$ENV{'HOME'}/bin/scripts/inxi/data/lsusb/lsusb-v-dz64.txt";
		#$file = "$ENV{'HOME'}/bin/scripts/inxi/data/lsusb/x541na-lsusb-v.txt";
		open my $fh, '<', $file or die $!;
		chomp(@data = <$fh>);
	}
	foreach (@data){
		# we won't need all the lsusb data, so set it to skip
		# after the last item we might want
		# Couldn't open device, some information will be missing
		next if /^\s*$|^Couldn't/; # expensive second call: || /UNAVAIL/
		if (!$b_skip && $bus_id && /^\s\s/){
			#if ($_ =~ /\bDescriptor\b:/){
			if ($_ =~ /^\s+([\S]+)\sDescriptor:/){
				#$_ =~ /^\s+([\S]+)\sDescriptor:/;
				$_ = "Descriptor_$1";
			}
			else {
				$_ =~ s/^\s\s|[\s]+$//g;
				$_ =~ s/^[\s]+/~/g;
				#$_ =~ s/[\s]+$//g;
				$_ =~ s/\sType/_Type/g;
				$_ =~ s/^([\S]+)[\s]+(.*)//;
				my $one = ($1) ? $1: '';
				my $two = ($2) ? $2: '';
				$_ = "$one:$two";
				$b_skip = 1 if $one eq '~bInterfaceProtocol';
				#$_ = cleaner($_);
				if (/([\S]+):([0-9]+|0x[0-9a-f]+)\s(.*)/){
					$_ = "$1:$2:$3";
					#$b_skip = 1 if $1 eq '~bInterfaceProtocol';
				}
				#print "$1\n";
			}
			push @working, $_;
		}
		# note; nNbrPorts is only available for root?
		elsif (/^Bus\s([0-9]+)\sDevice\s([0-9]+):\sID\s(([0-9a-f]{4}):([0-9a-f]{4})).*/){
		#elsif (/^Bus\s/){
			#if (/^Bus\s([0-9]+)\sDevice\s([0-9]+):\sID\s(([0-9a-f]{4}):([0-9a-f]{4})).*/){
				$j = scalar @usb;
				$bus_id = int($1); # trim off leading 0's
				$device_id = int($2);
				$id = $3;
				$b_skip = 0;
				if (@working){
					$usb[$j] = ([@working],);
				}
				@working = ($bus_id,$device_id,$id);
			#}
		}
	}
	if (@working){
		$j = scalar @usb;
		$usb[$j] = ([@working],);
	}
	# this also sorts @usb
	main::log_data('dump','@usb: v-pre-sys',\@usb) if $b_log;
	UsbSysData::set('lsusb') if @usb;
	print Dumper \@usb if $test[6];
	main::log_data('dump','@usb: v-post-sys',\@usb) if $b_log;
	eval $end if $b_log;
}

========================================
get_usb_drivers()
----------------------------------------

called in: AudioData::usb_data()
					#@temp2 = main::get_usb_drivers($row[0],$row[2]) if !$bsd_type && -d "/sys/devices";
					#if (@temp2 && $temp2[0]){
					#	$driver = $temp2[0];
					#}
					$driver ||= 'snd-usb-audio';
					
called in NetworkData::usb_data()
				#@temp2 = main::get_usb_drivers($row[0],$row[2]) if !$bsd_type && -d "/sys/devices";
				#if (@temp2){
				#	$driver = $temp2[0] if $temp2[0];
				#	$path = $temp2[1] if $temp2[1];
				#}
				$driver ||= 'usb-network';
				
# NOTE: annoyingly, /sys does NOT actually use the id, it uses 
# the count of physical devices, starting at 0 for hub, on the bus.
# args: $1 - $bus number; $2 - vendor:chip id
sub get_usb_drivers {
	eval $start if $b_log;
	my ($bus,$id) = @_;
	return if !$bus || !$id;# these will be > 0
	my ($chip,$driver,$file,$path,$vendor,$working,$working2,@drivers,@temp);
	@temp = split /:/, $id;
	$vendor = $temp[0];
	$chip = $temp[1];
	# some have it one level deeper than others
	my @globs = ("/sys/bus/usb/devices/usb$bus/$bus-*/","/sys/bus/usb/devices/usb$bus/$bus-*/$bus-*/");
	foreach (@globs){
		$path = get_usb_path($vendor,$chip,$_);
		last if $path;
	}
	if ($path){
		if ( -e "${path}driver"){
			if ($working = Cwd::abs_path("${path}driver")){
				$working =~ s/^.*\///;
				if ($working && $working ne 'usb' && $working ne 'usbhid'){
					push @drivers, $working;
				}
			}
		}
		# test 2
		@temp = main::globber("$path$bus-*/");
		#print "@temp\n";
		foreach (@temp){
			#print "p2:". $_ . "driver\n";
			$file = $_ . 'driver';
			#print "f:$file\n";
			if (-e $file){
				#print "here\n";
				#print (Cwd::abs_path($file), "\n");
				if ($working = Cwd::abs_path($file)){
					#print "w:$working\n";
					$working =~ s/^.*\///;
					if ($working && $working ne 'usb' && $working ne 'usbhid' && ! grep {/$working/} @drivers){
						push @drivers, $working;
					}
				}
			}
		}
		#print join "\n", @drivers, "\n";
		$driver = join ',', @drivers if @drivers;
	}
	@temp = ($driver,$path);
	eval $end if $b_log;
	return @temp;
}

sub get_usb_path {
	eval $start if $b_log;
	my ($vendor,$chip,$glob) = @_;
	my ($path,$working,$working2);
	#print "$vendor,$chip,$glob\n";
	my @temp = main::globber($glob);
	#print join "\n", @temp, "\n";
	# first we need to get the device path, since it's not predictable
	foreach (@temp){
		#print "$_\n";
		$working = $_ . 'idVendor';
		$working2 = $_ . 'idProduct';
		if (-e $working && (main::reader($working))[0] eq $vendor && 
		    -e $working2 && (main::reader($working2))[0] eq $chip){
			$path = $_;
			#print "$_\n";
			last;
		}
	}
	eval $end if $b_log;
	return $path
}
