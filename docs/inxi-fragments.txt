================================================================================
INXI FRAGMENTS
================================================================================
FILE:    inxi-fragmentsg.txt
VERSION: 1.1
DATE:    2018-08-11

----------------------------------------
See: optimization.txt
See: perl-setup.txt
See: perl-version_support.txt

----------------------------------------
Comments:

These fragments were in inxi / pinxi, but were removed because they are no 
longer needed or used in this form.

================================================================================

Sections:
1. FRAGMENTS

================================================================================
FRAGMENTS
--------------------------------------------------------------------------------

========================================
get_env_de_data()
----------------------------------------

This was completely rewritten in version 3.0.19, but I want to keep this logic 
in case something goes wrong with the matches of the new looping method.

sub get_env_de_data {
	eval $start if $b_log;
	my ($program,@version_data);
	main::set_ps_gui() if ! $b_ps_gui;
	if ($desktop_session eq 'trinity' || $xdg_desktop eq 'trinity' || (grep {/^tde/} @ps_gui) ){
		$desktop[0] = 'Trinity';
		if ($program = main::check_program('kdesktop')){
			@version_data = main::grabber("$program --version 2>/dev/null");
			$desktop[1] = main::awk(\@version_data,'^TDE:',2,'\s+') if @version_data;
		}
		if ($extra > 1 && @version_data){
			$desktop[2] = 'Qt';
			$desktop[3] = main::awk(\@version_data,'^Qt:',2,'\s+') if @version_data;
		}
	}
	elsif ($xdg_desktop eq 'unity'){
		@data = main::program_values('unity');
		$desktop[0] = $data[3];
		$desktop[0] ||= 'Unity';
		$desktop[1] = main::program_version('cinnamon',$data[0],$data[1],$data[2],$data[5],$data[6]);
		#set_gtk_data() if $extra > 1;
	}
	elsif ( $xdg_desktop =~ /budgie/ ){
		@data = main::program_values('budgie');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('budgie-desktop',$data[0],$data[1],$data[2],$data[5],$data[6]);
	}
	# debian package: lxde-core. 
	# NOTE: some distros fail to set XDG data for root
	elsif ( $xdg_desktop =~ /^(lxde|razor|lxqt)$/ || (grep {/^(razor-session|lxsession|lxqt-session)$/} @ps_gui)){
		# note: openbox-lxde --version may be present, but returns openbox data
		if ($xdg_desktop eq 'lxde' || (grep {/^lxsession$/} @ps_gui )){
			@data = main::program_values('lxde');
			$desktop[0] = $data[3];
			$desktop[1] = main::program_version('lxpanel',$data[0],$data[1],$data[2],$data[5],$data[6]);
		}
		# NOTE: lxqt-about opens a gui dialog
		elsif ($xdg_desktop eq 'razor' || $xdg_desktop eq 'lxqt' || (grep {/^(razor-desktop|lxqt-session)$/} @ps_gui)) {
			if (grep {/^lxqt-session$/} @ps_gui){
				@data = main::program_values('lxqt');
				$desktop[0] = $data[3];
				# BAD: lxqt-about opens dialogue, sigh
				$desktop[1] = main::program_version('lxqt-panel',$data[0],$data[1],$data[2],$data[5],$data[6]);
			}
			elsif (grep {/^razor-session$/} @ps_gui){
				$desktop[0] = 'Razor-Qt';
			}
			else {
				$desktop[0] = 'LX-Qt-Variant';
			}
			set_qt_data() if $extra > 1;
		}
	}
	# note, X-Cinnamon value strikes me as highly likely to change, so just 
	# search for the last part
	elsif ( $xdg_desktop =~ /cinnamon/ ){
		@data = main::program_values('cinnamon');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('cinnamon',$data[0],$data[1],$data[2],$data[5],$data[6]);
		#set_gtk_data() if $extra > 1;
	}
	elsif ($xdg_desktop eq 'pantheon' || $desktop_session eq 'pantheon'){
		@data = main::program_values('pantheon');
		$desktop[0] = $data[3];
		#$desktop[1] = main::program_version('pantheon',$data[0],$data[1],$data[2],$data[5],$data[6]);
		#set_gtk_data() if $extra > 1;
	}
	eval $end if $b_log;
}

========================================
get_gtk_version()
----------------------------------------

Because this test was absurdly slow, and almost always fails on newer systems,
I believe it used to work but this is such a hack, and so slow, that I removed 
it completely in 3.0.19, and all calls to it were removed in 3.0.18 

I left in a stub that is commented out in case we want to have real gtk toolkit.

This was located in DesktopData 

sub set_gtk_data {
	eval $start if $b_log;
	my ($version,$program,@data);
	# this is a hack, and has to be changed with every toolkit version change, and 
	# only dev systems 	# have this installed, but it's a cross distro command try it.
	if ($program = main::check_program('pkg-config')){
		@data = main::grabber("$program --modversion gtk+-4.0 2>/dev/null");
		$version = main::awk(\@data,'\S');
		# note: opensuse gets null output here, we need the command to get version and output sample
		if ( !$version ){
			@data = main::grabber("$program --modversion gtk+-3.0 2>/dev/null");
			$version = main::awk(\@data,'\S');
		}
		if ( !$version ){
			@data = main::grabber("$program --modversion gtk+-2.0 2>/dev/null");
			$version = main::awk(\@data,'\S');
		}
	}
	# now let's go to more specific version tests, this will never cover everything and that's fine.
	if (!$version){
		# we'll try some known package managers next. dpkg will handle a lot of distros 
		# this is the most likely order as of: 2014-01-13. Not going to try to support all 
		# package managers too much work, just the very biggest ones.
		if ($program = main::check_program('dpkg')){
			@data = main::grabber("$program -s libgtk-3-0 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s+');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -s libgtk-4-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s+');
			}
			if (!$version){
				@data = main::grabber("$program -s libgtk2.0-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s+');
			}
		}
		elsif ($program = main::check_program('pacman')){
			@data = main::grabber("$program -Qi gtk3 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -Qi gtk4 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
			if (!$version){
				@data = main::grabber("$program -Qi gtk2 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
		}
		elsif ($program = main::check_program('rpm')){
			@data = main::grabber("$program -qi libgtk-3-0 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -qi libgtk-4-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
			if (!$version){
				@data = main::grabber("$program -qi libgtk-3-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
		}
	}
	$desktop[2] = 'Gtk';
	eval $end if $b_log;
}

========================================
get_usb_drivers()
----------------------------------------

called in: AudioData::usb_data()
					#@temp2 = main::get_usb_drivers($row[0],$row[2]) if !$bsd_type && -d "/sys/devices";
					#if (@temp2 && $temp2[0]){
					#	$driver = $temp2[0];
					#}
					$driver ||= 'snd-usb-audio';
					
called in NetworkData::usb_data()
				#@temp2 = main::get_usb_drivers($row[0],$row[2]) if !$bsd_type && -d "/sys/devices";
				#if (@temp2){
				#	$driver = $temp2[0] if $temp2[0];
				#	$path = $temp2[1] if $temp2[1];
				#}
				$driver ||= 'usb-network';
				
# NOTE: annoyingly, /sys does NOT actually use the id, it uses 
# the count of physical devices, starting at 0 for hub, on the bus.
# args: $1 - $bus number; $2 - vendor:chip id
sub get_usb_drivers {
	eval $start if $b_log;
	my ($bus,$id) = @_;
	return if !$bus || !$id;# these will be > 0
	my ($chip,$driver,$file,$path,$vendor,$working,$working2,@drivers,@temp);
	@temp = split /:/, $id;
	$vendor = $temp[0];
	$chip = $temp[1];
	# some have it one level deeper than others
	my @globs = ("/sys/bus/usb/devices/usb$bus/$bus-*/","/sys/bus/usb/devices/usb$bus/$bus-*/$bus-*/");
	foreach (@globs){
		$path = get_usb_path($vendor,$chip,$_);
		last if $path;
	}
	if ($path){
		if ( -e "${path}driver"){
			if ($working = Cwd::abs_path("${path}driver")){
				$working =~ s/^.*\///;
				if ($working && $working ne 'usb' && $working ne 'usbhid'){
					push @drivers, $working;
				}
			}
		}
		# test 2
		@temp = main::globber("$path$bus-*/");
		#print "@temp\n";
		foreach (@temp){
			#print "p2:". $_ . "driver\n";
			$file = $_ . 'driver';
			#print "f:$file\n";
			if (-e $file){
				#print "here\n";
				#print (Cwd::abs_path($file), "\n");
				if ($working = Cwd::abs_path($file)){
					#print "w:$working\n";
					$working =~ s/^.*\///;
					if ($working && $working ne 'usb' && $working ne 'usbhid' && ! grep {/$working/} @drivers){
						push @drivers, $working;
					}
				}
			}
		}
		#print join "\n", @drivers, "\n";
		$driver = join ',', @drivers if @drivers;
	}
	@temp = ($driver,$path);
	eval $end if $b_log;
	return @temp;
}

sub get_usb_path {
	eval $start if $b_log;
	my ($vendor,$chip,$glob) = @_;
	my ($path,$working,$working2);
	#print "$vendor,$chip,$glob\n";
	my @temp = main::globber($glob);
	#print join "\n", @temp, "\n";
	# first we need to get the device path, since it's not predictable
	foreach (@temp){
		#print "$_\n";
		$working = $_ . 'idVendor';
		$working2 = $_ . 'idProduct';
		if (-e $working && (main::reader($working))[0] eq $vendor && 
		    -e $working2 && (main::reader($working2))[0] eq $chip){
			$path = $_;
			#print "$_\n";
			last;
		}
	}
	eval $end if $b_log;
	return $path
}
