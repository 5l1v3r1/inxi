================================================================================
PERL PROGRAMMING
================================================================================
FILE:    perl_programming.txt
VERSION: 2.3
DATE:    2017-12-08

----------------------------------------
See: perl_setup.txt
See: perl_version_support.txt

----------------------------------------
Comments:

Collection of useful Perl development information.

This guy's docs are much more usable than most:
https://www.caveofprogramming.com/categories/perl-tutorial/index.html

================================================================================

Sections:
1. PERL BASICS
2. AWK TO PERL
3. BASH TO PERL
4. EXAMPLES
5. SHELL COMMAND EQIVALENTS
6. EQUIVALENTS
7. SHELLS

================================================================================
PERL BASICS
--------------------------------------------------------------------------------

Collection of Perl ways of doing things that might not be super intuitive
if you are used to other languages.

========================================
RESOURCES
----------------------------------------

Books: O'Reilly:

LP: Learning Perl (3rd edition, 2001)
LPO: Learning Perl Objects, References, and Modules (1st edition, 2003)
PCB: Perl Cookbook
PP: Programming Perl
A2P: awk to perl output

SSP:
https://stackoverflow.com/questions/1152400/how-can-i-translate-a-shell-script-to-perl
community wiki answer

========================================
BASICS
----------------------------------------

----------------------------------------
use
----------------------------------------

https://perldoc.perl.org/functions/use.html

BEGIN { require Module; Module->import( LIST ); }
 
use Module 12.34; 
# exactly equivalent to:
BEGIN { require Module; Module->VERSION(12.34) }

----------------------------------------
ARGV, ARRAYS IN GENERAL
----------------------------------------

Scalar value @ARGV[0] better written as $ARGV[0]...

----------------------------------------
hashes
----------------------------------------

slightly odd:

%seen = (); # declare hash, not array

$seen{'a'} = 'fred';
$seen{'b'} = 'bob';

sort(keys, %seen);

convert hash to array
my @a = values %h;

----------------------------------------
arrays
----------------------------------------

$string = 'hello how are you?';

@allwords = split(" ", $string); # whitespace: 1 or more spaces
$revwords = join(" ", reverse @allwords);
print $revwords , "\n";


----------------------------------------
Boolean/defined
----------------------------------------

$a = $b || $c

$x ||= $y; # please do not use this, it's too hard to read

$foo = $bar || 'DEFAULT VALUE';

$dir = shift(@ARGV) || '/tmp';

@a = @b unless @a; # copy only if empty

----------------------------------------

# don't use this please, gets hard to read, hides bugs
$a = defined($b) ? $b : $c; 

use v5.9;
$a = $b // $c;

$a //= $y; # please do not use this

// is defined-or

false always: 0, "0", ""

========================================
FEATURE
----------------------------------------

https://perldoc.perl.org/feature.html
{
	use feature 'say';
	say "say is available here";
}
print "But not here.\n";

use feature 'say';
say "say is available here";
{
	no feature 'say';
	print "But not here.\n";
}
say "Yet it is here.";


========================================
FILES
----------------------------------------

NOTE: .pl stands for perl library

----------------------------------------
OPEN, WRITE
----------------------------------------

open(my $fh, '>', $fpath) or die "Could not open file '$fpath' $!";
print $fh $content;
close $fh;

----------------------------------------
READING FILES
----------------------------------------

for my $file (@ARGV) {
  print "$file is a file\n" if -f "$file";
  print "$file is a directory\n" if -d "$file";
  print "I can read $file\n" if -r "$file";
  print "I can write to $file\n" if -w "$file";
}

for my $file (glob("*")) {
  print $file;
  print "*" if -x "$file" && ! -d "$file";
  print "/" if -d "$file";
  print "\t";
}

sub list_dir($$) {
  my ($dir, $prefix) = @_;
  my $newprefix = $prefix;
  if ($prefix eq "") {
    $newprefix = $dir;
  } else {
    $newprefix .= "/$dir";
  }
  chdir $dir;
  for my $file (glob("*")) {
    print "$prefix/" if $prefix ne "";
    print "$dir/$file\n";
    list_dir($file, $newprefix) if -d "$file";
  }
  chdir "..";
}

list_dir(".", "");

----------------------------------------
INCLUDING FILES
----------------------------------------

sub load_common_subroutines {
  open MORE_CODE, "navigation.pl" or die "navigation.pl: $!";
  undef $/; # enable slurp mode
  my $more_code = <MORE_CODE>;
  close MORE_CODE;
  eval $more_code;
  die $@ if $@;
}

do "navigation.pl";
die $@ if $@;

require "drop_anchor.pl";
require "navigate.pl";

LPO 2.5.1
# paths for perl files?
unshift @INC, "/home/skipper/perl-lib";

----------------------------------------
OPEN READ PRINT TO OTHER FILE
----------------------------------------

my $filename = "whatever";
my $anotherfile = "another";
open (FILE, "$filename") || die "Could not open $filename!\n";
open OUT, ">", "$anotherfile" or die "Could not open $anotherfile for writing!\n";
while(<FILE>) {
  print OUT $_;
}
close FILE;

========================================
MODULES - CHECK AVAILABLE
----------------------------------------

http://www.perlmonks.org/?node_id=691741

-----------------------------------------

my $scan_foo = 1;

eval "use File::stat";
if ( $@ ) {
     $scan_foo = 0;
}



-----------------------------------------
use HTML::Perlinfo::Modules;

my $m = HTML::Perlinfo::Modules->new();
my $module = $m->print_modules( show_only => qr/FOO::bar/i );

if ($module) {
  my $foobarzlot=sprintf("%d,",bar(FILE)->zlot);
  print "FOOBARZLOT=".$foobarzlot."\n";
}


Note that it is very easy to look up multiple modules by simply adding 
them to the precompiled regular expression. For example:

my $modules = $m->print_modules( show_only => qr/FOO::bar|File::Which|
+File::stat/i );

========================================
SHORTCUTS
----------------------------------------

s/// m// tr///

$string = 'this is what you have';

substr($string, -10 =~ /pattern/; # match for tests etc

substr($string,0,5) =~ s/is/at/g;

========================================
VARIABLES
----------------------------------------

----------------------------------------
variable tricks
----------------------------------------

($var1, $var2) = ($var2, $var1); # swap values


========================================
UNICODE
----------------------------------------

PCB: 1.8

This may matter for color codes

$string ="fac\x{0327}ade"; # fa√ßade

----------------------------------------
charnames
----------------------------------------

use charnames ':full';
print "\N{GREEK CAPITAL LETTER DELTA} is called delta\n";

user charnames ':short';
print "\N{greek:Delta} is called delta\n";


================================================================================
AWK TO PERL
--------------------------------------------------------------------------------

========================================
INSTALL a2p/s2p
----------------------------------------

Install: 

awk to perl:
 cpan App::a2p

sed to perl:
 cpan App::s2p 
 
 
========================================
FIELD/RECORD SEPARATORS
----------------------------------------

$, = ' ';  # set output field separator
$\ = "\n"; # set output record separator

================================================================================
BASH TO PERL
--------------------------------------------------------------------------------

========================================
BASH TO PERL: PERLMONKS
----------------------------------------

http://www.perlmonks.org/?node_id=627015

----------------------------------------

. 	do 	built-in
awk 	perl ;-) (often 'split') 	built-in 
	See also a2p	Base program
basename 	File::Basename::basename 	Base module
cat 	while(<>){print} 	built-in
	ExtUtils::Command::cat 	Base module
cd 	chdir 	built-in
chmod 	chmod 	built-in
chown 	chown 	built-in
cp 	File::Copy 	Base module
	ExtUtils::Command::cp 	Base module
cut 	split 	built-in
date 	localtime 	built-in
	POSIX::strftime 	Base module
declare 	see typedef 	
df 	Filesys::Df 	CPAN
diff 	File::Compare 	Base module
dirname 	File::Basename::dirname 	Base modules
echo 	print 	built-in
egrep 	while(<>){print if /re/} 	built-in
eval 	eval 	built-in
exec 	exec 	built-in
	pipe (co-processes) 	built-in
	open (file descriptors) 	built-in
export 	Assign to %ENV 	Hash variable
	Env::C 	CPAN
find 	File::Find::find 	Base module
ftp 	Net::Ftp 	Base module
function 	sub 	built-in
grep 	see egrep 	
hostname 	Sys::Hostname::hostname	Base module
integer 	int 	built-in
kill 	kill 	built-in
ln 	link 	built-in
ln -s 	symlink 	built-in
ls 	glob 	built-in
	opendir/readdir/closedir 	built-in
	stat/lstat 	built-in
mkdir 	mkdir 	built-in
mkpath 	ExtUtils::Command::mkpath 	Base module
mv 	rename 	built-in
	ExtUtils::Command::mv 	Base module
od 	ord 	built-in
	printf 	built-in
print 	print 	built-in
printf 	printf 	built-in
ps 	Proc::ProcessTable 	CPAN
pwd 	Cwd::getcwd 	Base module
rand 	rand 	built-in
read 	See I/O Operators 	built-in
rm 	unlink 	built-in
	ExtUtils::Command::rm 	Base module
rm -f 	ExtUtils::Command::rm_rf 	Base module
sed 	s/// (usually) 	built-in
	See also s2p	Base program
select 	Shell::POSIX::select 	CPAN
sleep 	sleep 	built-in
	alarm 	built-in
sort 	sort 	built-in
source 	do 	built-in
tail 	File::Tail 	CPAN
telnet 	Net::Telnet 	CPAN>
times 	times 	built-in
touch 	open/close 	built-in
	ExtUtils::Command::touch 	Base module
trap 	%SIG 	Hash
	sigtrap 	pragma
typeset 	my 	built-in
typeset -i 	int 	built-in
typeset -l 	lc 	built-in
typeset -u 	uc 	built-in
typeset -Z 	sprintf 	built-in
which 	which 	File::Which

========================================
BASH TO PERL: SSP
----------------------------------------

----------------------------------------
CAT
----------------------------------------

https://metacpan.org/pod/perlfaq5#How-can-I-read-in-an-entire-file-all-at-once

NOTE:
neither 
Path::Tiny;
File::Map
are in standard core so not using those, but they aren't necessary either

This works fine. This is the type of perl that is fine to use in non user
viewed functions, but which I want to avoid in the get data area.

my $contents = do { local( @ARGV, $/ ) = $file; <> };

----------------------------------------
CUT
----------------------------------------

while(<>) {
  my @array = split ",";
  print $array[3], "\n";
}

for long lines, faster

while(<>) {
  my ($column) = /^(?:[^,]*,){3}([^,]*),/;
  print $column, "\n";
}
columns:

while(<>) {
  print substr($_, 5, 10), "\n";
}

----------------------------------------
GREP
----------------------------------------

my $pattern = $ARGV[0];
shift @ARGV;
while(<>) {
        print $_ if /$pattern/o;
}

'o' == compile pattern only once

/$pattern/
is the same as:
$_ =~ m/$pattern/

----------------------------------------
HEAD
----------------------------------------

reads all file:

my $printlines = abs(shift);
my $lines = 0;
my $current;
while(<>) {
  if($ARGV ne $current) {
    $lines = 0;
    $current = $ARGV;
  }
  print "$_" if $lines < $printlines;
  $lines++;
}

faster:

my $printlines = abs(shift);
my @files;
if(scalar(@ARGV) == 0) {
  @files = ("-");
} else {
  @files = @ARGV;
}
for my $file (@files) {
  next unless -f $file && -r $file;
  open FILE, "<", $file or next;
  my $lines = 0;

  while(<FILE>) {
    last if $lines == $printlines;
    print "$_";
    $lines++;
  }

  close FILE;
}


----------------------------------------
SLICE Xth ITEM
----------------------------------------

A2P:

Slice out 3rd, assuming separator ' '

while (<>) reads from either file or stdin

gawk '{print $3}'

perl -e 'while (<>){ @a = split(" ", $_); print @a[2] . "\n";} '

like 'cat' for file or stdin

while(<>) {
  print $_;
}

----------------------------------------
SORT
----------------------------------------

sort array:

my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print sort @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
}
print sort @lines;

sort numbers:

my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print sort @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
}
print sort {$a <=> $b} @lines;

----------------------------------------
TAIL
----------------------------------------

my $skiplines = abs(shift);
my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
  shift @lines if $#lines == $skiplines;
}
print @lines;

----------------------------------------
UNIQ
----------------------------------------

my $current = "";
my %lines;
while(<>) {
  if($ARGV ne $current) {
    undef %lines;
    $current = $ARGV;
  }
  print $_ unless defined($lines{$_});
  $lines{$_} = "";
}

----------------------------------------
WC
----------------------------------------

my $current;
my %lines;
my %words;
my %chars;
while(<>) {
  $lines{"$ARGV"}++;
  $chars{"$ARGV"} += length($_);
  $words{"$ARGV"} += scalar(grep {$_ ne ""} split /\s/);
}

for my $file (keys %lines) {
  print "$lines{$file} $words{$file} $chars{$file} $file\n";
}

================================================================================
EXAMPLES
--------------------------------------------------------------------------------

inxi: 998

xset q 2>/dev/null | grep -i 'Log file' | gawk '{print $3}')

echo 'this is a log file really!' | perl -e 'while (<>) { chomp; 
if ( /Log file/i )  { @Fld = split(" ", $_, -1);  
print $Fld[(3)-1] . "\n"; } }'

check if available, avoid system('which program &>/dev/null') subshell
https://stackoverflow.com/questions/1882101/how-can-i-quickly-check-if-linux-unzip-is-installed-using-perl
print "tput installed\n" if grep { -x "$_/tput"}split /:/,$ENV{PATH}

========================================
PRINTING LINES, INDENTATION
----------------------------------------

my $i=20;
my $j=2;
my $l = sprintf("%4s %6s",'-f,','--full');
my $k = sprintf("%4s %6s",'-y,','--widths');
my $m = sprintf("%4s %6s",'','--other-stuff');
printf("%-${i}s%s\n", "$l", "Now this will work?");
printf("%-${i}s%s\n", "$k", "Now this will work?");
printf("%-${i}s%s\n", "$m", "Now this will work?");
my $h = ($i+$j);
printf("%-${h}s%s\n", "", "* info about it working!!");

OUTPUT:

 -f, --full         Now this will work?
 -y, --widths       Now this will work?
     --other-stuff  Now this will work?
                      * info about it working!!

================================================================================
SHELL COMMAND EQIVALENTS
--------------------------------------------------------------------------------

We want to avoid all possible subshells, but we also want to avoid any 
dependencies on non standard core modules.

https://perldoc.perl.org/POSIX.html

========================================
UNAME
----------------------------------------

use POSIX qw(uname);
my @uname = uname();
print $uname[0] . " " . $uname[2];

NOTE: from the POSIX.html docs:

Get name of current operating system.

($sysname, $nodename, $release, $version, $machine)
= POSIX::uname();

Note that the actual meanings of the various fields are not that well 
standardized, do not expect any great portability. The $sysname might 
be the name of the operating system, the $nodename might be the name 
of the host, the $release might be the (major) release number of the 
operating system, the $version might be the (minor) release number of 
the operating system, and the $machine might be a hardware 
identifier. Maybe.

================================================================================
EQUIVALENTS
--------------------------------------------------------------------------------


========================================
ARRAYS
----------------------------------------

See: print_r

https://www.caveofprogramming.com/perl-tutorial/perl-array-quick-guide-to-arrays-in-perl.html

----------------------------------------
ADDING / REMOVING
----------------------------------------

----------------------------------------
ADDING:

sadly, no $array[] = 'something'; auto incrementing

so:
Add to end:

push @array, 'something';

Add to beginning:

unshift @array, 'something';


# Append to the first array
# We need to typecast the reference to an 
# array before using push.
push @{$stuff[0]}, 'kiwi';

Perl has the ability to have an extra comma at the end of a list. For example:

my @array = (
	'This thing',
	'That thing',
);

----------------------------------------
REMOVING:

These are both fairly pointless in my experience but I include them
here for completion's sake, with one exception, if we have split a
line and want to get the first or last item without counting it.

Note that these REMOVE the item, they don't just give it. This is 
something that might in rare cases be useful, like if you want the second
to the last item, or second item, and don't care about the first or last.

# Remove the last item ('something') and save it.
my $end = pop @array; 

# Remove first item off the array and save it.
my $start = shift @array;

----------------------------------------
ARRAY OF ARRAYS
----------------------------------------

http://perldoc.perl.org/perllol.html

NOTE the different brackets. 

my @stuff = (
    ['apple', 'orange', 'banana'],
    [42, 1234],
    ['some', 'more', 'stuff', 'here'],
    ['assorted', 100, 0.7, 'hello']
);

better:
my @fruits = ('apple', 'orange', 'banana');
my @numbers = (42, 1234);
my @strings = ('some', 'more', 'stuff', 'here');
my @assorted = ('assorted', 100, 0.7, 'hello');

BUT:: if you use push, then you have to use [] for the
sub arrays. Sigh.

# Build an array from references to the above arrays.
# (The same trick works with references to hashes!)

my @stuff = (@fruits, @numbers, @strings, @assorted);

print $stuff[2][0]; # prints 'some'

----------------------------------------
IS_ARRAY
----------------------------------------

http://www.perlmonks.org/?node_id=118961

look at the ref() function in perl, it tells you the type of ref you have.

----------------------------------------

foreach $item (@array){
   if(ref($item) eq 'ARRAY'){
      #It's an array reference...
      #you can read it with $item->[1]
      #or dereference it uisng @newarray = @{$item}
   }else{
      #not an array in any way...
   }
}

----------------------------------------

use UNIVERSAL 'isa';

foreach $item (@array) {
	if (isa($item, 'ARRAY')) {
		print "We've got an array!!\n";
	}
}

----------------------------------------
COUNT / LENGTH
----------------------------------------

ARRAY:
scalar @array;
OR
my $size = @array;

HASH:

NOTE: to count a hash, you have to do this, sigh...
$count = keys %hash;

NOTE: print "@array\n"; prints out the contents, not the count.

The quotes make the difference.

----------------------------------------
MAP/GREP
----------------------------------------

my @text = ('catfish', 'badger', 'dogfish', 'aardvark');

my @fish = grep(/fish/, @text);

print join(', ', @fish);

# prints: catfish, dogfish

----------------------------------------


my @names = ('Bob', 'Pete', 'Sue', 'Alice');

my @prefixed = map("NAME: $_", @names);

print join(', ', @prefixed);

# Prints:
# NAME: Bob, NAME: Pete, NAME: Sue, NAME: Alice

----------------------------------------
MULTI DIMENSIONAL ASSOCIATIVE ARRAYS
----------------------------------------

http://www.perlmonks.org/?node_id=1978

my %a = (
'a' => 'hello',
'b' => { 'c' => 'world'}
);
print "$a{'a'} $a{'b'}{'c'}\n";

$hash{toes} = { 
    biggest => 'hairy troll',
    smallest => 'toddler',
};

http://www.perlmonks.org/?node_id=421382

foreach my $outter (keys %hash) {
  foreach my $inner (keys %{$hash{$outter}}) {
    print "$outter - $inner = ", $hash{$outter}{$inner}, "\n";
  }
}

$hash{foo}->{bar}->{beer}="free";
$hash{foo}{bar}{beer}="free"

%hash = (
	arms => {
		biggest  => 'mine',
		smallest => 'yours'
	},
	feet => {
		biggest  => 'right',
		smallest => 'left'
	},
	legs => {
		biggest  => 'theirs',
		smallest => 'them',
		muscular => 'yes'
	}
);

----------------------------------------
PRINTING/DEBUGGING
----------------------------------------

print join(', ', @fruits);

----------------------------------------
SORTING
----------------------------------------

my @strings = ("cat", "dog", "aardvark", "lizard");

my @sorted = sort @strings;

# @sorted is now sorted. @strings remains the same, of course.

print join(', ', @sorted);

# prints:
# aardvark, cat, dog, lizard

----------------------------------------

my @strings = ("cat", "dog", "aardvark", "zebra");

# Sort in reverse alphabetical order 
my @sorted = sort { $b cmp $a } @strings;

print join(', ', @sorted);

# prints:
# zebra, dog, cat, aardvark

---------------------------------------

my @numbers = (1, 6, 4, 3, 10);

# Sort in numerical order
my @sorted = sort { $a <=> $b } @numbers;

print join(', ', @sorted);

# prints:
# 1, 3, 4, 6, 10

---------------------------------------

my @strings = ("cat", "dog", "aardvark", "zebra");

# Sort in order of string length, longest first
my @sorted = sort { length($b) <=> length($a) } @strings;

print join(', ', @sorted);

# prints:
# aardvark, zebra, cat, dog

========================================
ASSIGNMENT IN CONDITIONAL
----------------------------------------

Surprisingly, this seems to work!!

if ( my $mounts = system_files('mounts')){
	print "$mounts\n";
}

========================================
BOOLEANS
----------------------------------------

Perl does not have real booleans, like true/false literals.

It's similar to other languages in how it tests, but to keep pinxi sane, 
let's stick to basics:

$var = undef; false
$var = ''; false

and that's it. Because perl uses 0, > 0 exactly backward from say, shell, 
that's too confusing so just don't use 0 as a test for false. Be careful in 
the code

For tests, that becomes:

if ( $var ){
do stuff
}

or

if ( ! $var ){
do stuff
}

NOTE:
because an array length of 0 is false:

if ( @array ){
do stuff...
}
means the array has at least one index.

NOTE:
if you declare like so:

my ($b_one, $b_two);
then test:

if ( $b_one eq 'true' ){

this will kick out:
Use of uninitialized value $b_conf in string eq at ./pinxi line 315.

on at least bsd perl 5.12, so you have to test only for boolean true false
if ( $b_one ){

========================================
break
----------------------------------------

last;

========================================
foreach ($a_something as $key=>$value){
----------------------------------------

foreach my $key ( keys %info_files ){
print $info_files{$key};
}

========================================
__FUNCTION__
----------------------------------------

(caller(0))[3]

outputs:

main::show_options

Cannot be in ""

========================================
print_r
----------------------------------------

See: ARRAYS

use Data::Dumper qw(Dumper);
print Dumper \%grades;
print "----------------\n";

However, note:

All you have to do is assign the array to a scalar like so:

my $one = @_; 

If the subsequent use of $one is in double quotes, it will output
the contents of the array, and if it is not quoted, it will output 
the array count. Weird.

It takes the args the function that calls it used, passes it to:

$three, and then $three contains the string rather than the array.

========================================
range operator
----------------------------------------

..

[1 .. 5]

my @a = 'a'..'z'; # 26 letters

# a, e, i, o, u...
my @vowels = @a[0,4,8,14,20];

# And sometimes "y"
push( @vowels, $a[-2] ) if rand > .5;

========================================
STATIC VARIABLES
----------------------------------------

5.10 and later:

state ($var);

pre 5.10: 

Don't bother with these hacks, if we want it static, we have
to make it a global, our. Or static within scope, as below.

https://www.cs.ait.ac.th/~on/O/oreilly/perl/cookbook/ch10_04.htm

Wrap the function in another block, and declare my variables in that block's scope rather than the function's:

{
    my $variable;
    sub mysub {
        # ... accessing $variable
    }
}

If the variables require initialization, make that block a BEGIN so the variable is guaranteed to be set before the main program starts running:

BEGIN {
    my $variable = 1;                       # initial value
    sub othersub {                          # ... accessing $variable
    }
}

========================================
SWITCH / CASE
----------------------------------------

Sigh. LOL. Sigh.

http://www.perlmonks.org/?node_id=1054948

http://perldoc.perl.org/perlfaq7.html#How-do-I-create-a-switch-or-case-statement%3f

pre 5.08: hacks, dispatch tables, endless elsif

Note: to use this structure, it must be an actual pattern, or the whole word, if
it's safe to test for whole word. If not, use word boundaries or ^...$


for ($variable_to_test) {
	if    (/pat1/)  { }     # do something
	elsif (/pat2/)  { }     # do something else
	elsif (/pat3/)  { }     # do something else
	else            { }     # default
}

my %commands = (
	"happy" => \&joy,
	"sad",  => \&sullen,
	"done"  => sub { die "See ya!" },
	"mad"   => \&angry,
);
print "How are you? ";
chomp($string = <STDIN>);
if ($commands{$string}) {
	$commands{$string}->();
} else {
	print "No such command: $string\n";
}

5.10 and later: 
switch (given/when) 

given ( $string ) {
	when( 'Fred' )        { say "I found Fred!" }
	when( 'Barney' )      { say "I found Barney!" }
	when( /Bamm-?Bamm/ )  { say "I found Bamm-Bamm!" }
	default               { say "I don't recognize the name!" }
};

========================================
TRAP WARNINGS
----------------------------------------

https://www.caveofprogramming.com/perl-tutorial/perl-eval-using-eval-to-run-code-and-trap-errors-in-perl.html

https://perlmaven.com/how-to-capture-and-save-warnings-in-perl

this would basically emulate the inxi warnings/alerts supression done 
via bash methods, I think.

<<<
The local is important to limit the effect of our change if you are using 
this code within a module. Especially if you distribute it. Without the 
localization the effect would be felt in all the application. The local 
limits it to the enclosing block. 
>>>

local $SIG{__WARN__} = sub {
	die;
};
local $SIG{__WARN__} = sub {
	my $message = shift;
	logger($message);
};
local $SIG{__WARN__} = sub {
	my $message = shift;
	die $message;
};

https://perlmaven.com/use-of-uninitialized-value

Turning off buffering

In order to avoid this you can turn off the buffering of STDOUT.

This is done by the following code: $| = 1; at the beginning of the script.

use warnings;
use strict;
use 5.010;

$| = 1;

================================================================================
SHELLS
--------------------------------------------------------------------------------

https://robots.thoughtbot.com/the-unix-shells-humble-if

inxi will at times use a subshell, so it's important that all inxi subshell
commands are fully POSIX compliant. That's a good explanation of what to do and
not to do. Since all my shell code has always been Bash, I have to be careful 
to avoid letting bashisms slip into subshells.

There will not be many subshells, but I believe most of the debugger data 
collector will be done via subshell, otherwise the perl equivalents would  
make the size mushroom unacceptably.
