================================================================================
PERL PROGRAMMING
================================================================================
FILE:    perl_programming.txt
VERSION: 1.5
DATE:    2017-12-02

----------------------------------------
See: perl_setup.txt
See: perl_version_support.txt

----------------------------------------
Comments:

Collection of useful Perl development information.

================================================================================

Sections:
1. PERL BASICS
2. AWK TO PERL
3. BASH TO PERL
4. EXAMPLES
5. SHELL COMMAND EQIVALENTS

================================================================================
PERL BASICS
--------------------------------------------------------------------------------

Collection of Perl ways of doing things that might not be super intuitive
if you are used to other languages.

========================================
RESOURCES
----------------------------------------

Books: O'Reilly:

LP: Learning Perl (3rd edition, 2001)
LPO: Learning Perl Objects, References, and Modules (1st edition, 2003)
PCB: Perl Cookbook
PP: Programming Perl
A2P: awk to perl output

SSP:
https://stackoverflow.com/questions/1152400/how-can-i-translate-a-shell-script-to-perl
community wiki answer

========================================
BASICS
----------------------------------------

----------------------------------------
use
----------------------------------------

https://perldoc.perl.org/functions/use.html

BEGIN { require Module; Module->import( LIST ); }
 
use Module 12.34; 
# exactly equivalent to:
BEGIN { require Module; Module->VERSION(12.34) }

----------------------------------------
ARGV, ARRAYS IN GENERAL
----------------------------------------

Scalar value @ARGV[0] better written as $ARGV[0]...

----------------------------------------
hashes
----------------------------------------

slightly odd:

%seen = (); # declare hash, not array

$seen{'a'} = 'fred';
$seen{'b'} = 'bob';

sort(keys, %seen);

convert hash to array
my @a = values %h;

----------------------------------------
arrays
----------------------------------------

$string = 'hello how are you?';

@allwords = split(" ", $string); # whitespace: 1 or more spaces
$revwords = join(" ", reverse @allwords);
print $revwords , "\n";


----------------------------------------
Boolean/defined
----------------------------------------

$a = $b || $c

$x ||= $y; # please do not use this, it's too hard to read

$foo = $bar || 'DEFAULT VALUE';

$dir = shift(@ARGV) || '/tmp';

@a = @b unless @a; # copy only if empty

----------------------------------------

# don't use this please, gets hard to read, hides bugs
$a = defined($b) ? $b : $c; 

use v5.9;
$a = $b // $c;

$a //= $y; # please do not use this

// is defined-or

false always: 0, "0", ""

========================================
FILES
----------------------------------------

NOTE: .pl stands for perl library

----------------------------------------
OPEN, WRITE
----------------------------------------

open(my $fh, '>', $fpath) or die "Could not open file '$fpath' $!";
print $fh $content;
close $fh;

----------------------------------------
READING FILES
----------------------------------------

for my $file (@ARGV) {
  print "$file is a file\n" if -f "$file";
  print "$file is a directory\n" if -d "$file";
  print "I can read $file\n" if -r "$file";
  print "I can write to $file\n" if -w "$file";
}

for my $file (glob("*")) {
  print $file;
  print "*" if -x "$file" && ! -d "$file";
  print "/" if -d "$file";
  print "\t";
}

sub list_dir($$) {
  my ($dir, $prefix) = @_;
  my $newprefix = $prefix;
  if ($prefix eq "") {
    $newprefix = $dir;
  } else {
    $newprefix .= "/$dir";
  }
  chdir $dir;
  for my $file (glob("*")) {
    print "$prefix/" if $prefix ne "";
    print "$dir/$file\n";
    list_dir($file, $newprefix) if -d "$file";
  }
  chdir "..";
}

list_dir(".", "");

----------------------------------------
INCLUDING FILES
----------------------------------------

sub load_common_subroutines {
  open MORE_CODE, "navigation.pl" or die "navigation.pl: $!";
  undef $/; # enable slurp mode
  my $more_code = <MORE_CODE>;
  close MORE_CODE;
  eval $more_code;
  die $@ if $@;
}

do "navigation.pl";
die $@ if $@;

require "drop_anchor.pl";
require "navigate.pl";

LPO 2.5.1
# paths for perl files?
unshift @INC, "/home/skipper/perl-lib";

----------------------------------------
OPEN READ PRINT TO OTHER FILE
----------------------------------------

my $filename = "whatever";
my $anotherfile = "another";
open (FILE, "$filename") || die "Could not open $filename!\n";
open OUT, ">", "$anotherfile" or die "Could not open $anotherfile for writing!\n";
while(<FILE>) {
  print OUT $_;
}
close FILE;


========================================
VARIABLES
----------------------------------------

----------------------------------------
variable tricks
----------------------------------------

($var1, $var2) = ($var2, $var1); # swap values

========================================
SHORTCUTS
----------------------------------------

s/// m// tr///

$string = 'this is what you have';

substr($string, -10 =~ /pattern/; # match for tests etc

substr($string,0,5) =~ s/is/at/g;

========================================
FEATURE
----------------------------------------

https://perldoc.perl.org/feature.html
{
	use feature 'say';
	say "say is available here";
}
print "But not here.\n";

use feature 'say';
say "say is available here";
{
	no feature 'say';
	print "But not here.\n";
}
say "Yet it is here.";

========================================
UNICODE
----------------------------------------

PCB: 1.8

This may matter for color codes

$string ="fac\x{0327}ade"; # fa√ßade

----------------------------------------
charnames
----------------------------------------

use charnames ':full';
print "\N{GREEK CAPITAL LETTER DELTA} is called delta\n";

user charnames ':short';
print "\N{greek:Delta} is called delta\n";

================================================================================
AWK TO PERL
--------------------------------------------------------------------------------

========================================
INSTALL a2p/s2p
----------------------------------------

Install: 

awk to perl:
 cpan App::a2p

sed to perl:
 cpan App::s2p 
 
 
========================================
FIELD/RECORD SEPARATORS
----------------------------------------

$, = ' ';  # set output field separator
$\ = "\n"; # set output record separator

================================================================================
BASH TO PERL
--------------------------------------------------------------------------------

========================================
BASH TO PERL: PERLMONKS
----------------------------------------

http://www.perlmonks.org/?node_id=627015

----------------------------------------

. 	do 	built-in
awk 	perl ;-) (often 'split') 	built-in 
	See also a2p	Base program
basename 	File::Basename::basename 	Base module
cat 	while(<>){print} 	built-in
	ExtUtils::Command::cat 	Base module
cd 	chdir 	built-in
chmod 	chmod 	built-in
chown 	chown 	built-in
cp 	File::Copy 	Base module
	ExtUtils::Command::cp 	Base module
cut 	split 	built-in
date 	localtime 	built-in
	POSIX::strftime 	Base module
declare 	see typedef 	
df 	Filesys::Df 	CPAN
diff 	File::Compare 	Base module
dirname 	File::Basename::dirname 	Base modules
echo 	print 	built-in
egrep 	while(<>){print if /re/} 	built-in
eval 	eval 	built-in
exec 	exec 	built-in
	pipe (co-processes) 	built-in
	open (file descriptors) 	built-in
export 	Assign to %ENV 	Hash variable
	Env::C 	CPAN
find 	File::Find::find 	Base module
ftp 	Net::Ftp 	Base module
function 	sub 	built-in
grep 	see egrep 	
hostname 	Sys::Hostname::hostname	Base module
integer 	int 	built-in
kill 	kill 	built-in
ln 	link 	built-in
ln -s 	symlink 	built-in
ls 	glob 	built-in
	opendir/readdir/closedir 	built-in
	stat/lstat 	built-in
mkdir 	mkdir 	built-in
mkpath 	ExtUtils::Command::mkpath 	Base module
mv 	rename 	built-in
	ExtUtils::Command::mv 	Base module
od 	ord 	built-in
	printf 	built-in
print 	print 	built-in
printf 	printf 	built-in
ps 	Proc::ProcessTable 	CPAN
pwd 	Cwd::getcwd 	Base module
rand 	rand 	built-in
read 	See I/O Operators 	built-in
rm 	unlink 	built-in
	ExtUtils::Command::rm 	Base module
rm -f 	ExtUtils::Command::rm_rf 	Base module
sed 	s/// (usually) 	built-in
	See also s2p	Base program
select 	Shell::POSIX::select 	CPAN
sleep 	sleep 	built-in
	alarm 	built-in
sort 	sort 	built-in
source 	do 	built-in
tail 	File::Tail 	CPAN
telnet 	Net::Telnet 	CPAN>
times 	times 	built-in
touch 	open/close 	built-in
	ExtUtils::Command::touch 	Base module
trap 	%SIG 	Hash
	sigtrap 	pragma
typeset 	my 	built-in
typeset -i 	int 	built-in
typeset -l 	lc 	built-in
typeset -u 	uc 	built-in
typeset -Z 	sprintf 	built-in
which 	which 	File::Which

========================================
BASH TO PERL: SSP
----------------------------------------

----------------------------------------
CUT
----------------------------------------

while(<>) {
  my @array = split ",";
  print $array[3], "\n";
}

for long lines, faster

while(<>) {
  my ($column) = /^(?:[^,]*,){3}([^,]*),/;
  print $column, "\n";
}
columns:

while(<>) {
  print substr($_, 5, 10), "\n";
}

----------------------------------------
GREP
----------------------------------------

my $pattern = $ARGV[0];
shift @ARGV;
while(<>) {
        print $_ if /$pattern/o;
}

'o' == compile pattern only once

/$pattern/
is the same as:
$_ =~ m/$pattern/

----------------------------------------
HEAD
----------------------------------------

reads all file:

my $printlines = abs(shift);
my $lines = 0;
my $current;
while(<>) {
  if($ARGV ne $current) {
    $lines = 0;
    $current = $ARGV;
  }
  print "$_" if $lines < $printlines;
  $lines++;
}

faster:

my $printlines = abs(shift);
my @files;
if(scalar(@ARGV) == 0) {
  @files = ("-");
} else {
  @files = @ARGV;
}
for my $file (@files) {
  next unless -f $file && -r $file;
  open FILE, "<", $file or next;
  my $lines = 0;

  while(<FILE>) {
    last if $lines == $printlines;
    print "$_";
    $lines++;
  }

  close FILE;
}


----------------------------------------
SLICE Xth ITEM
----------------------------------------

A2P:

Slice out 3rd, assuming separator ' '

while (<>) reads from either file or stdin

gawk '{print $3}'

perl -e 'while (<>){ @a = split(" ", $_); print @a[2] . "\n";} '

like 'cat' for file or stdin

while(<>) {
  print $_;
}

----------------------------------------
SORT
----------------------------------------

sort array:

my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print sort @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
}
print sort @lines;

sort numbers:

my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print sort @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
}
print sort {$a <=> $b} @lines;

----------------------------------------
TAIL
----------------------------------------

my $skiplines = abs(shift);
my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
  shift @lines if $#lines == $skiplines;
}
print @lines;

----------------------------------------
UNIQ
----------------------------------------

my $current = "";
my %lines;
while(<>) {
  if($ARGV ne $current) {
    undef %lines;
    $current = $ARGV;
  }
  print $_ unless defined($lines{$_});
  $lines{$_} = "";
}

----------------------------------------
WC
----------------------------------------

my $current;
my %lines;
my %words;
my %chars;
while(<>) {
  $lines{"$ARGV"}++;
  $chars{"$ARGV"} += length($_);
  $words{"$ARGV"} += scalar(grep {$_ ne ""} split /\s/);
}

for my $file (keys %lines) {
  print "$lines{$file} $words{$file} $chars{$file} $file\n";
}

================================================================================
EXAMPLES
--------------------------------------------------------------------------------

inxi: 998

xset q 2>/dev/null | grep -i 'Log file' | gawk '{print $3}')

echo 'this is a log file really!' | perl -e 'while (<>) { chomp; 
if ( /Log file/i )  { @Fld = split(" ", $_, -1);  
print $Fld[(3)-1] . "\n"; } }'

check if available, avoid system('which program &>/dev/null') subshell
https://stackoverflow.com/questions/1882101/how-can-i-quickly-check-if-linux-unzip-is-installed-using-perl
print "tput installed\n" if grep { -x "$_/tput"}split /:/,$ENV{PATH}

================================================================================
SHELL COMMAND EQIVALENTS
--------------------------------------------------------------------------------

We want to avoid all possible subshells, but we also want to avoid any 
dependencies on non standard core modules.

https://perldoc.perl.org/POSIX.html

========================================
UNAME
----------------------------------------

use POSIX qw(uname);
my @uname = uname();
print $uname[0] . " " . $uname[2];

NOTE: from the POSIX.html docs:

Get name of current operating system.

($sysname, $nodename, $release, $version, $machine)
= POSIX::uname();

Note that the actual meanings of the various fields are not that well 
standardized, do not expect any great portability. The $sysname might 
be the name of the operating system, the $nodename might be the name 
of the host, the $release might be the (major) release number of the 
operating system, the $version might be the (minor) release number of 
the operating system, and the $machine might be a hardware 
identifier. Maybe.
