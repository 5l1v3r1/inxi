================================================================================
PERL PROGRAMMING
================================================================================
FILE:    perl_programming.txt
VERSION: 1.3
DATE:    2017-10-31

----------------------------------------
See: perl_setup.txt
See: perl_version_support.txt

----------------------------------------
Comments:

Collection of useful Perl development information.

================================================================================

Sections:
1. PERL BASICS
2. AWK TO PERL
3. BASH TO PERL
4. EXAMPLES

================================================================================
PERL BASICS
--------------------------------------------------------------------------------

Collection of Perl ways of doing things that might not be super intuitive
if you are used to other languages.

========================================
RESOURCES
----------------------------------------

Books: O'Reilly:

LP: Learning Perl (3rd edition, 2001)
LPO: Learning Perl Objects, References, and Modules (1st edition, 2003)
PCB: Perl Cookbook
PP: Programming Perl
A2P: awk to perl output

SSP:
https://stackoverflow.com/questions/1152400/how-can-i-translate-a-shell-script-to-perl
community wiki answer

========================================
BASICS
----------------------------------------

----------------------------------------
Boolean/defined
----------------------------------------

$a = $b || $c

$x ||= $y; # please do not use this, it's too hard to read

$foo = $bar || 'DEFAULT VALUE';

$dir = shift(@ARGV) || '/tmp';

@a = @b unless @a; # copy only if empty

----------------------------------------

# don't use this please, gets hard to read, hides bugs
$a = defined($b) ? $b : $c; 

use v5.9;
$a = $b // $c;

$a //= $y; # please do not use this

// is defined-or

false always: 0, "0", ""

----------------------------------------
variable tricks
----------------------------------------

($var1, $var2) = ($var2, $var1); # swap values

----------------------------------------
charnames
----------------------------------------

use charnames ':full';
print "\N{GREEK CAPITAL LETTER DELTA} is called delta\n";

user charnames ':short';
print "\N{greek:Delta} is called delta\n";

----------------------------------------
hashes
----------------------------------------

slightly odd:

%seen = (); # declare hash, not array

$seen{'a'} = 'fred';
$seen{'b'} = 'bob';

sort(keys, %seen);

convert hash to array
my @a = values %h;

----------------------------------------
arrays
----------------------------------------

$string = 'hello how are you?';

@allwords = split(" ", $string); # whitespace: 1 or more spaces
$revwords = join(" ", reverse @allwords);
print $revwords , "\n";

========================================
SHORTCUTS
----------------------------------------

s/// m// tr///

$string = 'this is what you have';

substr($string, -10 =~ /pattern/; # match for tests etc

substr($string,0,5) =~ s/is/at/g;

========================================
FEATURE
----------------------------------------

https://perldoc.perl.org/feature.html
{
	use feature 'say';
	say "say is available here";
}
print "But not here.\n";

use feature 'say';
say "say is available here";
{
	no feature 'say';
	print "But not here.\n";
}
say "Yet it is here.";

========================================
UNICODE
----------------------------------------

PCB: 1.8

This may matter for color codes

$string ="fac\x{0327}ade"; # fa√ßade

================================================================================
AWK TO PERL
--------------------------------------------------------------------------------

========================================
INSTALL a2p/s2p
----------------------------------------

Install: 

awk to perl:
 cpan App::a2p

sed to perl:
 cpan App::s2p 
 
 
========================================
FIELD/RECORD SEPARATORS
----------------------------------------

$, = ' ';  # set output field separator
$\ = "\n"; # set output record separator

================================================================================
BASH TO PERL
--------------------------------------------------------------------------------

----------------------------------------
CUT
----------------------------------------
SSP:

while(<>) {
  my @array = split ",";
  print $array[3], "\n";
}

for long lines, faster

while(<>) {
  my ($column) = /^(?:[^,]*,){3}([^,]*),/;
  print $column, "\n";
}
columns:

while(<>) {
  print substr($_, 5, 10), "\n";
}

----------------------------------------
FILES
----------------------------------------

SSP:

for my $file (@ARGV) {
  print "$file is a file\n" if -f "$file";
  print "$file is a directory\n" if -d "$file";
  print "I can read $file\n" if -r "$file";
  print "I can write to $file\n" if -w "$file";
}

for my $file (glob("*")) {
  print $file;
  print "*" if -x "$file" && ! -d "$file";
  print "/" if -d "$file";
  print "\t";
}

sub list_dir($$) {
  my ($dir, $prefix) = @_;
  my $newprefix = $prefix;
  if ($prefix eq "") {
    $newprefix = $dir;
  } else {
    $newprefix .= "/$dir";
  }
  chdir $dir;
  for my $file (glob("*")) {
    print "$prefix/" if $prefix ne "";
    print "$dir/$file\n";
    list_dir($file, $newprefix) if -d "$file";
  }
  chdir "..";
}

list_dir(".", "");

----------------------------------------
GREP
----------------------------------------

SSP:

my $pattern = $ARGV[0];
shift @ARGV;
while(<>) {
        print $_ if /$pattern/o;
}

'o' == compile pattern only once

/$pattern/
is the same as:
$_ =~ m/$pattern/

----------------------------------------
HEAD
----------------------------------------

SSP:

reads all file:

my $printlines = abs(shift);
my $lines = 0;
my $current;
while(<>) {
  if($ARGV ne $current) {
    $lines = 0;
    $current = $ARGV;
  }
  print "$_" if $lines < $printlines;
  $lines++;
}

faster:

my $printlines = abs(shift);
my @files;
if(scalar(@ARGV) == 0) {
  @files = ("-");
} else {
  @files = @ARGV;
}
for my $file (@files) {
  next unless -f $file && -r $file;
  open FILE, "<", $file or next;
  my $lines = 0;

  while(<FILE>) {
    last if $lines == $printlines;
    print "$_";
    $lines++;
  }

  close FILE;
}

----------------------------------------
OPEN READ PRINT TO OTHER FILE
----------------------------------------

SSP:

my $filename = "whatever";
my $anotherfile = "another";
open (FILE, "$filename") || die "Could not open $filename!\n";
open OUT, ">", "$anotherfile" or die "Could not open $anotherfile for writing!\n";
while(<FILE>) {
  print OUT $_;
}
close FILE;

----------------------------------------
SLICE Xth ITEM
----------------------------------------

A2P:

Slice out 3rd, assuming separator ' '

while (<>) reads from either file or stdin

gawk '{print $3}'

perl -e 'while (<>){ @a = split(" ", $_); print @a[2] . "\n";} '

like 'cat' for file or stdin

while(<>) {
  print $_;
}

----------------------------------------
SORT
----------------------------------------

SSP:

sort array:

my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print sort @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
}
print sort @lines;

sort numbers:

my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print sort @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
}
print sort {$a <=> $b} @lines;

----------------------------------------
TAIL
----------------------------------------

SSP:

my $skiplines = abs(shift);
my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
  shift @lines if $#lines == $skiplines;
}
print @lines;

----------------------------------------
UNIQ
----------------------------------------

SSP:

my $current = "";
my %lines;
while(<>) {
  if($ARGV ne $current) {
    undef %lines;
    $current = $ARGV;
  }
  print $_ unless defined($lines{$_});
  $lines{$_} = "";
}

----------------------------------------
WC
----------------------------------------

SSP:

my $current;
my %lines;
my %words;
my %chars;
while(<>) {
  $lines{"$ARGV"}++;
  $chars{"$ARGV"} += length($_);
  $words{"$ARGV"} += scalar(grep {$_ ne ""} split /\s/);
}

for my $file (keys %lines) {
  print "$lines{$file} $words{$file} $chars{$file} $file\n";
}

================================================================================
EXAMPLES
--------------------------------------------------------------------------------

inxi: 998

xset q 2>/dev/null | grep -i 'Log file' | gawk '{print $3}')

echo 'this is a log file really!' | perl -e 'while (<>) { chomp; 
if ( /Log file/i )  { @Fld = split(" ", $_, -1);  
print $Fld[(3)-1] . "\n"; } }'

a
