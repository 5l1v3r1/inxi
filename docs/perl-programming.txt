================================================================================
PERL PROGRAMMING
================================================================================
FILE:    perl-programming.txt
VERSION: 2.6
DATE:    2018-01-05

----------------------------------------
See: optimization.txt
See: perl-setup.txt
See: perl-version_support.txt

----------------------------------------
Comments:

Collection of useful Perl development information.

This guy's docs are much more usable than most:
https://www.caveofprogramming.com/categories/perl-tutorial/index.html

================================================================================

Sections:
1. PERL BASICS
2. AWK TO PERL
3. BASH TO PERL
4. EXAMPLES
5. SHELL COMMAND EQIVALENTS
6. EQUIVALENTS
7. SHELLS

================================================================================
PERL BASICS
--------------------------------------------------------------------------------

Collection of Perl ways of doing things that might not be super intuitive
if you are used to other languages.

========================================
RESOURCES
----------------------------------------

Books: O'Reilly:

LP: Learning Perl (3rd edition, 2001)
LPO: Learning Perl Objects, References, and Modules (1st edition, 2003)
PCB: Perl Cookbook
PP: Programming Perl
A2P: awk to perl output

SSP:
https://stackoverflow.com/questions/1152400/how-can-i-translate-a-shell-script-to-perl
community wiki answer

========================================
ARRAYS
----------------------------------------

See: print_r

https://www.caveofprogramming.com/perl-tutorial/perl-array-quick-guide-to-arrays-in-perl.html

----------------------------------------
ADDING / REMOVING
----------------------------------------

----------------------------------------
ADDING:

sadly, no $array[] = 'something'; auto incrementing

so:
Add to end:

push @array, 'something';

Add to beginning:

unshift @array, 'something';


# Append to the first array
# We need to typecast the reference to an 
# array before using push.
push @{$stuff[0]}, 'kiwi';

Perl has the ability to have an extra comma at the end of a list. For example:

my @array = (
	'This thing',
	'That thing',
);

----------------------------------------
REMOVING:

These are both fairly pointless in my experience but I include them
here for completion's sake, with one exception, if we have split a
line and want to get the first or last item without counting it.

Note that these REMOVE the item, they don't just give it. This is 
something that might in rare cases be useful, like if you want the second
to the last item, or second item, and don't care about the first or last.

# Remove the last item ('something') and save it.
my $end = pop @array; 

# Remove first item off the array and save it.
my $start = shift @array;

----------------------------------------
ARRAY OF ARRAYS
----------------------------------------

http://perldoc.perl.org/perllol.html

NOTE the different brackets. 

my @stuff = (
    ['apple', 'orange', 'banana'],
    [42, 1234],
    ['some', 'more', 'stuff', 'here'],
    ['assorted', 100, 0.7, 'hello']
);

better:
my @fruits = ('apple', 'orange', 'banana');
my @numbers = (42, 1234);
my @strings = ('some', 'more', 'stuff', 'here');
my @assorted = ('assorted', 100, 0.7, 'hello');

BUT:: if you use push, then you have to use [] for the
sub arrays. Sigh.

# Build an array from references to the above arrays.
# (The same trick works with references to hashes!)

my @stuff = (@fruits, @numbers, @strings, @assorted);

print $stuff[2][0]; # prints 'some'

----------------------------------------
IS_ARRAY
----------------------------------------

http://www.perlmonks.org/?node_id=118961

look at the ref() function in perl, it tells you the type of ref you have.

----------------------------------------

foreach $item (@array){
   if(ref($item) eq 'ARRAY'){
      #It's an array reference...
      #you can read it with $item->[1]
      #or dereference it uisng @newarray = @{$item}
   }else{
      #not an array in any way...
   }
}

----------------------------------------

use UNIVERSAL 'isa';

foreach $item (@array) {
	if (isa($item, 'ARRAY')) {
		print "We've got an array!!\n";
	}
}

----------------------------------------
COUNT / LENGTH
----------------------------------------

ARRAY:
scalar @array;
OR
my $size = @array;

HASH:

NOTE: to count a hash, you have to do this, sigh...
$count = keys %hash;

NOTE: print "@array\n"; prints out the contents, not the count.

The quotes make the difference.

----------------------------------------
MAP/GREP
----------------------------------------

my @text = ('catfish', 'badger', 'dogfish', 'aardvark');

my @fish = grep(/fish/, @text);

print join(', ', @fish);

# prints: catfish, dogfish

----------------------------------------


my @names = ('Bob', 'Pete', 'Sue', 'Alice');

my @prefixed = map("NAME: $_", @names);

print join(', ', @prefixed);

# Prints:
# NAME: Bob, NAME: Pete, NAME: Sue, NAME: Alice

----------------------------------------
MULTI DIMENSIONAL ASSOCIATIVE ARRAYS
----------------------------------------

KEEP ORDER!!!

use Tie::IxHash;

tie my %myhash, 'Tie::IxHash';

for (my $i=0; $i<20; $i++) {
    $myhash{$i} = 2*$i;
    }

my @keys = keys %myhash;
# @keys = (0,1,2,3,...)

http://www.perlmonks.org/?node_id=1978

my %a = (
'a' => 'hello',
'b' => { 'c' => 'world'}
);
print "$a{'a'} $a{'b'}{'c'}\n";

$hash{toes} = { 
    biggest => 'hairy troll',
    smallest => 'toddler',
};

http://www.perlmonks.org/?node_id=421382

foreach my $outter (keys %hash) {
  foreach my $inner (keys %{$hash{$outter}}) {
    print "$outter - $inner = ", $hash{$outter}{$inner}, "\n";
  }
}

$hash{foo}->{bar}->{beer}="free";
$hash{foo}{bar}{beer}="free"

%hash = (
	arms => {
		biggest  => 'mine',
		smallest => 'yours'
	},
	feet => {
		biggest  => 'right',
		smallest => 'left'
	},
	legs => {
		biggest  => 'theirs',
		smallest => 'them',
		muscular => 'yes'
	}
);


http://www.perlmonks.org/?node_id=274383

for ( keys %category_hash ) {
   my $first_lvl = $category_hash{$_};
   print "$_\n";

   for ( keys %{ $first_lvl } ) {
      my $second_lvl = $first_lvl->{$_};
      print ' ' x 3 . "$_"\n";

      for ( keys %{ $second_lvl } ) {
         print ' ' x 6 . "$_ : $second_lvl->{$_}\n";
      }
   } # END for keys $first_lvl
}    # END for keys %category_hash

https://docstore.mik.ua/orelly/perl/prog3/ch09_04.htm

while ( <> ) {
    next unless s/^(.*?):\s*//;
    $who = $1;
    for $field ( split ) {
        ($key, $value) = split /=/, $field;
        $HoH{$who}{$key} = $value;
    }
}

while ( <> ) {
    next unless s/^(.*?):\s*//;
    $who = $1;
    $rec = {};
    $HoH{$who} = $rec;
    for $field ( split ) {
        ($key, $value) = split /=/, $field;
        $rec->{$key} = $value;
    }
}

for $family ( keys %HoH ) {
    print "$family: ";
    for $role ( keys %{ $HoH{$family} } ) {
         print "$role=$HoH{$family}{$role} ";
    }
    print "\n";
}

while ( ($family, $roles) = each %HoH ) {
    print "$family: ";
    while ( ($role, $person) = each %$roles ) {
        print "$role=$person ";
    }
    print "\n";
}

for $family ( sort keys %HoH ) {
    print "$family: ";
    for $role ( sort keys %{ $HoH{$family} } ) {
         print "$role=$HoH{$family}{$role} ";
    }
    print "\n";
}

---------------------------------------
adding new rows to hash arrays of hashes:

$ref = $data{$data_name};
print $ref;

## NOTE: this adds a ROW:
$ref = $data{$data_name};
push @$ref, \%row;

## OR
push @{$data{$data_name}}, \%row;

http://www.perlmonks.org/?node_id=1018185
---------------------------------------
print +(keys %{$var->{'0xAAAAAAAA'}})[1], "\n";
print $var->{'0x55555555'}->{'0xAAAAAAAA'}->[0]->[0], "\n";


http://www.perlmonks.org/?node_id=977408


----------------------------------------
PRINTING/DEBUGGING
----------------------------------------

print join(', ', @fruits);

----------------------------------------
SORTING
----------------------------------------

my @strings = ("cat", "dog", "aardvark", "lizard");

my @sorted = sort @strings;

# @sorted is now sorted. @strings remains the same, of course.

print join(', ', @sorted);

# prints:
# aardvark, cat, dog, lizard

----------------------------------------

my @strings = ("cat", "dog", "aardvark", "zebra");

# Sort in reverse alphabetical order 
my @sorted = sort { $b cmp $a } @strings;

print join(', ', @sorted);

# prints:
# zebra, dog, cat, aardvark

---------------------------------------

my @numbers = (1, 6, 4, 3, 10);

# Sort in numerical order
my @sorted = sort { $a <=> $b } @numbers;

print join(', ', @sorted);

# prints:
# 1, 3, 4, 6, 10

---------------------------------------

my @strings = ("cat", "dog", "aardvark", "zebra");

# Sort in order of string length, longest first
my @sorted = sort { length($b) <=> length($a) } @strings;

print join(', ', @sorted);

# prints:
# aardvark, zebra, cat, dog


========================================
ARGV, ARRAYS IN GENERAL
----------------------------------------

Scalar value @ARGV[0] better written as $ARGV[0]...

----------------------------------------
hashes
----------------------------------------

slightly odd:

%seen = (); # declare hash, not array

$seen{'a'} = 'fred';
$seen{'b'} = 'bob';

sort(keys, %seen);

convert hash to array
my @a = values %h;


----------------------------------------
arrays
----------------------------------------

$string = 'hello how are you?';

@allwords = split(" ", $string); # whitespace: 1 or more spaces
$revwords = join(" ", reverse @allwords);
print $revwords , "\n";

----------------------------------------
split
----------------------------------------

Use of implicit split to @_ is deprecated

(D deprecated, W syntax) It makes a lot of work for the compiler when you 
clobber a subroutine's argument list, so it's better if you assign the 
results of a split() explicitly to an array (or list).

Only 5.08 shows this message.

Cause:

scalar split /../, $something
or
$something = split /../, $something
solution:
@a = split /../, $something
$something = scalar @a
----------------------------------------
to also get rid of blank lines:

my @fin = grep {$_} split /\n/, $string;


========================================
Boolean/defined
----------------------------------------

$a = $b || $c

$x ||= $y; # please do not use this, it's too hard to read

$foo = $bar || 'DEFAULT VALUE';

$dir = shift(@ARGV) || '/tmp';

@a = @b unless @a; # copy only if empty

----------------------------------------

# don't use this please, gets hard to read, hides bugs
$a = defined($b) ? $b : $c; 

use v5.9;
$a = $b // $c;

$a //= $y; # please do not use this

// is defined-or

false always: 0, "0", ""

========================================
CLASSES
----------------------------------------

http://www.perlmonks.org/?node_id=289076

better:
http://www.perlmonks.org/?node_id=218778

========================================
FEATURE
----------------------------------------

https://perldoc.perl.org/feature.html
{
	use feature 'say';
	say "say is available here";
}
print "But not here.\n";

use feature 'say';
say "say is available here";
{
	no feature 'say';
	print "But not here.\n";
}
say "Yet it is here.";


========================================
FILES
----------------------------------------

NOTE: .pl stands for perl library

----------------------------------------
OPEN, WRITE
----------------------------------------

open(my $fh, '>', $fpath) or die "Could not open file '$fpath' $!";
print $fh $content;
close $fh;

----------------------------------------
REMOVE LINK
----------------------------------------

if ( -l "$ENV{MYHOME}/link" ) {
    unlink "$ENV{MYHOME}/link"
        or die "Failed to remove file $ENV{MYHOME}/link: $!\n";
}

----------------------------------------
PERMISSIONS
----------------------------------------

https://alvinalexander.com/blog/post/perl/perl-file-test-operators-reference-cheat-sheet

-r  File (or directory) is readable by effective uid/gid
-w  File (or directory) is writable by effective uid/gid
-x  File (or directory) is executable by effective uid/gid
-o  File (or directory) is owned by effective uid/gid

-R  File (or directory) is readable by real uid/gid
-W  File (or directory) is writable by real uid/gid
-X  File (or directory) is executable by real uid/gid
-O  File (or directory) is owned by real uid/gid

----------------------------------------
READING FILES
----------------------------------------

for my $file (@ARGV) {
  print "$file is a file\n" if -f "$file";
  print "$file is a directory\n" if -d "$file";
  print "I can read $file\n" if -r "$file";
  print "I can write to $file\n" if -w "$file";
}

for my $file (glob("*")) {
  print $file;
  print "*" if -x "$file" && ! -d "$file";
  print "/" if -d "$file";
  print "\t";
}

sub list_dir($$) {
  my ($dir, $prefix) = @_;
  my $newprefix = $prefix;
  if ($prefix eq "") {
    $newprefix = $dir;
  } else {
    $newprefix .= "/$dir";
  }
  chdir $dir;
  for my $file (glob("*")) {
    print "$prefix/" if $prefix ne "";
    print "$dir/$file\n";
    list_dir($file, $newprefix) if -d "$file";
  }
  chdir "..";
}

list_dir(".", "");

----------------------------------------
INCLUDING FILES
----------------------------------------

sub load_common_subroutines {
  open MORE_CODE, "navigation.pl" or die "navigation.pl: $!";
  undef $/; # enable slurp mode
  my $more_code = <MORE_CODE>;
  close MORE_CODE;
  eval $more_code;
  die $@ if $@;
}

do "navigation.pl";
die $@ if $@;

require "drop_anchor.pl";
require "navigate.pl";

LPO 2.5.1
# paths for perl files?
unshift @INC, "/home/skipper/perl-lib";

----------------------------------------
OPEN READ PRINT TO OTHER FILE
----------------------------------------

my $filename = "whatever";
my $anotherfile = "another";
open (FILE, "$filename") || die "Could not open $filename!\n";
open OUT, ">", "$anotherfile" or die "Could not open $anotherfile for writing!\n";
while(<FILE>) {
  print OUT $_;
}
close FILE;

----------------------------------------
SLURP FILE - READ ALL AT ONCE
----------------------------------------
https://perlmaven.com/slurp

The $/ variable is the Input Record Separator in Perl. When we put the 
read-line operator in scalar context, for example by assigning to a 
scalar variable $x = <$fh>, perl will read from the file up-to and including 
the Input Record Separator which is, by default, the new-line \n. 

my $file = 'data.txt';
my $data;
{
    open my $fh, '<', $file or die;
    local $/ = undef;
    $data = <$fh>;
    close $fh;
}
print $data;

========================================
MODULES - CHECK AVAILABLE
----------------------------------------

http://www.perlmonks.org/?node_id=691741

-----------------------------------------

my $scan_foo = 1;

eval "use File::stat";
if ( $@ ) {
     $scan_foo = 0;
}

-----------------------------------------
use HTML::Perlinfo::Modules;

my $m = HTML::Perlinfo::Modules->new();
my $module = $m->print_modules( show_only => qr/FOO::bar/i );

if ($module) {
  my $foobarzlot=sprintf("%d,",bar(FILE)->zlot);
  print "FOOBARZLOT=".$foobarzlot."\n";
}


Note that it is very easy to look up multiple modules4 by simply adding 
them to the precompiled regular expression. For example:

my $modules = $m->print_modules( show_only => qr/FOO::bar|File::Which|
+File::stat/i );

----------------
use Module::CoreList

corelist Net::FTP

========================================
MODULES - USE / INCLUDE
----------------------------------------

https://stackoverflow.com/questions/2376411/in-perl-how-can-i-import-a-hash-from-a-library
----------------------------------------

# revs.pm
package revs;

our %vers = ( foo => "bar" );

1; # Perl modules need to return a boolean "true" value.

# importer.pl
use revs;

print $revs::vers{foo} . "\n";

----------------------------------------

package revs;
use strict;
use warnings;
require Exporter;
our @ISA    = qw(Exporter);
our @EXPORT = qw(%vers);
our %vers   = (foo=>'bar');
1;


use strict;
use warnings;
use Data::Dumper;
use revs;
print Dumper(\%vers);

----------------------------------------

package MyApp::Versions;
use strict;
use Carp qw(confess);
use Sub::Exporter -setup => {
    exports => ['get_component_version'],
};

my %component_versions = ( foo => 42 ); # yes, "my", not "our".

sub get_component_version {
    my ($component) = @_;
    return $component_versions{$component} ||
        confess "No component $component!"
}
1;

package Foo;
use MyApp::Versions qw(get_component_version);

sub some_function {
    die 'your foo is too old'
        unless get_component_version('foo') >= 69;

    return FooComponent->oh_hai;
}

========================================
PPID
----------------------------------------

http://perldoc.perl.org/functions/getppid.html
getppid


http://perldoc.perl.org/perlvar.html#%24%24

To see if your system is affected by this discrepancy check if:
getconf GNU_LIBPTHREAD_VERSION | grep -q NPTL ; echo "$?"
returns a false value. NTPL threads preserve the POSIX semantics.

========================================
SHORTCUTS
----------------------------------------

s/// m// tr///

$string = 'this is what you have';

substr($string, -10 =~ /pattern/; # match for tests etc

substr($string,0,5) =~ s/is/at/g;

========================================
SYSTEM/EXEC GOTCHAS
----------------------------------------

http://gssg-www.stanford.edu/public/systemfunction.html

========================================
use
----------------------------------------

https://perldoc.perl.org/functions/use.html

BEGIN { require Module; Module->import( LIST ); }
 
use Module 12.34; 
# exactly equivalent to:
BEGIN { require Module; Module->VERSION(12.34) }

========================================
UNICODE
----------------------------------------

PCB: 1.8

This may matter for color codes

$string ="fac\x{0327}ade"; # façade

----------------------------------------
charnames
----------------------------------------

use charnames ':full';
print "\N{GREEK CAPITAL LETTER DELTA} is called delta\n";

user charnames ':short';
print "\N{greek:Delta} is called delta\n";

========================================
VARIABLES
----------------------------------------

----------------------------------------
variable tricks
----------------------------------------

($var1, $var2) = ($var2, $var1); # swap values


================================================================================
AWK TO PERL
--------------------------------------------------------------------------------

========================================
INSTALL a2p/s2p
----------------------------------------

Install: 

awk to perl:
 cpan App::a2p

sed to perl:
 cpan App::s2p 
 
 
========================================
FIELD/RECORD SEPARATORS
----------------------------------------

$, = ' ';  # set output field separator
$\ = "\n"; # set output record separator

================================================================================
BASH TO PERL
--------------------------------------------------------------------------------

========================================
BASH TO PERL: PERLMONKS
----------------------------------------

http://www.perlmonks.org/?node_id=627015

----------------------------------------

. 	do 	built-in
awk 	perl ;-) (often 'split') 	built-in 
	See also a2p	Base program
basename 	File::Basename::basename 	Base module
cat 	while(<>){print} 	built-in
	ExtUtils::Command::cat 	Base module
cd 	chdir 	built-in
chmod 	chmod 	built-in
chown 	chown 	built-in
cp 	File::Copy 	Base module
	ExtUtils::Command::cp 	Base module
cut 	split 	built-in
date 	localtime 	built-in
	POSIX::strftime 	Base module
declare 	see typedef 	
df 	Filesys::Df 	CPAN
diff 	File::Compare 	Base module
dirname 	File::Basename::dirname 	Base modules
echo 	print 	built-in
egrep 	while(<>){print if /re/} 	built-in
eval 	eval 	built-in
exec 	exec 	built-in
	pipe (co-processes) 	built-in
	open (file descriptors) 	built-in
export 	Assign to %ENV 	Hash variable
	Env::C 	CPAN
find 	File::Find::find 	Base module
ftp 	Net::Ftp 	Base module
function 	sub 	built-in
grep 	see egrep 	
hostname 	Sys::Hostname::hostname	Base module
integer 	int 	built-in
kill 	kill 	built-in
ln 	link 	built-in
ln -s 	symlink 	built-in
ls 	glob 	built-in
	opendir/readdir/closedir 	built-in
	stat/lstat 	built-in
mkdir 	mkdir 	built-in
mkpath 	ExtUtils::Command::mkpath 	Base module
mv 	rename 	built-in
	ExtUtils::Command::mv 	Base module
od 	ord 	built-in
	printf 	built-in
print 	print 	built-in
printf 	printf 	built-in
ps 	Proc::ProcessTable 	CPAN
pwd 	Cwd::getcwd 	Base module
rand 	rand 	built-in
read 	See I/O Operators 	built-in
rm 	unlink 	built-in
	ExtUtils::Command::rm 	Base module
rm -f 	ExtUtils::Command::rm_rf 	Base module
sed 	s/// (usually) 	built-in
	See also s2p	Base program
select 	Shell::POSIX::select 	CPAN
sleep 	sleep 	built-in
	alarm 	built-in
sort 	sort 	built-in
source 	do 	built-in
tail 	File::Tail 	CPAN
telnet 	Net::Telnet 	CPAN>
times 	times 	built-in
touch 	open/close 	built-in
	ExtUtils::Command::touch 	Base module
trap 	%SIG 	Hash
	sigtrap 	pragma
typeset 	my 	built-in
typeset -i 	int 	built-in
typeset -l 	lc 	built-in
typeset -u 	uc 	built-in
typeset -Z 	sprintf 	built-in
which 	which 	File::Which

========================================
BASH TO PERL: SSP
----------------------------------------

----------------------------------------
CAT
----------------------------------------

https://metacpan.org/pod/perlfaq5#How-can-I-read-in-an-entire-file-all-at-once

NOTE:
neither 
Path::Tiny;
File::Map
are in standard core so not using those, but they aren't necessary either

This works fine. This is the type of perl that is fine to use in non user
viewed functions, but which I want to avoid in the get data area.

my $contents = do { local( @ARGV, $/ ) = $file; <> };

----------------------------------------
CUT
----------------------------------------

while(<>) {
  my @array = split ",";
  print $array[3], "\n";
}

for long lines, faster

while(<>) {
  my ($column) = /^(?:[^,]*,){3}([^,]*),/;
  print $column, "\n";
}
columns:

while(<>) {
  print substr($_, 5, 10), "\n";
}

----------------------------------------
GREP
----------------------------------------

my $pattern = $ARGV[0];
shift @ARGV;
while(<>) {
        print $_ if /$pattern/o;
}

'o' == compile pattern only once

/$pattern/
is the same as:
$_ =~ m/$pattern/

----------------------------------------
HEAD
----------------------------------------

reads all file:

my $printlines = abs(shift);
my $lines = 0;
my $current;
while(<>) {
  if($ARGV ne $current) {
    $lines = 0;
    $current = $ARGV;
  }
  print "$_" if $lines < $printlines;
  $lines++;
}

faster:

my $printlines = abs(shift);
my @files;
if(scalar(@ARGV) == 0) {
  @files = ("-");
} else {
  @files = @ARGV;
}
for my $file (@files) {
  next unless -f $file && -r $file;
  open FILE, "<", $file or next;
  my $lines = 0;

  while(<FILE>) {
    last if $lines == $printlines;
    print "$_";
    $lines++;
  }

  close FILE;
}

----------------------------------------
LS
----------------------------------------

opendir my($dh), $dirname or die "Couldn't open dir '$dirname': $!";
my @files = readdir $dh;
closedir $dh;

----------------------------------------
SLICE Xth ITEM
----------------------------------------

A2P:

Slice out 3rd, assuming separator ' '

while (<>) reads from either file or stdin

gawk '{print $3}'

perl -e 'while (<>){ @a = split(" ", $_); print @a[2] . "\n";} '

like 'cat' for file or stdin

while(<>) {
  print $_;
}

----------------------------------------
SORT
----------------------------------------

sort array:

my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print sort @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
}
print sort @lines;

sort numbers:

my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print sort @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
}
print sort {$a <=> $b} @lines;

----------------------------------------
TAIL
----------------------------------------

my $skiplines = abs(shift);
my @lines;
my $current = "";
while(<>) {
  if($ARGV ne $current) {
    print @lines;
    undef @lines;
    $current = $ARGV;
  }
  push @lines, $_;
  shift @lines if $#lines == $skiplines;
}
print @lines;

----------------------------------------
UNIQ
----------------------------------------

my $current = "";
my %lines;
while(<>) {
  if($ARGV ne $current) {
    undef %lines;
    $current = $ARGV;
  }
  print $_ unless defined($lines{$_});
  $lines{$_} = "";
}

----------------------------------------
WC
----------------------------------------

my $current;
my %lines;
my %words;
my %chars;
while(<>) {
  $lines{"$ARGV"}++;
  $chars{"$ARGV"} += length($_);
  $words{"$ARGV"} += scalar(grep {$_ ne ""} split /\s/);
}

for my $file (keys %lines) {
  print "$lines{$file} $words{$file} $chars{$file} $file\n";
}

================================================================================
EXAMPLES
--------------------------------------------------------------------------------

inxi: 998

xset q 2>/dev/null | grep -i 'Log file' | gawk '{print $3}')

echo 'this is a log file really!' | perl -e 'while (<>) { chomp; 
if ( /Log file/i )  { @Fld = split(" ", $_, -1);  
print $Fld[(3)-1] . "\n"; } }'

check if available, avoid system('which program &>/dev/null') subshell
https://stackoverflow.com/questions/1882101/how-can-i-quickly-check-if-linux-unzip-is-installed-using-perl
print "tput installed\n" if grep { -x "$_/tput"}split /:/,$ENV{PATH}

========================================
PRINTING LINES, INDENTATION
----------------------------------------

my $i=20;
my $j=2;
my $l = sprintf("%4s %6s",'-f,','--full');
my $k = sprintf("%4s %6s",'-y,','--widths');
my $m = sprintf("%4s %6s",'','--other-stuff');
printf("%-${i}s%s\n", "$l", "Now this will work?");
printf("%-${i}s%s\n", "$k", "Now this will work?");
printf("%-${i}s%s\n", "$m", "Now this will work?");
my $h = ($i+$j);
printf("%-${h}s%s\n", "", "* info about it working!!");

OUTPUT:

 -f, --full         Now this will work?
 -y, --widths       Now this will work?
     --other-stuff  Now this will work?
                      * info about it working!!

================================================================================
SHELL COMMAND EQIVALENTS
--------------------------------------------------------------------------------

We want to avoid all possible subshells, but we also want to avoid any 
dependencies on non standard core modules.

https://perldoc.perl.org/POSIX.html

========================================
UNAME
----------------------------------------

use POSIX qw(uname);
my @uname = uname();
print $uname[0] . " " . $uname[2];

NOTE: from the POSIX.html docs:

Get name of current operating system.

($sysname, $nodename, $release, $version, $machine)
= POSIX::uname();

Note that the actual meanings of the various fields are not that well 
standardized, do not expect any great portability. The $sysname might 
be the name of the operating system, the $nodename might be the name 
of the host, the $release might be the (major) release number of the 
operating system, the $version might be the (minor) release number of 
the operating system, and the $machine might be a hardware 
identifier. Maybe.

================================================================================
EQUIVALENTS
--------------------------------------------------------------------------------




========================================
ASSIGNMENT IN CONDITIONAL
----------------------------------------

Surprisingly, this seems to work!!

if ( my $mounts = system_files('mounts')){
	print "$mounts\n";
}

========================================
BOOLEANS
----------------------------------------

Perl does not have real booleans, like true/false literals.

It's similar to other languages in how it tests, but to keep pinxi sane, 
let's stick to basics:

$var = undef; false
$var = ''; false

and that's it. Because perl uses 0, > 0 exactly backward from say, shell, 
that's too confusing so just don't use 0 as a test for false. Be careful in 
the code

For tests, that becomes:

if ( $var ){
do stuff
}

or

if ( ! $var ){
do stuff
}

NOTE:
because an array length of 0 is false:

if ( @array ){
do stuff...
}
means the array has at least one index.

NOTE:
if you declare like so:

my ($b_one, $b_two);
then test:

if ( $b_one eq 'true' ){

this will kick out:
Use of uninitialized value $b_conf in string eq at ./pinxi line 315.

on at least bsd perl 5.12, so you have to test only for boolean true false
if ( $b_one ){

========================================
break
----------------------------------------

last;

========================================
foreach ($a_something as $key=>$value){
----------------------------------------

foreach my $key ( keys %info_files ){
print $info_files{$key};
}

========================================
__FUNCTION__
----------------------------------------

(caller(0))[3]

outputs:

main::show_options

Cannot be in ""

========================================
print_r
----------------------------------------

See: ARRAYS

use Data::Dumper qw(Dumper);
print Dumper \%grades;
print "----------------\n";

However, note:

All you have to do is assign the array to a scalar like so:

my $one = @_; 

If the subsequent use of $one is in double quotes, it will output
the contents of the array, and if it is not quoted, it will output 
the array count. Weird.

It takes the args the function that calls it used, passes it to:

$three, and then $three contains the string rather than the array.

========================================
range operator
----------------------------------------

..

[1 .. 5]

my @a = 'a'..'z'; # 26 letters

# a, e, i, o, u...
my @vowels = @a[0,4,8,14,20];

# And sometimes "y"
push( @vowels, $a[-2] ) if rand > .5;

========================================
STATIC VARIABLES
----------------------------------------

5.10 and later:

state ($var);

pre 5.10: 

Don't bother with these hacks, if we want it static, we have
to make it a global, our. Or static within scope, as below.

https://www.cs.ait.ac.th/~on/O/oreilly/perl/cookbook/ch10_04.htm

Wrap the function in another block, and declare my variables in that block's scope rather than the function's:

{
    my $variable;
    sub mysub {
        # ... accessing $variable
    }
}

If the variables require initialization, make that block a BEGIN so the variable is guaranteed to be set before the main program starts running:

BEGIN {
    my $variable = 1;                       # initial value
    sub othersub {                          # ... accessing $variable
    }
}

========================================
SWITCH / CASE
----------------------------------------

Sigh. LOL. Sigh.

http://www.perlmonks.org/?node_id=1054948

http://perldoc.perl.org/perlfaq7.html#How-do-I-create-a-switch-or-case-statement%3f

pre 5.08: hacks, dispatch tables, endless elsif

Note: to use this structure, it must be an actual pattern, or the whole word, if
it's safe to test for whole word. If not, use word boundaries or ^...$


for ($variable_to_test) {
	if    (/pat1/)  { }     # do something
	elsif (/pat2/)  { }     # do something else
	elsif (/pat3/)  { }     # do something else
	else            { }     # default
}

my %commands = (
	"happy" => \&joy,
	"sad",  => \&sullen,
	"done"  => sub { die "See ya!" },
	"mad"   => \&angry,
);
print "How are you? ";
chomp($string = <STDIN>);
if ($commands{$string}) {
	$commands{$string}->();
} else {
	print "No such command: $string\n";
}

for my $case (@cases) {
    local $_ = $n;
    next unless $case->[0]->();
    $t = $case->[1]->();
    last;
}

You can also do this in all versions of Perl 5:

my $t = do {
    if    ($n == 0)   { "$n ain't squawt"        }
    elsif ($n == 1)   { "$n is not a lot"        }
    elsif ($n < 100)  { "$n is more than 1..."   }
    elsif ($n < 1000) { "$n is in triple digits" }
    else              {  "Wow! $n is thousands!" }
};

my $t = sub {
    return "$n ain't squawt"        if $n == 0;
    return "$n is not a lot"        if $n == 1;
    return "$n is more than 1..."   if $n < 100;
    return "$n is in triple digits" if $n < 1000;
    return "Wow! $n is thousands!";
}->();

5.10 and later: 
switch (given/when) 

given ( $string ) {
	when( 'Fred' )        { say "I found Fred!" }
	when( 'Barney' )      { say "I found Barney!" }
	when( /Bamm-?Bamm/ )  { say "I found Bamm-Bamm!" }
	default               { say "I don't recognize the name!" }
};

my $salute = $name eq $EMPTY_STR                       ? 'Dear Customer'
           : $name =~ m/ \A((?:Sir|Dame) \s+ \S+) /xms ? "Dear $1"
           : $name =~ m/ (.*), \s+ Ph[.]?D \z     /xms ? "Dear Dr $1"
           :                                             "Dear $name"
           ;

if    ($n == 0)   { $t = "$n ain't squawt";        }
  elsif ($n == 1)   { $t = "$n is not a lot";        }
  elsif ($n < 100)  { $t = "$n is more than 1...";   }
  elsif ($n < 1000) { $t = "$n is in triple digits"; }
  else              { $t = "Wow! $n is thousands!" ; }  

As of perl 5.13.1, even as:

my $t = do {
    given ($n) {
        when (0)         { "$_ ain't squawt"        }
        when (1)         { "$_ is not a lot"        }
        when ($_ < 100)  { "$_ is more than 1..."   }
        when ($_ < 1000) { "$_ is in triple digits" }
        default          {  "Wow! $_ is thousands!" }
    }
};

----------------------------------------

use 5.013;  # 5.014
use warnings;

print 'Enter your grade: ';
chomp( my $grade = <> );

say do { 
    given ($grade) {
        'Well done!'        when 'A';
        'Try harder!'       when 'B';
        'You need help!!!'  when 'C';
        default { 'You are just making it up!' }
    }
};

----------------------------------------

Perl itself has had such a switch statement for quite a while now:

use Switch;

switch ($grade) {
    case "A"   { say "Well done!" }
    case "B"   { say "Try harder!" }
    case "C"   { say "You need help!!!" }
    else         { print "You just making it up" }
}

However DON’T USE IT!!! Its a source filter and is being deprecated.

========================================
TRAP WARNINGS
----------------------------------------

https://perlmaven.com/how-to-capture-and-save-warnings-in-perl
local $SIG{__WARN__} = sub {
	# here we get the warning
};

local $SIG{__WARN__} = sub {
	my $message = shift;
	logger($message);
};

----------------------------------------

https://www.caveofprogramming.com/perl-tutorial/perl-eval-using-eval-to-run-code-and-trap-errors-in-perl.html

https://perlmaven.com/how-to-capture-and-save-warnings-in-perl

this would basically emulate the inxi warnings/alerts supression done 
via bash methods, I think.

<<<
The local is important to limit the effect of our change if you are using 
this code within a module. Especially if you distribute it. Without the 
localization the effect would be felt in all the application. The local 
limits it to the enclosing block. 
>>>

local $SIG{__WARN__} = sub {
	die;
};
local $SIG{__WARN__} = sub {
	my $message = shift;
	logger($message);
};
local $SIG{__WARN__} = sub {
	my $message = shift;
	die $message;
};

https://perlmaven.com/use-of-uninitialized-value

Turning off buffering

In order to avoid this you can turn off the buffering of STDOUT.

This is done by the following code: $| = 1; at the beginning of the script.

use warnings;
use strict;
use 5.010;

$| = 1;

================================================================================
SHELLS
--------------------------------------------------------------------------------

https://robots.thoughtbot.com/the-unix-shells-humble-if

inxi will at times use a subshell, so it's important that all inxi subshell
commands are fully POSIX compliant. That's a good explanation of what to do and
not to do. Since all my shell code has always been Bash, I have to be careful 
to avoid letting bashisms slip into subshells.

There will not be many subshells, but I believe most of the debugger data 
collector will be done via subshell, otherwise the perl equivalents would  
make the size mushroom unacceptably.

================================================================================
BSDs
--------------------------------------------------------------------------------


https://forum.ivorde.com/freebsd-collecting-hardware-information-t21.html

grep -i cpu /var/run/dmesg.boot
CPU: Pentium III/Pentium III Xeon/Celeron (501.14-MHz 686-class CPU)
cpu0: <ACPI CPU> on acpi0

Determining hardware platform and processor architecture:
uname -mp
i386 i386

Physical and available memory

grep -i mem /var/run/dmesg.boot
real memory  = 268369920 (255 MB)
avail memory = 248635392 (237 MB)

PCI slots using pciconf
pciconf -lv
hostb0@pci0:0:0:   class=0x060000 card=0x00000000 chip=0x71908086 rev=0x03 hdr=0x00
    vendor     = 'Intel Corporation'
    device     = '82443BX/ZX 440BX/ZX CPU to PCI Bridge (AGP Implemented)'
    class      = bridge
    subclass   = HOST-PCI
pcib1@pci0:1:0:   class=0x060400 card=0x00000000 chip=0x71918086 rev=0x03 hdr=0x01
    vendor     = 'Intel Corporation'
    device     = '82443BX/ZX 440BX/ZX AGPset PCI-to-PCI bridge'
    class      = bridge
    subclass   = PCI-PCI
isab0@pci0:4:0:   class=0x060100 card=0x00000000 chip=0x71108086 rev=0x02 hdr=0x00
    vendor     = 'Intel Corporation'
    device     = '82371AB/EB/MB PIIX4/4E/4M ISA Bridge'
    class      = bridge
    subclass   = PCI-ISA
atapci0@pci0:4:1:   class=0x010180 card=0x00000000 chip=0x71118086 rev=0x01 hdr=0x00
    vendor     = 'Intel Corporation'
    device     = '82371AB/EB/MB PIIX4/4E/4M IDE Controller'
    class      = mass storage
    subclass   = ATA
uhci0@pci0:4:2:   class=0x0c0300 card=0x00000000 chip=0x71128086 rev=0x01 hdr=0x00
    vendor     = 'Intel Corporation'
    device     = '82371AB/EB/MB PIIX4/4E/4M USB Interface'
    class      = serial bus
    subclass   = USB
none0@pci0:4:3:   class=0x068000 card=0x00000000 chip=0x71138086 rev=0x02 hdr=0x00
    vendor     = 'Intel Corporation'
    device     = '82371AB/EB/MB PIIX4/4E/4M Power Management Controller'
    class      = bridge
xl0@pci0:11:0:   class=0x020000 card=0x905510b7 chip=0x905510b7 rev=0x30 hdr=0x00
    vendor     = '3COM Corp, Networking Division'
    device     = '3C905-TX Fast Etherlink 10/100 PCI TX NIC'
    class      = network
    subclass   = ethernet
rl0@pci0:16:0:   class=0x020000 card=0x813910ec chip=0x813910ec rev=0x10 hdr=0x00
    vendor     = 'Realtek Semiconductor'
    device     = 'RT8139 (A/B/C/810x/813x/C+) Fast Ethernet Adapter'
    class      = network
    subclass   = ethernet
none1@pci1:0:0:   class=0x030000 card=0xff00102b chip=0x0521102b rev=0x03 hdr=0x00
    vendor     = 'Matrox Electronic Systems Ltd.'
    device     = 'Matrox lnc MGA-G200B Eclipse/Calao'
    class      = display
    subclass   = VGA
    
USB device information on FreeBSD:
usbdevs -v
Controller /dev/usb0:
addr 1: full speed, self powered, config 1, UHCI root hub(0x0000), Intel(0x0000), rev 1.00
port 1 powered
port 2 powered

Hard Disk information in FreeBSD:
atacontrol
usage:  atacontrol <command> args:
        atacontrol list
        atacontrol info channel
        atacontrol attach channel
        atacontrol detach channel
        atacontrol reinit channel
        atacontrol create type [interleave] disk0 ... diskN
        atacontrol delete array
        atacontrol addspare array disk
        atacontrol rebuild array
        atacontrol status array
        atacontrol mode device [mode]
        atacontrol cap device
        
atacontrol list
ATA channel 0:
    Master:  ad0 <ST3160215A/3.AAD> ATA/ATAPI revision 7
    Slave:       no device present
ATA channel 1:
    Master:      no device present
    Slave:       no device present

detailed info about a hard disk device

atacontrol cap ad0

Protocol              ATA/ATAPI revision 7
device model          ST3160215A
serial number         9RA8M9EK
firmware revision     3.AAD
cylinders             16383
heads                 16
sectors/track         63
lba supported         268435455 sectors
lba48 supported       312581808 sectors
dma supported
overlap not supported

Feature                      Support  Enable    Value           Vendor
write cache                    yes   yes
read ahead                     yes   yes
Tagged Command Queuing (TCQ)   no   no   0/0x00
SMART                          yes   yes
microcode download             yes   yes
security                       yes   no
power management               yes   yes
advanced power management      no   no   65278/0xFEFE
automatic acoustic management  no   no   0/0x00   208/0xD0

lspci:
lspci command to print PCI hardware on the machine.
By default "lspci" command is only available on Linux distro's only.

To enable in FreeBSD you need to install pciutils

# cd /usr/ports/sysutils/pciutils
# make install clean

pciconf:
lspci equivalent command in FreeBSD is pciconf

# pciconf -lv

================================================================================
PERFORMANCE
--------------------------------------------------------------------------------

http://makepp.sourceforge.net/2.0/perl_performance.html

-----------------------------
https://stackoverflow.com/questions/19319989/my-perl-script-starts-too-slowly-and-includes-many-modules-can-i-precompile-i


If some of the packages you import are not needed at startup, change use calls 
to require and move them to the places in your code where the packages are needed 
(so you import them when they are needed, not necessarily at startup). Depending 
on how complex your program is, it could be a lot of work to figure out what calls 
can be changed without breaking your program or affecting its behavior.
