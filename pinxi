#!/usr/bin/env perl
## infobash: Copyright (C) 2005-2007  Michiel de Boer a.k.a. locsmif
## inxi: Copyright (C) 2008-2018 Harald Hope
##       Additional features (C) Scott Rogers - kde, cpu info
## Further fixes (listed as known): Horst Tritremmel <hjt at sidux.com>
## Steven Barrett (aka: damentz) - usb audio patch; swap percent used patch
## Jarett.Stevens - dmidecode -M patch for older systems with the /sys
##
## License: GNU GPL v3 or greater
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## If you don't understand what Free Software is, please read (or reread)
## this page: http://www.gnu.org/philosophy/free-sw.html

use strict;
use warnings;
# use diagnostics;
use 5.008;

# use Cwd; # qw(abs_path);
# use Data::Dump qw(dump); # damn, not in core modules
use Data::Dumper qw(Dumper); # print_r
# use File::Basename;
use File::Find;
# use Getopt::Long qw(GetOptionsFromArray); # :config no_ignore_case bundling_values
use Getopt::Long qw(GetOptions);
# Note: default auto_abbrev is enabled, that's fine
Getopt::Long::Configure ('bundling', 'no_ignore_case', 
'no_getopt_compat', 'no_auto_abbrev','pass_through');
# use Net::FTP; # load this where it's used in debugger only
# use Path::Class; # maybe use, maybe not, for ls /sys
use POSIX qw(uname strftime ttyname);
use Sys::Hostname;
use Time::HiRes qw(gettimeofday tv_interval);
# use feature qw(state);

## INXI INFO ##
my $self_name='pinxi';
my $self_version='2.9.00';
my $self_date='2018-01-14';
my $self_patch='148-p';
## END INXI INFO ##

### INITIALIZE VARIABLES ###

## Self data
my ($self_path, $user_config_dir, $user_config_file,$user_data_dir);

## Debuggers
my $debug=0;
my ($end,$start,$t1,$t2,$t3,$fh_l,$log_file); # log file handle, file
my $t0 = [gettimeofday]; # let's start it right away

## Hashes
my ( %alerts, %client, %colors, %dl, %files, %rows, %system_files, %use );

## arrays
# ps_aux is full output, ps_cmd is only the last 10 to last
my (@app,@pci,@ps_aux,@ps_cmd);
my @test = (0,0,0,0,0);

#my $opt_parser = Getopt::Long::Parser->new;

## Booleans
my ($b_console_irc,$b_display,$b_force_dmidecode,$b_irc,$b_log,
$b_log_colors,$b_log_full,$b_root,$b_running_in_display);
my ($b_update,$b_weather) = (1,1);

## System
my $bsd_type = '';
my $cpu_sleep = 0.3;
my $dl_timeout = 4;
my $language = '';
my $os = '';
my $ps_count = 5;
my @paths = qw(/sbin /bin /usr/sbin /usr/bin /usr/X11R6/bin /usr/local/sbin /usr/local/bin);
$ENV{'PATH'} = join(':',@paths);
my $sensors_cpu_nu = 0;

## Tools
my ($display, $ftp_alt);
my $display_opt = '';

## Output
my $extra = 0;# supported values: 0-3
my $filter_string = '<filter>';
my $line1 = "----------------------------------------------------------------------\n";
my $line2 = "======================================================================\n";
my $line3 = "----------------------------------------\n";
my $output_type = 'screen';
my $prefix = 0; # for the primiary row hash key prefix

# these will assign a separator to non irc states. Important! Using ':' can 
# trigger stupid emoticon. Note: SEP1/SEP2 from short form not used anymore.
# behaviors in output on IRC, so do not use those.
my %sep = ( 
's1-irc' => ':',
's1-console' => ':',
's2-irc' => '',
's2-console' => ':',
);

my %show = ('host' => 1);

my %size = (
'console' => 115,
# Default indentation level. NOTE: actual indent is 1 greater to allow for 
# spacing
'indent' => 11,
'indent-min' => 90,
'irc' => 100, # shorter because IRC clients have nick  lists etc
'max' => 0,
'no-display' => 130,
# these will be set dynamically in set_display_width()
'term' => 80,
'term-lines' => 100,
);

## debug temp tools
$client{'test-konvi'} = 0;

########################################################################
#### STARTUP
########################################################################

#### -------------------------------------------------------------------
#### MAIN
#### -------------------------------------------------------------------

sub main {
# 	print Dumper \@ARGV;
	eval $start if $b_log;
	initialize();
	## use for start client debugging
	# $debug = 10;
	# set_debugger(); # for debugging of konvi issues
	#my $ob_start = StartClient->new();
	#$ob_start->get_client_data();
	StartClient::get_client_data();
	#print_line("path: $ENV{'PATH'}");
	# print_line( Dumper \%client);
	get_options();
	set_debugger(); # right after so it's set
	check_tools();
	set_colors();
	set_sep();
	# print download_file('stdout','https://') . "\n";
	generate_data();
	eval $end if $b_log;
	cleanup();
	# weechat's executor plugin forced me to do this, and rightfully so, 
	# because else the exit code from the last command is taken..
	exit 0;
}

#### -------------------------------------------------------------------
#### INITIALIZE
#### -------------------------------------------------------------------

sub initialize {
	set_os();
	# set_path();
	set_user_paths();
	set_basics();
	system_files('set');
	get_configs();
	# set_downloader();
	set_display_width('live');
}

sub check_tools {
	my ($action,$program,$message,@data,%commands,%hash);
	if ( $show{'memory'} || ( ( $bsd_type || $use{'dmidecode-force'} ) && ($show{'machine'} || $show{'battery'}) ) ){
		$action = 'use';
		if ($program = check_program('dmidecode')) {
			my $result = system("$program -t chassis >/dev/null 2>&1");
			if (!$result){
				if ($b_root) {
					@data = grabber("$program --type chassis");
					if ( grep { $_ =~ /No SMBIOS/i } @data ){
						$action = 'smbios';
					}
				}
			}
			elsif ($result){
				$action = 'permissions';
			}
		}
		else {
			$action = 'missing';
		}
		%hash = (
		'dmidecode' => {
		'action' => $action,
		'missing' => 'Required program dmidecode not available',
		'permissions' => 'Unable to run dmidecode. Are you root?',
		'smbios' => 'No SMBIOS data for dmidecode to process',
		},
		);
		%alerts = (%alerts, %hash);
	}
	if ( $show{'graphic'} ){
		foreach ( qw(xrandr xdpyinfo glxinfo) ){
			$action = 'use';
			if (check_program($_)) {
				if (!$b_display && !defined $display){
					if (!defined $display){$action = 'in-console' }
				}
			}
			else {
				$action = 'missing';
				# --display out of x override happens before this, so we need to retain that switch
				$show{'display-data'} = ( !$b_display && $show{'display-data'} == 2 ) ? 1 : 0;
			}
			%hash = (
			$_ => {
			'action' => $action,
			'missing' => "Missing: $_ - continuing in non desktop mode. Check --recommends",
			'in-console' => 'See --display option to get advanced graphics data',
			},
			);
			%alerts = (%alerts, %hash);
		}
	}
	# note: gnu/linux has sysctl so it may be used that for something if present
	# there is lspci for bsds so doesn't hurt to check it
	%commands = (
	'lspci' => '-n',
	);
	if ($bsd_type){
		%hash = (
		'pciconf' => '-l',
		'sysctl' => 'kernel.osrelease',
		);
		%commands = (%commands,%hash);
	}
	foreach ( keys %commands ){
		$action = 'use';
		if ($program = check_program($_)) {
			# > 0 means error in shell
			#my $cmd = "$program $commands{$_} >/dev/null";
			#print "$cmd\n";
			$action = 'permissions' if system("$program $commands{$_} >/dev/null 2>&1");
		}
		else {
			$action = 'missing';
		}
		%hash = (
		$_ => {
		'action' => $action,
		'missing' => "Missing system tool: $_. Output will be incomplete",
		'permissions' => "Unable to run $_. Root required?",
		},
		);
		%alerts = (%alerts, %hash);
	}
	%commands = ();
	if ( $show{'sensor'} ){
		%commands = (
		'sensors' => 'linux',
		);
	}
	foreach ( keys %commands ){
		$action = 'use';
		$message = 'Present and working';
		if ($commands{$_} eq 'linux' && $os ne 'linux'){
			$message = "No BSD support. No comparable $_ tool available.";
			$action = 'missing';
		}
		elsif (!check_program($_)){
			$message = "Required tool $_ not installed. Check --recommends";
			$action = 'missing';
		}
		%hash = (
		$_ => {
		'action' => $action,
		'missing' => $message,
		},
		);
		%alerts = (%alerts, %hash);
	}
	# print Dumper \%alerts;
}
sub set_basics {
	### LOCALIZATION - DO NOT CHANGE! ###
	# set to default LANG to avoid locales errors with , or .
	# Make sure every program speaks English.
	$ENV{'LANG'}='C';
	$ENV{'LC_ALL'}='C';
	# remember, perl uses the opposite t/f return as shell!!!
	$b_irc = ( system('tty>/dev/null') ) ? 1 : 0;
	# print "birc: $b_irc\n";
	$b_display = ( $ENV{'DISPLAY'} ) ? 1 : 0;
	$b_root = ( $ENV{'HOME'} eq '/root' ) ? 1 : 0;
	$dl{'dl'} = 'curl';
	$dl{'curl'} = 1;
	$dl{'tiny'} = 1; # note: tiny is actually tested for in set_downloader
	$dl{'wget'} = 1;
	$dl{'fetch'} = 1;
	$client{'console-irc'} = 0;
	$client{'dcop'} = (check_program('dcop')) ? 1 : 0;
	$client{'qdbus'} = (check_program('qdbus')) ? 1 : 0;
	$client{'konvi'} = 0;
	$client{'name'} = '';
	$client{'name-print'} = '';
	$client{'version'} = '';
	$colors{'default'} = 2;
	$show{'display-data'} = ( $b_display ) ? 1 : 0;
}

# args: $1 - default OR override default cols max integer count. $_[0]
# is the display width override.
sub set_display_width {
	my ($width) = @_;
	if ( $width eq 'live' ){
		## sometimes tput will trigger an error (mageia) if irc client
		if ( ! $b_irc ){
			if ( check_program('tput') ) {
				# trips error if use qx()...
				chomp($size{'term'}=qx{tput cols});
				chomp($size{'term-lines'}=qx{tput lines});
			}
			# print "tc: $size{'term'} cmc: $size{'console'}\n";
			# double check, just in case it's missing functionality or whatever
			if ( $size{'term'} == 0 || $size{'term'} !~ /\d/ ){ 
				$size{'term'}=80;
				$size{'term-lines'}=100;
			}
		}
		# this lets you set different size for in or out of display server
		# if ( ! $b_running_in_display && $configs{'COLS_MAX_NO_DISPLAY'} != 0 ){
		# 	$size{'console'}=$configs{'COLS_MAX_NO_DISPLAY'};
		# }
		# term_cols is set in top globals, using tput cols
		# print "tc: $size{'term'} cmc: $size{'console'}\n";
		if ( $size{'term'} < $size{'console'} ){
			$size{'console'}=$size{'term'};
		}
		# adjust, some terminals will wrap if output cols == term cols
		$size{'console'}=( $size{'console'} - 2 );
		# echo cmc: $size{'console'}
		# comes after source for user set stuff
		if ( ! $b_irc ){
			$size{'max'}=$size{'console'};
		}
		else {
			$size{'max'}=$size{'irc'};
		}
	}
	else {
		$size{'max'}=$width;
	}
	# print "tc: $size{'term'} cmc: $size{'console'} cm: $size{'max'}\n";
}

sub set_os {
	my @uname = uname();
	$os = lc($uname[0]);
	if ( $os =~ /(bsd|dragonfly|darwin)/ ){
		if ( $os =~ /openbsd/ ){
			$os = 'openbsd';
		}
		elsif ($os =~ /darwin/){
			$os = 'darwin';
		}
		if ($os =~ /kfreebsd/){
			$bsd_type = 'debian-bsd';
		}
		else {
			$bsd_type = 'bsd';
		}
	}
}
# not used, leaving for now in case something unaccounted happens.
# this data is now hard set top of program
sub set_path {
	my $added_paths = '';
	# Extra path variable to make execute failures less likely, merged below
	my @path = split ':', $ENV{'PATH'};
	#print "PATH=$ENV{'PATH'}\n";
	# Create a difference of $PATH and $extra_paths and add that to $PATH:
	foreach (@paths) {
		if ( ! grep (/$_/, @path) ){
			$added_paths .= ":$_";
			# print "$added_paths\n";
		}
	}
	$ENV{'PATH'} .= $added_paths;
	# print "PATH=$ENV{'PATH'}\n";
	##/bin/sh -c 'echo "PATH in subshell=\"$PATH\""'
}

sub set_sep {
	if ( $b_irc ){
		# too hard to read if no colors, so force that for users on irc
		if ($colors{'scheme'} == 0 ){
			$sep{'s1'} = $sep{'s1-console'};
			$sep{'s2'} = $sep{'s2-console'};
		}
		else {
			$sep{'s1'} = $sep{'s1-irc'};
			$sep{'s2'} = $sep{'s2-irc'};
		}
	}
	else {
		$sep{'s1'} = $sep{'s1-console'};
		$sep{'s2'} = $sep{'s2-console'};
	}
}

sub set_user_paths {
	my ( $b_conf, $b_data );
	# this needs to be set here because various options call the parent 
	# initialize function directly.
	$self_path = $0;
	$self_path =~ s/[^\/]+$//;
	
	if ( defined $ENV{'XDG_CONFIG_HOME'} && $ENV{'XDG_CONFIG_HOME'} ){
		$user_config_dir=$ENV{'XDG_CONFIG_HOME'};
		$b_conf=1;
	}
	elsif ( -d "$ENV{'HOME'}/.config" ){
		$user_config_dir="$ENV{'HOME'}/.config";
		$b_conf=1;
	}
	else {
		$user_config_dir="$ENV{'HOME'}/.$self_name";
	}
	if ( defined $ENV{'XDG_DATA_HOME'} && $ENV{'XDG_DATA_HOME'} ){
		$user_data_dir="$ENV{'XDG_DATA_HOME'}/$self_name";
		$b_data=1;
	}
	elsif ( -d "$ENV{'HOME'}/.local/share" ){
		$user_data_dir="$ENV{'HOME'}/.local/share/$self_name";
		$b_data=1;
	}
	else {
		$user_data_dir="$ENV{'HOME'}/.$self_name";
	}
	# note, this used to be created/checked in specific instance, but we'll just do it
	# universally so it's done at script start.
	if ( ! -d $user_data_dir ){
		mkdir $user_data_dir;
		system "echo", "Made: $user_data_dir";
	}
	if ( $b_conf && -f "$ENV{'HOME'}/.$self_name/$self_name.conf" ){
		#system 'mv', "-f $ENV{'HOME'}/.$self_name/$self_name.conf", $user_config_dir;
		# print "WOULD: Moved $self_name.conf from $ENV{'HOME'}/.$self_name to $user_config_dir\n";
	}
	if ( $b_data && -d "$ENV{'HOME'}/.$self_name" ){
		#system 'mv', '-f', "$ENV{'HOME'}/.$self_name/*", $user_data_dir;
		#system 'rm', '-Rf', "$ENV{'HOME'}/.$self_name";
		# print "WOULD: Moved data dir $ENV{'HOME'}/.$self_name to $user_data_dir\n";
	}
	$log_file="$user_data_dir/$self_name.log";
	#system 'echo', "$ENV{'HOME'}/.$self_name/* $user_data_dir";
	# print "scd: $user_config_dir sdd: $user_data_dir \n";
}
# args: 1: set|hash key to return either null or path
sub system_files {
	my ($file) = @_;
	if ( $file eq 'set'){
		%files = (
		'asound-cards' => '/proc/asound/cards',
		'asound-modules' => '/proc/asound/modules',
		'asound-version' => '/proc/asound/version',
		'cpuinfo' => '/proc/cpuinfo',
		'dmesg-boot' => '/var/run/dmesg.boot',
		'lsb-release' => '/etc/lsb-release',
		'mdstat' => '/proc/mdstat',
		'meminfo' => '/proc/meminfo',
		'modules' => '/proc/modules',
		'mounts' => '/proc/mounts',
		'os-release' => '/etc/os-release',
		'partitions' => '/proc/partitions',
		'scsi' => '/proc/scsi/scsi',
		'version' => '/proc/version',
		'xorg-log' => '/var/log/Xorg.0.log'
		);
		foreach ( keys %files ){
			$system_files{$_} = -e $files{$_} ? $files{$_} : '';
		}
		if ( ! $system_files{'xorg-log'} && check_program('xset') ){
			my $data = qx(xset q 2>/dev/null);
			foreach ( split /\n/, $data){
				if ($_ =~ /Log file/i){
					$system_files{'xorg-log'} = get_piece($_,3);
					last;
				}
			}
		}
	}
	else {
		return $system_files{$file};
	}
}
########################################################################
#### UTILITIES
########################################################################

#### -------------------------------------------------------------------
#### COLORS
#### -------------------------------------------------------------------

## arg: 1 - the type of action, either integer, count, or full
sub get_color_scheme {
	my ($type) = @_;
	eval $start if $b_log;
	my @color_schemes = (
	[qw(EMPTY EMPTY EMPTY )],
	[qw(NORMAL NORMAL NORMAL )],
	# for dark OR light backgrounds
	[qw(BLUE NORMAL NORMAL)],
	[qw(BLUE RED NORMAL )],
	[qw(CYAN BLUE NORMAL )],
	[qw(DCYAN NORMAL NORMAL)],
	[qw(DCYAN BLUE NORMAL )],
	[qw(DGREEN NORMAL NORMAL )],
	[qw(DYELLOW NORMAL NORMAL )],
	[qw(GREEN DGREEN NORMAL )],
	[qw(GREEN NORMAL NORMAL )],
	[qw(MAGENTA NORMAL NORMAL)],
	[qw(RED NORMAL NORMAL)],
	# for light backgrounds
	[qw(BLACK DGREY NORMAL)],
	[qw(DBLUE DGREY NORMAL )],
	[qw(DBLUE DMAGENTA NORMAL)],
	[qw(DBLUE DRED NORMAL )],
	[qw(DBLUE BLACK NORMAL)],
	[qw(DGREEN DYELLOW NORMAL )],
	[qw(DYELLOW BLACK NORMAL)],
	[qw(DMAGENTA BLACK NORMAL)],
	[qw(DCYAN DBLUE NORMAL)],
	# for dark backgrounds
	[qw(WHITE GREY NORMAL)],
	[qw(GREY WHITE NORMAL)],
	[qw(CYAN GREY NORMAL )],
	[qw(GREEN WHITE NORMAL )],
	[qw(GREEN YELLOW NORMAL )],
	[qw(YELLOW WHITE NORMAL )],
	[qw(MAGENTA CYAN NORMAL )],
	[qw(MAGENTA YELLOW NORMAL)],
	[qw(RED CYAN NORMAL)],
	[qw(RED WHITE NORMAL )],
	[qw(BLUE WHITE NORMAL)],
	# miscellaneous
	[qw(RED BLUE NORMAL )],
	[qw(RED DBLUE NORMAL)],
	[qw(BLACK BLUE NORMAL)],
	[qw(BLACK DBLUE NORMAL)],
	[qw(NORMAL BLUE NORMAL)],
	[qw(BLUE MAGENTA NORMAL)],
	[qw(DBLUE MAGENTA NORMAL)],
	[qw(BLACK MAGENTA NORMAL)],
	[qw(MAGENTA BLUE NORMAL)],
	[qw(MAGENTA DBLUE NORMAL)],
	);
	if ($type eq 'count' ){
		return scalar @color_schemes;
	}
	if ($type eq 'full' ){
		return @color_schemes;
	}
	else {
		return @{$color_schemes[$type]};
		# print Dumper $color_schemes[$scheme_nu];
	}
	eval $end if $b_log;
}

sub set_color_scheme {
	eval $start if $b_log;
	my ($scheme) = @_;
	$colors{'scheme'} = $scheme;
	my $index = ( $b_irc ) ? 1 : 0; # defaults to non irc
	
	# NOTE: qw(...) kills the escape, it is NOT the same as using 
	# Literal "..", ".." despite docs saying it is.
	my %color_palette = (
	'EMPTY' => [ '', '' ],
	'DGREY' => [ "\e[1;30m", "\x0314" ],
	'BLACK' => [ "\e[0;30m", "\x0301" ],
	'RED' => [ "\e[1;31m", "\x0304" ],
	'DRED' => [ "\e[0;31m", "\x0305" ],
	'GREEN' => [ "\e[1;32m", "\x0309" ],
	'DGREEN' => [ "\e[0;32m", "\x0303" ],
	'YELLOW' => [ "\e[1;33m", "\x0308" ],
	'DYELLOW' => [ "\e[0;33m", "\x0307" ],
	'BLUE' => [ "\e[1;34m", "\x0312" ],
	'DBLUE' => [ "\e[0;34m", "\x0302" ],
	'MAGENTA' => [ "\e[1;35m", "\x0313" ],
	'DMAGENTA' => [ "\e[0;35m", "\x0306" ],
	'CYAN' => [ "\e[1;36m", "\x0311" ],
	'DCYAN' => [ "\e[0;36m", "\x0310" ],
	'WHITE' => [ "\e[1;37m", "\x0300" ],
	'GREY' => [ "\e[0;37m", "\x0315" ],
	'NORMAL' => [ "\e[0m", "\x03" ],
	);
	my @scheme = get_color_scheme($colors{'scheme'});
	$colors{'c1'} = $color_palette{$scheme[0]}[$index];
	$colors{'c2'} = $color_palette{$scheme[1]}[$index];
	$colors{'cn'} = $color_palette{$scheme[2]}[$index];
	# print Dumper \@scheme;
	# print "$colors{'c1'}here$colors{'c2'} we are!$colors{'cn'}\n";
	eval $end if $b_log;
}

sub set_colors {
	eval $start if $b_log;
	# it's already been set with -c 0-43
	if ( exists $colors{'c1'} ){
		return 1;
	}
	# This let's user pick their color scheme. For IRC, only shows the color schemes, 
	# no interactive. The override value only will be placed in user config files. 
	# /etc/inxi.conf can also override
	if (exists $colors{'selector'}){
		my $ob_selector = SelectColors->new($colors{'selector'});
		$ob_selector->select_schema();
		return 1;
	}
	# set the default, then override as required
	my $color_scheme = $colors{'default'};
	# these are set in user configs
	if (defined $colors{'global'}){
		$color_scheme = $colors{'global'};
	}
	else {
		if ( $b_irc ){
			if (defined $colors{'irc-virt-term'} && $b_display && $client{'console-irc'}){
				$color_scheme = $colors{'irc-virt-term'};
			}
			elsif (defined $colors{'irc-console'} && !$b_display){
				$color_scheme = $colors{'irc-console'};
			}
			elsif ( defined $colors{'irc-gui'}) {
				$color_scheme = $colors{'irc-gui'};
			}
		}
		else {
			if (defined $colors{'console'} && !$b_display){
				$color_scheme = $colors{'console'};
			}
			elsif (defined $colors{'virt-term'}){
				$color_scheme = $colors{'virt-term'};
			}
		}
	}
	set_color_scheme($color_scheme);
	eval $end if $b_log;
}

#### -------------------------------------------------------------------
#### CONFIGS
#### -------------------------------------------------------------------

sub check_config_file {
	$user_config_file = "$user_config_dir/$self_name.conf";
	if ( ! -f $user_config_file ){
		open( my $fh, '>', $user_config_file ) or error_handler('create', $user_config_file, $!);
	}
}

sub get_configs {
	my (@configs) = @_;
	my ($key, $val,@config_files);
	if (!@configs){
		@config_files = (
		qq(/etc/$self_name.conf), 
		qq($user_config_dir/$self_name.conf)
		);
	}
	else {
		@config_files = (@configs);
	}
	# Config files should be passed in an array as a param to this function.
	# Default intended use: global @CONFIGS;
	foreach (@config_files) {
		next unless open (my $fh, '<', "$_");
		while (<$fh>) {
			chomp;
			s/#.*//;
			s/^\s+//;
			s/\s+$//;
			s/'|"//g;
			s/true/1/; # switch to 1/0 perl boolean
			s/false/0/; # switch to 1/0 perl boolean
			next unless length;
			($key, $val) = split(/\s*=\s*/, $_, 2);
			get_config_item($key,$val);
			# print "f: $file key: $key val: $val\n";
		}
		close $fh;
	}
}

# args: 0: key; 1: value
sub get_config_item {
	my ($key,$val) = @_;
	if ($key eq 'B_ALLOW_UPDATE') {$b_update = $val}
	elsif ($key eq 'B_ALLOW_WEATHER') {$b_weather = $val}
	elsif ($key eq 'CPU_SLEEP') {$cpu_sleep = $val}
	elsif ($key eq 'DL_TIMEOUT') {$dl_timeout = $val}
	elsif ($key eq 'DOWNLOADER') {
	if ($val =~ /^(curl|fetch|ftp|perl|wget)$/){
		# this dumps all the other data and resets %dl for only the
		# desired downloader.
		$val = set_perl_downloader($val);
		%dl = ('dl' => $val, $val => 1);
	}}
	elsif ($key eq 'FILTER_STRING') {$filter_string = $val}
	elsif ($key eq 'LANGUAGE') {$language = $val}
	elsif ($key eq 'OUTPUT_TYPE') {$output_type = $val if $val =~ /^csv|json|screen|xml/}
	elsif ($key eq 'PS_COUNT') {$ps_count = $val }
	elsif ($key eq 'SENSORS_CPU_NO') {$sensors_cpu_nu = $val}
	# layout
	elsif ($key eq 'CONSOLE_COLOR_SCHEME') {$colors{'console'} = $val}
	elsif ($key eq 'GLOBAL_COLOR_SCHEME') {$colors{'global'} = $val}
	elsif ($key eq 'IRC_COLOR_SCHEME') {$colors{'irc-gui'} = $val}
	elsif ($key eq 'IRC_CONS_COLOR_SCHEME') {$colors{'irc-console'} = $val}
	elsif ($key eq 'IRC_X_TERM_COLOR_SCHEME') {$colors{'irc-virt-term'} = $val}
	elsif ($key eq 'VIRT_TERM_COLOR_SCHEME') {$colors{'virt-term'} = $val}
	# note: not using the old short SEP1/SEP2
	elsif ($key eq 'SEP1_IRC') {$sep{'s1-irc'} = $val}
	elsif ($key eq 'SEP1_CONSOLE') {$sep{'s1-console'} = $val}
	elsif ($key eq 'SEP[23]_IRC') {$sep{'s2-irc'} = $val}
	elsif ($key eq 'SEP[23]_CONSOLE') {$sep{'s2-console'} = $val}
	
	# size
	elsif ($key eq 'COLS_MAX_CONSOLE') {$size{'console'} = $val}
	elsif ($key eq 'COLS_MAX_IRC') {$size{'irc'} = $val}
	elsif ($key eq 'COLS_MAX_NO_DISPLAY') {$size{'no-display'} = $val}
	#  print "mc: key: $key val: $val\n";
	# print Dumper (keys %size) . "\n";
}

{
package SelectColors;

# use warnings;
# use strict;
# use diagnostics;
# use 5.008;

my (@data,@rows,%configs,%status);
my ($type,$w_fh);
my $safe_color_count = 12; # null/normal + default color group
my $count = 0;

# args: 1 - type
sub new {
	my $class = shift;
	($type) = @_;
	my $self = {};
	return bless $self, $class;
}
sub select_schema {
	eval $start if $b_log;
	assign_selectors();
	main::set_color_scheme(0);
	set_status();
	start_selector();
	create_color_selections();
	if (! $b_irc ){
		main::check_config_file();
		get_selection();
	}
	else {
		print_irc_message();
	}
	eval $end if $b_log;
}

sub set_status {
	$status{'console'} = (defined $colors{'console'}) ? "Set: $colors{'console'}" : 'Unset';
	$status{'virt-term'} = (defined $colors{'virt-term'}) ? "Set: $colors{'virt-term'}" : 'Unset';
	$status{'irc-console'} = (defined $colors{'irc-console'}) ? "Set: $colors{'irc-console'}" : 'Unset';
	$status{'irc-gui'} = (defined $colors{'irc-gui'}) ? "Set: $colors{'irc-gui'}" : 'Unset';
	$status{'irc-virt-term'} = (defined $colors{'irc-virt-term'}) ? "Set: $colors{'irc-virt-term'}" : 'Unset';
	$status{'global'} = (defined $colors{'global'}) ? "Set: $colors{'global'}" : 'Unset';
}

sub assign_selectors {
	if ($type == 94){
		$configs{'variable'} = 'CONSOLE_COLOR_SCHEME';
		$configs{'selection'} = 'console';
	}
	elsif ($type == 95){
		$configs{'variable'} = 'VIRT_TERM_COLOR_SCHEME';
		$configs{'selection'} = 'virt-term';
	}
	elsif ($type == 96){
		$configs{'variable'} = 'IRC_COLOR_SCHEME';
		$configs{'selection'} = 'irc-gui';
	}
	elsif ($type == 97){
		$configs{'variable'} = 'IRC_X_TERM_COLOR_SCHEME';
		$configs{'selection'} = 'irc-virt-term';
	}
	elsif ($type == 98){
		$configs{'variable'} = 'IRC_CONS_COLOR_SCHEME';
		$configs{'selection'} = 'irc-console';
	}
	elsif ($type == 99){
		$configs{'variable'} = 'GLOBAL_COLOR_SCHEME';
		$configs{'selection'} = 'global';
	}
}
sub start_selector {
	my $whoami = getpwuid($<) || "unknown???";
	if ( ! $b_irc ){
		@data = (
		[ 0, '', '', "Welcome to $self_name! Please select the default 
		$configs{'selection'} color scheme."],
		);
	}
	@rows = (
	[ 0, '', '', "Because there is no way to know your $configs{'selection'}
	foreground/background colors, you can set your color preferences from 
	color scheme option list below:"],
	[ 0, '', '', "0 is no colors; 1 is neutral."],
	[ 0, '', '', "After these, there are 4 sets:"],
	[ 0, '', '', "1-dark^or^light^backgrounds; 2-light^backgrounds; 
	3-dark^backgrounds; 4-miscellaneous"],
	[ 0, '', '', ""],
	);
	push @data, @rows;
	if ( ! $b_irc ){
		@rows = (
		[ 0, '', '', "Please note that this will set the $configs{'selection'} 
		preferences only for user: $whoami"],
		);
		push @data, @rows;
	}
	@rows = (
	[ 0, '', '', "$line1"],
	);
	push @data, @rows;
	main::print_basic(@data); 
	@data = ();
}
sub create_color_selections {
	my $spacer = '^^'; # printer removes double spaces, but replaces ^ with ' '
	$count = ( main::get_color_scheme('count') - 1 );
	for my $i (0 .. $count){
		if ($i > 9){
			$spacer = '^';
		}
		if ($configs{'selection'} =~ /^global|irc-gui|irc-console|irc-virt-term$/ && $i > $safe_color_count ){
			last;
		}
		main::set_color_scheme($i);
		@rows = (
		[0, '', '', "$i)$spacer$colors{'c1'}Card:$colors{'c2'}^nVidia^GT218 
		$colors{'c1'}Display^Server$colors{'c2'}^x11^(X.Org^1.7.7)$colors{'cn'}"],
		);
		push @data, @rows;
	}
	main::print_basic(@data); 
	@data = ();
	main::set_color_scheme(0);
}
sub get_selection {
	my $number = $count + 1;
	@data = (
	[0, '', '', ($number++) . ")^Remove all color settings. Restore $self_name default."],
	[0, '', '', ($number++) . ")^Continue, no changes or config file setting."],
	[0, '', '', ($number++) . ")^Exit, use another terminal, or set manually."],
	[0, '', '', "$line1"],
	[0, '', '', "Simply type the number for the color scheme that looks best to your 
	eyes for your $configs{'selection'} settings and hit <ENTER>. NOTE: You can bring this 
	option list up by starting $self_name with option: -c plus one of these numbers:"],
	[0, '', '', "94^-^console,^not^in^desktop^-^$status{'console'}"],
	[0, '', '', "95^-^terminal,^desktop^-^$status{'virt-term'}"],
	[0, '', '', "96^-^irc,^gui,^desktop^-^$status{'irc-gui'}"],
	[0, '', '', "97^-^irc,^desktop,^in^terminal^-^$status{'irc-virt-term'}"],
	[0, '', '', "98^-^irc,^not^in^desktop^-^$status{'irc-console'}"],
	[0, '', '', "99^-^global^-^$status{'global'}"],
	[0, '', '',  ""],
	[0, '', '', "Your selection(s) will be stored here: $user_config_file"],
	[0, '', '', "Global overrides all individual color schemes. Individual 
	schemes remove the global setting."],
	[0, '', '', "$line1"],
	);
	main::print_basic(@data); 
	@data = ();
	my $response = <STDIN>;
	chomp $response;
	if ($response =~ /[^0-9]/ || $response > ($count + 3)){
		@data = (
		[0, '', '', "Error - Invalid Selection. You entered this: $response. Hit <ENTER> to continue."],
		[0, '', '',  "$line1"],
		);
		main::print_basic(@data); 
		my $response = <STDIN>;
		start_selector();
		create_color_selections();
		get_selection();
	}
	else {
		process_selection($response);
	}
}
sub process_selection {
	my $response = shift;
	if ($response == ($count + 3) ){
		@data = ([0, '', '', "Ok, exiting $self_name now. You can set the colors later."],);
		main::print_basic(@data); 
		exit 1;
	}
	elsif ($response == ($count + 2)){
		@data = ([0, '', '', "Ok, continuing $self_name unchanged. You can set the colors 
		anytime by starting with: -c 95 to 99"],);
		main::print_basic(@data); 
		if ( defined $colors{'console'} && !$b_display ){
			main::set_color_scheme($colors{'console'});
		}
		if ( defined $colors{'virt-term'} ){
			main::set_color_scheme($colors{'virt-term'});
		}
		else {
			main::set_color_scheme($colors{'default'});
		}
	}
	elsif ($response == ($count + 1)){
		@data = ([0, '', '', "Removing all color settings from config file now..."],);
		main::print_basic(@data); 
		delete_all_config_colors();
		main::set_color_scheme($colors{'default'});
	}
	else {
		main::set_color_scheme($response);
		@data = ([0, '', '', "Updating config file for $configs{'selection'} color scheme now..."],);
		main::print_basic(@data); 
		if ($configs{'selection'} eq 'global'){
			delete_all_config_colors();
		}
		set_config_color_scheme($response);
	}
}
sub delete_all_config_colors {
	my @file_lines = main::reader( $user_config_file );
	open( $w_fh, '>', $user_config_file ) or error_handler('open', $user_config_file, $!);
	foreach ( @file_lines ) { 
		if ( $_ !~ /^(CONSOLE_COLOR_SCHEME|GLOBAL_COLOR_SCHEME|IRC_COLOR_SCHEME|IRC_CONS_COLOR_SCHEME|IRC_X_TERM_COLOR_SCHEME|VIRT_TERM_COLOR_SCHEME)/){
			print {$w_fh} "$_"; 
		}
	} 
	close $w_fh;
}
sub set_config_color_scheme {
	my $value = shift;
	my @file_lines = main::reader( $user_config_file );
	my $b_found = 0;
	open( $w_fh, '>', $user_config_file ) or error_handler('open', $user_config_file, $!);
	foreach ( @file_lines ) { 
		if ( $_ =~ /^$configs{'variable'}/ ){
			$_ = "$configs{'variable'}=$value\n";
			$b_found = 1;
		}
		print $w_fh "$_";
	}
	if (! $b_found ){
		print $w_fh "$configs{'variable'}=$value\n";
	}
	close $w_fh;
}

sub print_irc_message {
	@data = (
	[ 0, '', '', "$line1"],
	[ 0, '', '', "After finding the scheme number you like, simply run this again
	in a terminal to set the configuration data file for your irc client. You can 
	set color schemes for the following: start inxi with -c plus:"],
	[ 0, '', '', "94 (console,^not^in^desktop^-^$status{'console'})"],
	[ 0, '', '', "95 (terminal, desktop^-^$status{'virt-term'})"],
	[ 0, '', '', "96 (irc,^gui,^desktop^-^$status{'irc-gui'})"],
	[ 0, '', '', "97 (irc,^desktop,^in terminal^-^$status{'irc-virt-term'})"],
	[ 0, '', '', "98 (irc,^not^in^desktop^-^$status{'irc-console'})"],
	[ 0, '', '', "99 (global^-^$status{'global'})"]
	);
	main::print_basic(@data); 
	exit 1;
}

}

#### -------------------------------------------------------------------
#### DEBUGGERS
#### -------------------------------------------------------------------


# called in the initial -@ 10 script args setting so we can get logging 
# as soon as possible # will have max 3 files, inxi.log, inxi.1.log, 
# inxi.2.log
sub begin_logging {
	return 1 if $fh_l; # if we want to start logging for testing before options
	my $log_file_2="$user_data_dir/$self_name.1.log";
	my $log_file_3="$user_data_dir/$self_name.2.log";
	my $data = '';
	$end='main::log_data("fe", (caller(1))[3], "");';
	$start='main::log_data("fs", (caller(1))[3], @_);';
	#require Time::HiRes;
	#import Time::HiRes;
	$t3 = tv_interval ($t0, [gettimeofday]);
	my $now = strftime "%Y-%m-%d %H:%M:%S", localtime;
	# do the rotation if logfile exists
	if ( -f $log_file ){
		# copy if present second to third
		if ( -f $log_file_2 ){
			rename $log_file_2, $log_file_3 or error_handler('rename', "$log_file_2 -> $log_file_3", "$!");
		}
		# then copy initial to second
		rename $log_file, $log_file_2 or error_handler('rename', "$log_file -> $log_file_2", "$!");
	}
	# now create the logfile
	# print "Opening log file for reading: $log_file\n";
	open $fh_l, '>', $log_file or error_handler(4, $log_file, "$!");
	# and echo the start data
	$data = $line2;
	$data = $data . "START $self_name LOGGING:\n";
	$data = $data . "$now\n";
	$data = $data . "Elapsed since start: $t3\n";
	$data = $data .  $line2;
	
	print $fh_l $data;
}

# NOTE: no logging available until get_parameters is run, since that's what 
# sets logging # in order to trigger earlier logging manually set $b_log
# to true in top variables.
# arg: $one alone: logs data; $two with or without $three logs func start/end.
# arg: $one type (fs/fe/cat/raw) or logged data; 
# [$two is function name; [$three - function args]]
sub log_data {
	return if ! $b_log;
	my ($one, $two, @args) = @_;
	my $args = '';
	my $data = '';
	my $spacer = '   ';
	# print "1: $one 2: $two 3: $three\n";
	if ($one eq 'fs') {
		if (@args){
			$args = "\n${spacer}Args: " . join(', ', @args) . '; ';
		}
		else {
			$args = "\n${spacer}Args: None; ";
		}
		# $t1 = [gettimeofday];
		$t3 = tv_interval ($t0, [gettimeofday]);
		$data = "Start: Function: $two$args\n${spacer}Elapsed: $t3\n";
		$spacer='';
	}
	elsif ( $one eq 'fe') {
		$t3 = tv_interval ($t0, [gettimeofday]);
		$data = "${spacer}Elapsed: $t3\nEnd: Function: $two\n";
		$spacer='';
	}
	elsif ( $one eq 'cat') {
		if ( $b_log_full ){
			for my $file ($two){
				my $contents = do { local( @ARGV, $/ ) = $file; <> }; # or: qx(cat $file)
				$data = "$data${line3}Full file data: $file\n\n$contents\n$line3\n";
			}
			$spacer='';
		}
	}
	elsif ( $one eq 'raw') {
		if ( $b_log_full ){
			$data = "\n${line3}Raw System Data:\n\n$two\n$line3";
			$spacer='';
		}
	}
	else {
		$data = "$one\n";
	}
	# print "d: $data";
	if ($data){
		print $fh_l "$spacer$data";
	}
}

sub set_debugger {
	if ( $debug < 10 || $debug > 12){
		$end = '';
		$start = '';
		if ( $debug >= 20 ){
			if ( $b_irc ){
				error_handler('not-in-irc', 'debug data generator');
			}
			my $ob_sys = SystemDebugger->new('full');
			$ob_sys->run_debugger();
			if ( $debug > 20 ){
				$ob_sys->upload_file($ftp_alt);
			}
			exit 0;
		}
	}
	elsif ($debug >= 10 && $debug <= 12){
		$b_log = 1;
		if ($debug == 11){
			$b_log_full = 1;
		}
		elsif ($debug == 12){
			$b_log_colors = 1;
		}
		begin_logging();
	}
}

# SystemDebugger
{
package SystemDebugger;

# use warnings;
# use strict;
# use diagnostics;
# use 5.008;
# use Net::FTP; # never load until needed

# use File::Find q(find);
#no warnings 'File::Find';
# use File::Spec::Functions;
#use File::Copy;
#use POSIX qw(strftime);

my $type = 'full';
my $upload = '';
my $data_dir = '';
my $debug_dir = '';
my $debug_gz = '';
my @content = (); 
my $b_debug = 0;
my $b_delete_dir = 1;
# args: 1 - type
# args: 2 - upload
sub new {
	my $class = shift;
	($type) = @_;
	my $self = {};
	# print "$f\n";
	# print "$type\n";
	return bless $self, $class;
}

sub run_debugger {
	require File::Copy;
	import File::Copy;
	require File::Spec::Functions;
	import File::Spec::Functions;
	
	print "Starting $self_name debugging data collector...\n";
	create_debug_directory();
	print "Note: for dmidecode data you must be root.\n" if $b_root;
	print $line3;
	if (!$b_debug){
		disk_data();
		display_data();
		network_data();
		perl_modules();
		system_data();
	}
	system_files();
	print $line3;
	if (!$b_debug){
		if ( -d '/sys' && main::count_dir_files('/sys') ){
			sys_tree();
			sys_traverse_data();
		}
		else {
			print "Skipping /sys data collection. /sys not present, or empty.\n";
		}
		print $line3;
	}
	run_self();
	print $line3;
	compress_dir();
}

sub create_debug_directory {
	my $host = main::get_hostname();
	$host =~ s/ /-/g;
	$host ||= 'no-host';
	my $bsd_string = '';
	my $root_string = '';
	# note: Time::Piece was introduced in perl 5.9.5
	my ($sec,$min,$hour,$mday,$mon,$year) = localtime;
	$year = $year+1900;
	$mon += 1;
	if (length($sec)  == 1) {$sec = "0$sec";}
	if (length($min)  == 1) {$min = "0$min";}
	if (length($hour) == 1) {$hour = "0$hour";}
	if (length($mon)  == 1) {$mon = "0$mon";}
	if (length($mday) == 1) {$mday = "0$mday";}
	
	my $today = "$year-$mon-${mday}_$hour$min$sec";
	# my $date = strftime "-%Y-%m-%d_", localtime;
	if ($b_root){
		$root_string = '-root';
	}
	if ( $bsd_type ){
		$bsd_string = "-$bsd_type-$os";
	}
	$debug_dir = "$self_name$bsd_string-$host-$today$root_string";
	$debug_gz = "$debug_dir.tar.gz";
	$data_dir = "$user_data_dir/$debug_dir";
	if ( -d $data_dir ){
		unlink $data_dir or main::error_handler('remove', "$data_dir", "$!");
	}
	mkdir $data_dir or main::error_handler('mkdir', "$data_dir", "$!");
	if ( -e "$user_data_dir/$debug_gz" ){
		#rmdir "$user_data_dir$debug_gz" or main::error_handler('remove', "$user_data_dir/$debug_gz", "$!");
		print "Failed removing leftover directory:\n$user_data_dir$debug_gz error: $?" if system('rm','-rf',"$user_data_dir$debug_gz");
	}
	print "Data going into: $data_dir\n";
}
sub compress_dir {
	print "Creating tar.gz compressed file of this material...\n";
	print "File: $debug_gz\n";
	system("cd $user_data_dir; tar -czf $debug_gz $debug_dir");
	print "Removing $data_dir...\n";
	#rmdir $data_dir or print "failed removing: $data_dir error: $!\n";
	return 1 if !$b_delete_dir;
	if (system('rm','-rf',$data_dir) ){
		print "Failed removing: $data_dir\nError: $?\n";
	}
	else {
		print "Directory removed.\n";
	}
}
## NOTE: >/dev/null 2>&1 is sh, and &>/dev/null is bash, fix this
# ls -w 1 /sysrs > tester 2>&1
sub disk_data {
	my (%data,@files,@files2);
	print "Collecting dev, label, disk, uuid data, df...\n";
	@files = (
	'/etc/fstab',
	'/etc/mtab',
	'/proc/mdstat',
	'/proc/mounts',
	'/proc/partitions',
	'/proc/scsi/scsi',
	'/proc/sys/dev/cdrom/info',
	);
	if (-d '/proc/ide/'){
		my @ides = </proc/ide/*/*>;
		@files = (@files, @ides) if @ides;
	}
	else {
		push (@files, '/proc-ide-directory');
	}
	copy_files(\@files, 'disk');
	my @cmds = (
	['btrfs', 'filesystem show'],
	['btrfs', 'filesystem show --mounted'],
	# ['btrfs', 'filesystem show --all-devices'],
	['df', '-h -T -P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 --exclude-type=devfs --exclude-type=linprocfs --exclude-type=sysfs --exclude-type=fdescfs '],
	['df', '-T -P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 --exclude-type=devfs --exclude-type=linprocfs --exclude-type=sysfs --exclude-type=fdescfs'],
	['df', '-T -P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 --exclude-type=devfs --exclude-type=linprocfs --exclude-type=sysfs --exclude-type=fdescfs --total'],
	['df', '-h -T'],
	['df', '-h'],
	['df', '-k -T'],
	['df', '-k'],
	['df', '-P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 '],
	['df', '-P'],
	['gpart', 'list'],
	['gpart', 'show'],
	['gpart', 'status'],
	['ls', '-l /dev'],
	['ls', '-l /dev/disk'],
	['ls', '-l /dev/disk/by-id'],
	['ls', '-l /dev/disk/by-label'],
	['ls', '-l /dev/disk/by-uuid'],
	# http://comments.gmane.org/gmane.linux.file-systems.zfs.user/2032
	['ls', '-l /dev/disk/by-wwn'],
	['ls', '-l /dev/disk/by-path'],
	['ls', '-l /dev/mapper'],
	['mount', ''],
	['nvme', 'present-only'],
	['readlink', '/dev/root'],
	['swapon', '-s'],
	['zfs', 'list'],
	['zpool', 'list'],
	['zpool', 'list -v'],
	);
	run_commands(\@cmds,'disk');
	@cmds = (
	['atacontrol', 'list'],
	['camcontrol', 'devlist'],
	['swapctl', '-l -k'],
	['sysctl', '-b kern.geom.conftxt'],
	['sysctl', '-b kern.geom.confxml'],
	);
	run_commands(\@cmds,'disk-bsd');
}
sub display_data {
	my (%data,@files,@files2);
	my $working = '';
	if ( ! $b_display ){
		print "Warning: only some of the data collection can occur if you are not in X\n";
		system("touch $data_dir/warning-user-not-in-x");
	}
	if ( $b_root ){
		print "Warning: only some of the data collection can occur if you are running as Root user\n";
		system("touch $data_dir/warning-root-user");
	}
	print "Collecting Xorg log and xorg.conf files...\n";
	if ( -d "/etc/X11/xorg.conf.d/" ){
		@files = glob q("/etc/X11/xorg.conf.d/*");
	}
	else {
		@files = ('/xorg-conf-d');
	}
	push (@files, $files{'xorg-log'});
	push (@files, '/etc/X11/xorg.conf');
	copy_files(\@files,'xorg');
	print "Collecting X, xprop, glxinfo, xrandr, xdpyinfo data, wayland, weston...\n";
	%data = (
	'desktop-session' => $ENV{'DESKTOP_SESSION'},
	'gdmsession' => $ENV{'GDMSESSION'},
	'gnome-desktop-session-id' => $ENV{'GNOME_DESKTOP_SESSION_ID'},
	'kde3-full-session' => $ENV{'KDE_FULL_SESSION'},
	'xdg-current-desktop' => $ENV{'XDG_CURRENT_DESKTOP'},
	'kde-gte-4-session-version' => $ENV{'KDE_SESSION_VERSION'},
	'xdg-session-desktop' => $ENV{'XDG_SESSION_DESKTOP'},
	# wayland data collectors:
	'xdg-session-type' => $ENV{'XDG_SESSION_TYPE'},
	'wayland-display' =>  $ENV{'WAYLAND_DISPLAY'},
	'gdk-backend' => $ENV{'GDK_BACKEND'},
	'qt-qpa-platform' => $ENV{'QT_QPA_PLATFORM'},
	'clutter-backend' => $ENV{'CLUTTER_BACKEND'},
	'sdl-videodriver' => $ENV{'SDL_VIDEODRIVER'},
	);
	write_data(\%data,'display');
	my @cmds = (
	# kde 5/plasma desktop 5, this is maybe an extra package and won't be used
	['about-distro',''],
	['glxinfo',''],
	['glxinfo','-B'],
	['kded','--version'],
	['kded4','--version'],
	['kded5','--version'],
	['kded6','--version'],
	['kf4-config','--version'],
	['kf5-config','--version'],
	['kf6-config','--version'],
	['plasmashell','--version'],
	['kwin_x11','--version'],
	['loginctl','--no-pager list-sessions'],
	['weston-info',''],
	['weston','--version'],
	['xdpyinfo',''],
	['Xorg','-version'],
	['xprop','-root'],
	['xrandr',''],
	);
	run_commands(\@cmds,'display');
}
sub network_data {
	print "Collecting networking data...\n";
# 	no warnings 'uninitialized';
	my @cmds = (
	['ifconfig',''],
	['ip','addr'],
	);
	run_commands(\@cmds,'network');
}
sub perl_modules {
	print "Collecting Perl module data (this can take a while)...\n";
	my @modules = ();
	my ($dirname,$holder,$mods,$value) = ('','','','');
	my $filename = 'perl-modules.txt';
	my @inc;
	foreach (sort @INC){
		# some BSD installs have . n @INC path
		if (-d $_ && $_ ne '.'){
			$_ =~ s/\/$//; # just in case, trim off trailing slash
			$value .= "EXISTS: $_\n";
			push @inc, $_;
		} 
		else {
			$value .= "ABSENT: $_\n";
		}
	}
	main::writer("$data_dir/perl-inc-data.txt",$value);
	File::Find::find { wanted => sub { 
		push @modules, File::Spec->canonpath($_) if /\.pm\z/  
	}, no_chdir => 1 }, @inc;
	@modules = sort(@modules);
	foreach (@modules){
		my $dir = $_;
		$dir =~ s/[^\/]+$//;
		if (!$holder || $holder ne $dir ){
			$holder = $dir;
			$value = "DIR: $dir\n";
			$_ =~ s/^$dir//;
			$value .= " $_\n";
		}
		else {
			$value = $_;
			$value =~ s/^$dir//;
			$value = " $value\n";
		}
		$mods .= $value;
	}
	open (my $fh, '>', "$data_dir/$filename");
	print $fh $mods;
	close $fh;
}
sub system_data {
	print "Collecting system data...\n";
	my %data = (
	'cc' => $ENV{'CC'},
	'size-indent' => $size{'indent'},
	'size-indent-min' => $size{'indent-min'},
	'size-cols-max' => $size{'max'},
	'xdg-config-home' => $ENV{'XDG_CONFIG_HOME'},
	'xdg-config-dirs' => $ENV{'XDG_CONFIG_DIRS'},
	'xdg-data-home' => $ENV{'XDG_DATA_HOME'},
	'xdg-data-dirs' => $ENV{'XDG_DATA_DIRS'},
	);
	my @files = </proc/asound/card*/codec*>;
	if (@files){
		my $asound = qx(head -n 1 /proc/asound/card*/codec* 2>&1);
		$data{'proc-asound-codecs'} = $asound;
	}
	else {
		$data{'proc-asound-codecs'} = undef;
	}
	@files = </usr/bin/gcc*>;
	if (@files){
		$data{'gcc-versions'} = join "\n",@files;
	}
	else {
		$data{'gcc-versions'} = undef;
	}
	@files = </sys/*>;
	if (@files){
		$data{'sys-tree-ls-1-basic'} = join "\n", @files;
	}
	else {
		$data{'sys-tree-ls-1-basic'} = undef;
	}
	write_data(\%data,'system');
	# bsd tools http://cb.vu/unixtoolbox.xhtml
	my @cmds = (
	# general
	['usbdevs','-v'],
	# freebsd
	['pciconf','-l -cv'],
	['pciconf','-vl'],
	['pciconf','-l'],
	# openbsd
	['pcidump',''],
	['pcidump','-v'],
	# netbsd
	['kldstat',''],
	['pcictl','list'],
	['pcictl','list -ns'],
	);
	run_commands(\@cmds,'system-bsd');
	# diskinfo -v <disk>
	# fdisk <disk>
	@cmds = (
	['clang','--version'],
	['dmidecode',''],
	['dmesg',''],
	['gcc','--version'],
	['hciconfig','-a'],
	['initctl','list'],
	['lscpu',''],
	['lspci','-k'],
	['lspci','-knn'],
	['lspci','-knnv'],# returns ports
	['lspci','-n'],
	['lspci','-nn'],
	['lspci','-nnk'],
	['lspci','-mm'],
	['lspci','-mmk'],
	['lspci','-mmkv'],
	['lspci','-mmnn'],
	['lspci','-v'],
	['lspci',''],
	['lsusb',''],
	['lsusb','-v'],
	['nvidia-smi','-q'],
	['nvidia-smi','-q -x'],
	['ps','aux'],
	['ps','-e'],
	['ps','-p 1'],
	['runlevel',''],
	['rc-status','-a'],
	['rc-status','-l'],
	['rc-status','-r'],
	['sensors',''],
	# leaving this commented out to remind that some systems do not
	# support strings --version, but will just simply hang at that command
	# which you can duplicate by simply typing: strings then hitting enter.
	# ['strings','--version'],
	['strings','present-only'],
	['sysctl','-a'],
	['systemctl','list-units'],
	['systemctl','list-units --type=target'],
	['systemd-detect-virt',''],
	);
	run_commands(\@cmds,'system');
}
sub system_files {
	print "Collecting system files data...\n";
	# main::check_recommends() > $data_dir/check-recommends.txt 2>&1
	my (%data,@files,@files2);
	@files = RepoData::get($data_dir);
	copy_files(\@files, 'repo');
	# chdir "/etc";
	@files = glob q("/etc/*[-_]{[rR]elease,[vV]ersion}");
	push (@files, '/etc/issue');
	copy_files(\@files,'distro');
	
	@files = (
	'/etc/lsb-release',
	'/etc/os-release',
	'/proc/1/comm',
	'/proc/asound/cards',
	'/proc/asound/version',
	'/proc/cpuinfo',
	'/proc/meminfo',
	'/proc/modules',
	'/proc/net/arp',
	'/proc/version',
	);
	@files2=</sys/class/power_supply/*/uevent>;
	if (@files2){
		@files = (@files,@files2);
	}
	else {
		push (@files, '/sys-class-power-supply-empty');
	}
	copy_files(\@files, 'system');
	@files = (
	'/etc/make.conf',
	'/etc/src.conf',
	'/var/run/dmesg.boot',
	);
	copy_files(\@files,'system-BSD');
	
}

sub copy_files {
	my ($files_ref, $variant) = @_;
	my ($absent,$error,$good,$name,$unreadable);
	$variant = ( $variant ) ? "$variant-" : '';
	foreach (@$files_ref) {
		$name = $_;
		$name =~ s/^\///;
		$name =~ s/\//-/g;
		$name = "$data_dir/file-$variant$name";
		$good = $name . '.txt';
		$absent = $name . '-absent';
		$error = $name . '-error';
		$unreadable = $name . '-unreadable';
		if (-e $_ ) {
			if (-r $_){
				copy($_,"$good") or main::toucher($error);
			}
			else {
				main::toucher($unreadable);
			}
		}
		else {
			main::toucher($absent);
		}
	}
}

sub run_commands {
	my ($cmds,$type) = @_;
	my $holder = '';
	my ($name,$cmd,$args);
	foreach (@$cmds){
		my @rows = @$_;
		if (my $program = main::check_program($rows[0])){
			if ($rows[1] eq 'present-only'){
				$name = "$data_dir/cmd-$type-$rows[0]-present";
				main::toucher($name);
			}
			else {
				$args = $rows[1];
				$args =~ s/\s|--|\/|=/-/g; # for:
				$args =~ s/--/-/g;# strip out -- that result from the above
				$args =~ s/^-//g;
				$args = "-$args" if $args;
				$name = "$data_dir/cmd-$type-$rows[0]$args.txt";
				$cmd = "$program $rows[1] >$name 2>&1";
				system($cmd);
			}
		}
		else {
			if ($holder ne $rows[0]){
				$name = "$data_dir/cmd-$type-$rows[0]-absent";
				main::toucher($name);
				$holder = $rows[0];
			}
		}
	}
}
sub write_data {
	my ($data_ref, $variant) = @_;
	my ($empty,$error,$fh,$good,$name,$undefined,$value);
	$variant = ( $variant ) ? "$variant-" : '';
	foreach (keys %$data_ref) {
		$value = $$data_ref{$_};
		$name = "$data_dir/data-$variant$_";
		$good = $name . '.txt';
		$empty = $name . '-empty';
		$error = $name . '-error';
		$undefined = $name . '-undefined';
		if (defined $value) {
			if ($value || $value eq '0'){
				open($fh, '>', $good) or main::toucher($error);
				print $fh "$value";
			}
			else {
				main::toucher($empty);
			}
		}
		else {
			main::toucher($undefined);
		}
	}
}

sub run_self {
	print "Creating $self_name output file now. This can take a few seconds...\n";
	print "Starting $self_name from: $self_path\n";
	my $cmd = "$self_path/$self_name -FRfrploudmxxx -c 0 --debug 10 -y 120 > $data_dir/inxi-FRfrploudmxxxy120.txt 2>&1";
	system($cmd);
	copy($log_file, "$data_dir") or main::error_handler('copy-failed', "$log_file", "$!");
}

sub sys_tree {
	print "Constructing /sys tree data...\n";
	if ( main::check_program('tree') ){
		my $dirname = '/sys';
		my $cmd;
		system("tree -a -L 10 /sys > $data_dir/sys-tree-full-10.txt");
		opendir my($dh), $dirname or main::error_handler('open-dir',"$dirname", "$!");
		my @files = readdir $dh;
		closedir $dh;
		foreach (@files){
			next if /^\./;
			$cmd = "tree -a -L 10 $dirname/$_ > $data_dir/sys-tree-$_-10.txt";
			#print "$cmd\n";
			system($cmd);
		}
	}
	else {
		sys_ls(1);
		sys_ls(2);
		sys_ls(3);
		sys_ls(4);
	}
}
sub sys_ls {
	my ( $depth) = @_;
	my $cmd = do {
		if ( $depth == 1 ){ 'ls -l /sys/ 2>/dev/null' }
		elsif ( $depth == 2 ){ 'ls -l /sys/*/ 2>/dev/null' }
		elsif ( $depth == 3 ){ 'ls -l /sys/*/*/ 2>/dev/null' }
		elsif ( $depth == 4 ){ 'ls -l /sys/*/*/*/ 2>/dev/null' }
		elsif ( $depth == 5 ){ 'ls -l /sys/*/*/*/*/ 2>/dev/null' }
		elsif ( $depth == 5 ){ 'ls -l /sys/*/*/*/*/ 2>/dev/null' }
	};
	my @working = ();
	my $output = '';
	my ($type);
	my $result = qx($cmd);
	open my $ch, '<', \$result or main::error_handler('open-data',"$cmd", "$!");
	while ( my $line = <$ch> ){
		chomp($line);
		$line =~ s/^\s+|\s+$//g;
		@working = split /\s+/, $line;
		$working[0] ||= '';
		if ( scalar @working > 7 ){
			if ($working[0] =~ /^d/ ){
				$type = "d - ";
			}
			elsif ($working[0] =~ /^l/){
				$type = "l - ";
			}
			else {
				$type = "f - ";
			}
			$working[9] ||= '';
			$working[10] ||= '';
			$output = $output . "  $type$working[8] $working[9] $working[10]\n";
		}
		elsif ( $working[0] !~ /^total/ ){
			$output = $output . $line . "\n";
		}
	}
	close $ch;
	my $file = "$data_dir/sys-tree-ls-$depth.txt";
	open my $fh, '>', $file or main::error_handler('create',"$file", "$!");
	print $fh $output;
	close $fh;
	# print "$output\n";
}

sub sys_traverse_data {
	print "Parsing /sys files...\n";
	# get rid pointless error:Can't cd to (/sys/kernel/) debug: Permission denied
	no warnings 'File::Find';
	File::Find::find( \&wanted, "/sys");
	process_data();
}
sub wanted {
	return if -d; # not directory
	return unless -e; # Must exist
	return unless -r; # Must be readable
	return unless -f; # Must be file
	# note: a new file in 4.11 /sys can hang this, it is /parameter/ then
	# a few variables. Since inxi does not need to see that file, we will
	# not use it. Also do not need . files or __ starting files
	# print $File::Find::name . "\n";
	# block maybe: cfgroup\/
	return if $File::Find::name =~ /\/(\.[a-z]|kernel\/|parameters\/|debug\/)/;
	# comment this one out if you experience hangs or if 
	# we discover syntax of foreign language characters
	# Must be ascii like. This is questionable and might require further
	# investigation, it is removing some characters that we might want
	return unless -T; 
	# print $File::Find::name . "\n";
	push (@content, $File::Find::name);
	return;
}
sub process_data {
	my ($data,$fh,$result,$row,$sep);
	my $filename = "sys-tree-parse.txt";
	# no sorts, we want the order it comes in
	# @content = sort @content; 
	foreach (@content){
		$data='';
		$sep='';
		open($fh, '<', $_);
		while ($row = <$fh>) {
			chomp $row;
			$data .= $sep . '"' . $row . '"';
			$sep=', ';
		}
		$result .= "$_:[$data]\n";
		# print "$_:[$data]\n"
	}
	# print scalar @content . "\n";
	open ($fh, '>', "$data_dir/$filename");
	print $fh $result;
	close $fh;
	# print $fh "$result";
}
# args: 1 - path to file to be uploaded
# args: 2 - optional: alternate ftp upload url
# NOTE: must be in format: ftp.site.com/incoming
sub upload_file {
	require Net::FTP;
	import Net::FTP;
	my ($self, $ftp_url) = @_;
	my ($ftp, $domain, $host, $user, $pass, $dir, $error);
	$ftp_url ||= main::get_defaults('ftp-upload');
	$ftp_url =~ s/\/$//g; # trim off trailing slash if present
	my @url = split(/\//, $ftp_url);
	my $file_path = "$user_data_dir/$debug_gz";
	$host = $url[0];
	$dir = $url[1];
	$domain = $host;
	$domain =~ s/^ftp\.//;
	$user = "anonymous";
	$pass = "anonymous\@$domain";
	
	print $line3;
	print "Uploading to: $ftp_url\n";
	# print "$host $domain $dir $user $pass\n";
	print "File to be uploaded: $file_path\n";
	
	if ($host && ( $file_path && -e $file_path ) ){
		# NOTE: important: must explicitly set to passive true/1
		$ftp = Net::FTP->new($host, Debug => 0, Passive => 1);
		$ftp->login($user, $pass) || main::error_handler('ftp-login', $ftp->message);
		$ftp->binary();
		$ftp->cwd($dir);
		print "Connected to FTP server.\n";
		$ftp->put($file_path) || main::error_handler('ftp-upload', $ftp->message);
		$ftp->quit;
		print "Uploaded file successfully!\n";
		print $ftp->message;
	}
	else {
		main::error_handler('ftp-bad-path', "$file_path");
	}
}
}

#### -------------------------------------------------------------------
#### DOWNLOADER
#### -------------------------------------------------------------------

sub download_file {
	my ($type, $url, $file) = @_;
	my ($cmd,$args,$timeout);
	my $result = 1;
	$dl{'no-ssl-opt'} ||= '';
	$dl{'spider'} ||= '';
	$file ||= ''; # to avoid debug error
	if ( ! $dl{'dl'} ){
		return 0;
	}
	if ($dl{'timeout'}){
		$timeout = "$dl{'timeout'}$dl_timeout";
	}
	
	# print "$dl{'no-ssl-opt'}\n";
	# print "$dl{'dl'}\n";
	# tiny supports spider sort of
	if ($dl{'dl'} eq 'tiny' ){
		print_line("Using tiny: type: $type \nurl: $url \nfile: $file\n") if $test[1];
		$result = get_file($type, $url, $file);
	}
	else {
		if ($type eq 'stdout'){
			$args = $dl{'stdout'};
			$cmd = "$dl{'dl'} $dl{'no-ssl-opt'} $timeout $args $url $dl{'null'}";
			print_line("$cmd\n") if $test[1];
			$result = qx($cmd);
		}
		elsif ($type eq 'file') {
			$args = $dl{'file'};
			$cmd = "$dl{'dl'} $dl{'no-ssl-opt'} $timeout $args $file $url $dl{'null'}";
			print_line("$cmd\n") if $test[1];
			system($cmd);
			$result = $?;
		}
		elsif ( $dl{'dl'} eq 'wget' && $type eq 'spider'){
			$cmd = "$dl{'dl'} $dl{'no-ssl-opt'} $timeout $dl{'spider'} $url";
			print_line("$cmd\n") if $test[1];
			system($cmd);
			$result = $?;
		}
	}
	return $result;
}

sub get_file {
	my ($type, $url, $file) = @_;
	my $response = HTTP::Tiny->new->get($url);
	my $return = 1;
	my $debug = 0;
	my $fh;
	
	if ( ! $response->{success} ){
		print "Failed to connect to server/file!\n";
		$return = 0;
	}
	else {
		if ( $debug ){
			print "$response->{success}\n";
			print "$response->{status} $response->{reason}\n";
			while (my ($key, $value) = each %{$response->{headers}}) {
				for (ref $value eq "ARRAY" ? @$value : $value) {
					print "$key: $_\n";
				}
			}
		}
		if ( $type eq "stdout" || $type eq "ua-stdout" ){
			$return = $response->{content};
		}
		elsif ($type eq "spider"){
			# do nothing, just use the return value
		}
		elsif ($type eq "file"){
			open($fh, ">", $file);
			print $fh $response->{content}; # or die "can't write to file!\n";
			close $fh;
		}
	}
	return $return;
}

sub set_downloader {
	eval $start if $b_log;
	$dl{'no-ssl'} = '';
	$dl{'null'} = '';
	$dl{'spider'} = '';
	# we only want to use HTTP::Tiny if it's present in user system.
	# It is NOT part of core modules.
	if ($dl{'tiny'}){
		eval "require HTTP::Tiny"; # if not found, return has error messages etc
		#print $@ . "\n";
		if ( $@ ) {
			$dl{'tiny'} = 0;
		}
		else {
			import HTTP::Tiny;
		}
	}
	#print $dl{'tiny'} . "\n";
	if ($dl{'tiny'}){
		$dl{'dl'} = 'tiny';
		$dl{'file'} = '';
		$dl{'stdout'} = '';
		$dl{'timeout'} = '';
	}
	elsif ( $dl{'curl'} && check_program('curl')  ){
		$dl{'dl'} = 'curl';
		$dl{'file'} = '  -L -s -o ';
		$dl{'no-ssl'} = ' --insecure';
		$dl{'stdout'} = ' -L -s ';
		$dl{'timeout'} = ' -y ';
	}
	elsif ($dl{'wget'} && check_program('wget') ){
		$dl{'dl'} = 'wget';
		$dl{'file'} = ' -q -O ';
		$dl{'no-ssl'} = ' --no-check-certificate';
		$dl{'spider'} = ' -q --spider';
		$dl{'stdout'} = '  -q -O -';
		$dl{'timeout'} = ' -T ';
	}
	elsif ($dl{'fetch'} && check_program('fetch')){
		$dl{'dl'} = 'fetch';
		$dl{'file'} = ' -q -o ';
		$dl{'no-ssl'} = ' --no-verify-peer';
		$dl{'stdout'} = ' -q -o -';
		$dl{'timeout'} = ' -T ';
	}
	elsif ( $bsd_type eq 'openbsd' && check_program('ftp') ){
		$dl{'dl'} = 'ftp';
		$dl{'file'} = ' -o ';
		$dl{'null'} = ' 2>/dev/null';
		$dl{'stdout'} = ' -q -O - ';
		$dl{'timeout'} = '';
	}
	else {
		$dl{'dl'} = '';
	}
	# no-ssl-opt is set to 1 with --alt 34, so it is true, then assign
	$dl{'no-ssl-opt'} = $dl{'no-ssl'} if $dl{'no-ssl-opt'};
	eval $end if $b_log;
}

sub set_perl_downloader {
	my ($downloader) = @_;
	$downloader =~ s/perl/tiny/;
	return $downloader;
}

#### -------------------------------------------------------------------
#### ERROR HANDLER
#### -------------------------------------------------------------------

sub error_handler {
	my ( $err, $one, $two) = @_;
	my $errno = 0;
	my $b_help = 0;
	my $message = do {
		if ( $err eq 'empty' ) { 'empty value' }
		## Basic rules
		elsif ( $err eq 'not-in-irc' ) { 
			$errno=1; "You can't run option $one in an IRC client!" }
		## Internal/external options
		elsif ( $err eq 'bad-arg' ) { 
			$errno=10; $b_help=1; "Unsupported value: $two for option: $one" }
		elsif ( $err eq 'bad-arg-int' ) { 
			$errno=11; "Bad internal argument: $one" }
		elsif ( $err eq 'distro-block' ) { 
			$errno=20; "Option: $one has been disabled by the $self_name distribution maintainer." }
		elsif ( $err eq 'unknown-option' ) { 
			$errno=21; $b_help=1; "Unsupported option: $one" }
		## Data
		elsif ( $err eq 'open-data' ) { 
			$errno=32; "Error opening data for reading: $one \nError: $two" }
		elsif ( $err eq 'download-error' ) { 
			$errno=32; "Error downloading file with $dl{'dl'}: $one \nError: $two" }
		## Files:
		elsif ( $err eq 'copy-failed' ) { 
			$errno=30; "Error copying file: $one \nError: $two" }
		elsif ( $err eq 'create' ) { 
			$errno=32; "Error creating file: $one \nError: $two" }
		elsif ( $err eq 'downloader-error' ) { 
			$errno=30; "Error downloading file: $one \nfor download source: $two" }
		elsif ( $err eq 'file-corrupt' ) { 
			$errno=31; "Downloaded file is corrupted: $one" }
		elsif ( $err eq 'mkdir' ) { 
			$errno=32; "Error creating directory: $one \nError: $two" }
		elsif ( $err eq 'open' ) { 
			$errno=32; "Error opening file: $one \nError: $two" }
		elsif ( $err eq 'open-dir' ) { 
			$errno=32; "Error opening directory: $one \nError: $two" }
		elsif ( $err eq 'not-writable' ) { 
			$errno=33; "The file: $one is not writable!" }
		elsif ( $err eq 'open-dir-failed' ) { 
			$errno=33; "The directory: $one failed to open with error: $two" }
		elsif ( $err eq 'remove' ) { 
			$errno=33; "Failed to remove file: $one Error: $two" }
		elsif ( $err eq 'rename' ) { 
			$errno=34; "There was an error moving files: $one\nError: $two" }
		elsif ( $err eq 'write' ) { 
			$errno=35; "Failed writing file: $one - Error: $two!" }
		## FTP
		elsif ( $err eq 'ftp-bad-path' ) { 
			$errno=50; "Unable to locate for FTP upload file:\n$one" }
		elsif ( $err eq 'ftp-login' ) { 
			$errno=50; "There was an error with login to ftp server: $one" }
		elsif ( $err eq 'ftp-login' ) { 
			$errno=51; "There was an error with upload to ftp server: $one" }
		## DEFAULT
		else {
			$errno=255; "Error handler ERROR!! Unsupported options: $err!"}
	};
	print_line("Error $errno: $message\n");
	if ($b_help){
		print_line("Check -h for correct parameters.\n");
	}
	exit 0;
}

#### -------------------------------------------------------------------
#### RECOMMENDS
#### -------------------------------------------------------------------

# CheckRecommends
{
package CheckRecommends;
sub run {
	main::error_handler('not-in-irc', 'recommends') if $b_irc;
	eval $start if $b_log;
	main::print_line("Would have run recommends\n");
	
	eval $end if $b_log;
	exit 1;
}
}

#### -------------------------------------------------------------------
#### TOOLS
#### -------------------------------------------------------------------

# Duplicates the functionality of awk to allow for one liner
# type data parsing. note: -1 corresponds to awk NF
# args 1: array of data; 2: search term; 3: field result; 4: separator
# correpsonds to: awk -F='separator' '/search/ {print $2}' <<< @data
# array is sent by reference so it must be dereferenced
# NOTE: if you just want the first row, pass it \S as search string
# NOTE: if $num is undefined, it will skip the second step
sub awk {
	eval $start if $b_log;
	my ($ref,$search,$num,$sep) = @_;
	my ($result);
	return if ! @$ref || ! $search;
	foreach (@$ref){
		if (/$search/i){
			$result = $_;
			$result =~ s/^\s+|\s+$//g;
			last;
		}
	}
	if ($result && defined $num){
		$sep ||= '\s+';
		$num-- if $num > 0; # retain the negative values as is
		$result = (split /$sep/, $result)[$num];
		$result =~ s/^\s+|,|\s+$//g if $result;
	}
	eval $end if $b_log;
	return $result;
}
# arg: 1 - string to strip start/end space/\n from
# note: a few nano seconds are saved by using raw $_[0] for program
sub check_program {
	(grep { return "$_/$_[0]" if -e "$_/$_[0]"} @paths)[0];
}

sub cleanup {
	# maybe add in future: , $fh_c, $fh_j, $fh_x
	foreach my $fh ($fh_l){
		if ($fh){
			close $fh;
		}
	}
}

# returns count of files in directory, if 0, dir is empty
sub count_dir_files {
	return unless -d $_[0];
	opendir my $dh, $_[0] or error_handler('open-dir-failed', "$_[0]", $!); 
	my $count = grep { ! /^\.{1,2}/ } readdir $dh; # strips out . and ..
	return $count;
}

# arg 1: type to return
sub get_defaults {
	my ($type) = @_;
	my %defaults = (
	'ftp-upload' => 'ftp.techpatterns.com/incoming',
	# 'inxi-branch-1' => 'https://github.com/smxi/inxi/raw/one/',
	# 'inxi-branch-2' => 'https://github.com/smxi/inxi/raw/two/',
	'inxi-main' => 'https://github.com/smxi/inxi/raw/master/',
	'inxi-pinxi' => 'https://github.com/smxi/inxi/raw/inxi-perl/',
	'inxi-man' => "https://github.com/smxi/inxi/raw/master/$self_name.1.gz",
	);
	if ( exists $defaults{$type}){
		return $defaults{$type};
	}
	else {
		error_handler('bad-arg-int', $type);
	}
}

# args: 0 - the string to get piece of
# 2 - the position in string, starting at 1 for 0 index.
# 3 - the separator, default is ' '
sub get_piece {
	eval $start if $b_log;
	my ($string, $num, $sep) = @_;
	$num--;
	$sep ||= '\s+';
	$string =~ s/^\s+|\s+$//g;
	my @temp = split(/$sep/, $string);
	eval $end if $b_log;
	if ( exists $temp[$num] ){
		$temp[$num] =~ s/,//g;
		return $temp[$num];
	}
}

# arg: 1 - command to turn into an array; 2 - optional: splitter
# 3 - optionsl, strip and clean data
# similar to reader() except this creates an array of data 
# by lines from the command arg
sub grabber {
	eval $start if $b_log;
	my ($cmd,$split,$strip) = @_;
	$split ||= "\n";
	my @rows = split /$split/, qx($cmd);
	if ($strip && @rows){
		@rows = grep {/^\s*[^#]/} @rows;
		@rows = map {s/^\s+|\s+$//g; $_} @rows if @rows;
	}
	eval $end if $b_log;
	return @rows;
}

# returns array of:
# 0 - match string; 1 - search number; 2 - version string; 3 - Print name
# 4 - console 0/1; 5 - 0/1 exit version loop at first iteration
# arg: 1 - program lower case name
sub program_values {
	my ($app) = @_;
	my (@client_data);
	my %data = (
	# clients
	'bitchx' => ['bitchx',2,'','BitchX',1,0],# special
	'finch' => ['finch',2,'-v','Finch',1,1],
	'gaim' => ['[0-9.]+',2,'-v','Gaim',0,1],
	'ircii' => ['[0-9.]+',3,'-v','ircII',1,1],
	'irssi' => ['irssi',2,'-v','Irssi',1,1],
	'irssi-text' => ['irssi',2,'-v','Irssi',1,1],
	'konversation' => ['konversation',2,'-v','Konversation',0,0],
	'kopete' => ['Kopete',2,'-v','Kopete',0,0],
	'kvirc' => ['[0-9.]+',2,'-v','KVIrc',0,0], # special
	'pidgin' => ['[0-9.]+',2,'-v','Pidgin',0,1],
	'quassel' => ['',1,'-v','Quassel [M]',0,0], # special
	'quasselclient' => ['',1,'-v','Quassel',0,0],# special
	'quasselcore' => ['',1,'-v','Quassel (core)',0,0],# special
	'gribble' => ['^Supybot',2,'--version','Gribble',1,0],# special
	'limnoria' => ['^Supybot',2,'--version','Limnoria',1,0],# special
	'supybot' => ['^Supybot',2,'--version','Supybot',1,0],# special
	'weechat' => ['[0-9.]+',1,'-v','WeeChat',1,0],
	'weechat-curses' => ['[0-9.]+',1,'-v','WeeChat',1,0],
	'xchat-gnome' => ['[0-9.]+',2,'-v','X-Chat-Gnome',1,1],
	'xchat' => ['[0-9.]+',2,'-v','X-Chat',1,1],
	# desktops 
	'afterstep' => ['^afterstep',3,'--version','AfterStep',0,1],
	'awesome' => ['^awesome',2,'--version','Awesome',0,1],
	'budgie' => ['^budgie-desktop',2,'--version','Budgie',0,1],
	'cinnamon' => ['^cinnamon',2,'--version','^Cinnamon',0,1],
	'dwm' => ['^dwm',1,'-v','dwm',0,1],
	'fluxbox' => ['^fluxbox',2,'--version','Fluxbox',0,1],
	'fvwm' => ['^fvwm',2,'--version','FVWM',0,1],
	# command: fvwm
	'fvwm-crystal' => ['^fvwm',2,'--version','FVWM-Crystal',0,1], 
	'gnome-about' => ['gnome',3,'--version','^Gnome',0,1],
	'gnome-shell' => ['gnome',3,'--version','^Gnome',0,1],
	'herbstluftwm' => ['^herbstluftwm',-1,'--version','herbstluftwm',0,1],
	'jwm' => ['^jwm',2,'--version','JWM',0,1],
	'i3' => ['^i3',2,'--version','i3',0,1],
	'icewm' => ['^icewm',2,'--version','IceWM',0,1],
	'kded3' => ['^KDE Development Platform:',4,'--version','KDE',0,1],
	# command: lxqt-about
	'lxqt' => ['^lxqt-about',2,'--version','LXQT',0,1],
	'mate' => ['^MATE[[:space:]]DESKTOP',-1,'--version','MATE',0,1],
	'openbox' => ['^openboxt',2,'--version','Openbox',0,1],
	'pekwm' => ['^pekwm',3,'--version','pekwm',0,1],
	'plasmashell' => ['^plasmashell',2,'--version','KDE Plasma',0,1],
	'qtdiag' => ['^qt',2,'--version','Qt',0,1],
	'sawfish' => ['^sawfish',3,'--version','Sawfish',0,1],
	'scrotwm' => ['^welcome.*scrotwm',4,'-v','Scrotwm',0,1],
	'spectrwm' => ['^spectrwm.*welcome.*spectrwm',5,'-v','Spectrwm',0,1],
	'unity' => ['^unity',2,'--version','Unity',0,1],
	'wm2' => ['^wm2',-1,'--version','WM2',0,1],
	'wmaker' => ['^Window[[:space:]]*Maker',-1,'--version','WindowMaker',0,1],
	'wmii' => ['^wmii',1,'--version','wmii',0,1], # note: in debian, wmii is wmii3
	'wmii2' => ['^wmii2',1,'--version','wmii2',0,1],
	'xfce4-panel' => ['^xfce4-panel',2,'--version','Xfce',0,1],
	'xfce5-panel' => ['^xfce5-panel',2,'--version','Xfce',0,1],
	'xfdesktop' => ['xfdesktop[[:space:]]version',5,'--version','Xfce',0,1],
	# command: xfdesktop
	'xfdesktop-toolkit' => ['Built[[:space:]]with[[:space:]]GTK',4,'--version','Gtk',0,1],
	
	# shells
	'bash' => ['^GNU[[:space:]]bash,[[:space:]]version',4,'--version','Bash',1,0],
	'csh' => ['^tcsh',2,'--version','csh',1,0],
	'dash' => ['dash',3,'--version','Dash',1,0], # no version, uses dpkg query, sigh
	'ksh' => ['version',5,'-v','csh',1,0], # ksh is too weird to try to handle with version
	'tcsh' => ['^tcsh',2,'--version','tcsh',1,0],
	'zsh' => ['^zsh',2,'--version','zsh',1,0],
	# tools
	'clang' => ['clang',4,'--version','Clang',1,0],
	'gcc' => ['^gcc',3,'--version','GCC',1,0],
	'gcc-apple' => ['Apple[[:space:]]LLVM',2,'--version','csh',1,0],
	);
	if ( defined $data{$app} ){
		my $ref = $data{$app};
		@client_data = @$ref;
	}
	#my $debug = main::Dumper \@client_data;
	# main::log_data("Client Data: " . main::Dumper \@client_data);
	return @client_data;
}
# args: 1 - desktop/app command for --version; 2 - search string; 
# 3 - space print number; 4 - [optional] version arg: -v, version, etc
sub program_version {
	eval $start if $b_log;
	my ($app, $search, $num,$version,$exit) = @_;
	my ($cmd,$line,$output);
	my $version_nu = '';
	my $count = 0;
	$exit ||= 100; # basically don't exit ever
	$version ||= '--version';
	
	# adjust to array index, not human readable
	$num-- if $num > 0;
	
	# dump these once the dm stuff is done, we'll pass this data
	# we're not trying to get ksh any more, it's too difficult
	#if ( $app =~ /^ksh/) {
	#	$version = '-v';
	#}
	# konvi in particular doesn't like using $ENV{'PATH'} as set, so we need
	# to always assign the full path if it hasn't already been done
	if ( $app !~ /^\//){
		$app = check_program($app);
	}
	# note, some wm/apps send version info to stderr instead of stdout
	if ( $app =~ /\/(dwm|ksh|kvirc|scrotwm)$/ ) {
		$cmd = "$app $version 2>&1";
	}
# 	elsif ( $app eq 'csh' ){
# 		$app = 'tcsh';
# 	}
	# quick debian/buntu hack until I find a universal way to get version for these
	elsif ( $app eq 'dash' ){
		$cmd = "dpkg -l $app 2>/dev/null";
	}
	else {
		$cmd = "$app $version 2>/dev/null";
	}
	log_data("version: $version num: $num search: $search command: $cmd") if $b_log;
	$output = qx($cmd);
	# print "$cmd : $output\n";
	# sample: dwm-5.8.2, ©.. etc, why no space? who knows. Also get rid of v in number string
	# xfce, and other, output has , in it, so dump all commas and parentheses
	if ($output){
		open my $ch, '<', \$output or error_handler('open-data',"$cmd", "$!");
		while (<$ch>){
			#chomp;
			last if $count > $exit;
			if ( $_ =~ /$search/i ) {
				$_ = trimmer($_);
				# print "$_ ::$num\n";
				$version_nu = (split /\s+/, $_)[$num];
				$version_nu =~ s/(|\([^)]+\)|,|dwm-|wmii2-|wmii-|v|V|\|)//g;
				# print "$version_nu\n";
				last;
			}
			$count++;
		}
		close $ch if $ch;
	}
	log_data("Program version: $version_nu") if $b_log;
	eval $end if $b_log;
	return $version_nu;
}
# print program_version('bash', 'bash', 4) . "\n";

# arg: 1 - full file path, returns array of file lines.
# 2 - optionsl, strip and clean data
# note: chomp has to chomp the entire action, not just <$fh>
sub reader {
	eval $start if $b_log;
	my ($file,$strip) = @_;
	open( my $fh, '<', $file ) or error_handler('open', $file, $!);
	chomp(my @rows = <$fh>);
	if ($strip && @rows){
		@rows = grep {/^\s*[^#]/} @rows;
		@rows = map {s/^\s+|\s+$//g; $_} @rows if @rows;
	}
	eval $end if $b_log;
	return @rows;
}
# args: 1 - the file to create if not exists
sub toucher {
	my $file = shift;
	if ( ! -e $file ){
		open( my $fh, '>', $file ) or error_handler('create', $file, $!);
	}
}

# calling it trimmer to avoid conflicts with existing trim stuff
# arg: 1 - string to be right left trimmed. Also slices off \n so no chomp needed
# this thing is super fast, no need to log its times etc, 0.0001 seconds or less
sub trimmer {
	#eval $start if $b_log;
	my ($str) = @_;
	$str =~ s/^\s+|\s+$|\n$//g; 
	#eval $end if $b_log;
	return $str;
}
sub uniq {
	my %seen;
	grep !$seen{$_}++, @_;
}
# arg: 1 file full  path to write to; 2 - arrayof data to write. 
# note: turning off strict refs so we can pass it a scalar or an array reference.
sub writer {
	my ($path, $ref_content) = @_;
	my ($content);
	no strict 'refs';
	# print Dumper $ref_content, "\n";
	if (ref $ref_content eq 'ARRAY'){
		$content = join "\n", @$ref_content or die "failed with error $!";
	}
	else {
		$content = scalar $ref_content;
	}
	open(my $fh, '>', $path) or error_handler('open',"$path", "$!");
	print $fh $content;
	close $fh;
}

#### -------------------------------------------------------------------
#### UPDATER
##### -------------------------------------------------------------------

# args: 1 - download url, not including file name; 2 - string to print out
# 3 - update type option
# note that 1 must end in / to properly construct the url path
sub update_me {
	eval $start if $b_log;
	my ( $self_download, $download_id ) = @_;
	my $downloader_error=1;
	my $file_contents='';
	my $output = '';
	my $b_man = 0;
	$self_path =~ s/\/$//; # dirname sometimes ends with /, sometimes not
	$self_download =~ s/\/$//; # dirname sometimes ends with /, sometimes not
	my $full_self_path = "$self_path/$self_name";
	
	if ( $b_irc ){
		error_handler('not-in-irc', "-U/--update" )
	}
	if ( ! -w $full_self_path ){
		error_handler('not-writable', "$self_name", '');
	}
	$output = "${output}Starting $self_name self updater.\n";
	$output = "${output}Using $dl{'dl'} as downloader.\n";
	$output = "${output}Currently running $self_name version number: $self_version\n";
	$output = "${output}Current version patch number: $self_patch\n";
	$output = "${output}Current version release date: $self_date\n";
	$output = "${output}Updating $self_name in $self_path using $download_id as download source...\n";
	print $output;
	$output = '';
	$self_download = "$self_download/$self_name";
	$file_contents=download_file('stdout', $self_download);
	
	# then do the actual download
	if (  $file_contents ){
		# make sure the whole file got downloaded and is in the variable
		if ( $file_contents =~ /###\*\*EOF\*\*###/ ){
			open(my $fh, '>', $full_self_path);
			print $fh $file_contents or error_handler('write', "$full_self_path", "$!" );
			close $fh;
			qx( chmod +x '$self_path/$self_name' );
			set_version_data();
			$output = "${output}Successfully updated to $download_id version: $self_version\n";
			$output = "${output}New $download_id version patch number: $self_patch\n";
			$output = "${output}New $download_id version release date: $self_date\n";
			$output = "${output}To run the new version, just start $self_name again.\n";
			$output = "${output}$line3\n";
			$output = "${output}Starting download of man page file now.\n";
			print $output;
			$output = '';
			if ($b_man && $download_id eq 'main branch' ){
				update_man();
			}
			else {
				print "Skipping man download because branch version is being used.\n";
			}
			exit 1;
		}
		else {
			error_handler('file-corrupt', "$self_name");
		}
	}
	# now run the error handlers on any downloader failure
	else {
		error_handler('download-error', $self_download, $download_id);
	}
	eval $end if $b_log;
}

sub update_man {
	my $man_file_url=get_defaults('inxi-man'); 
	my $man_file_location=set_man_location();
	my $man_file_path="$man_file_location/$self_name.1.gz" ;
	my $output = '';
	
	my $downloader_man_error=1;
	if ( ! -d $man_file_location ){
		print "The required man directory was not detected on your system.\n";
		print "Unable to continue: $man_file_location\n";
		return 0;
	}
	if ( -w $man_file_location ){
		print "Cannot write to $man_file_location! Are you root?\n";
		print "Unable to continue: $man_file_location\n";
		return 0;
	}
	if ( -f "/usr/share/man/man8/inxi.8.gz" ){
		print "Updating man page location to man1.\n";
		rename "/usr/share/man/man8/inxi.8.gz", "$man_file_location/inxi.1.gz";
		if ( check_program('mandb') ){
			system( 'mandb' );
		}
	}
	if ( $dl{'dl'} =~ /tiny|wget/){
		print "Checking Man page download URL...\n";
		download_file('spider', $man_file_url);
		$downloader_man_error = $?;
	}
	if ( $downloader_man_error == 1 ){
		if ( $dl{'dl'} =~ /tiny|wget/){
			print "Man file download URL verified: $man_file_url\n";
		}
		print "Downloading Man page file now.\n";
		download_file('file', $man_file_url,  $man_file_path );
		$downloader_man_error = $?;
		if ( $downloader_man_error == 0 ){
			print "Oh no! Something went wrong downloading the Man gz file at: $man_file_url\n";
			print "Check the error messages for what happened. Error: $downloader_man_error\n";
		}
		else {
			print "Download/install of man page successful. Check to make sure it works: man inxi\n";
		}
	}
	else {
		print "Man file download URL failed, unable to continue: $man_file_url\n";
	}
}

sub set_man_location {
	my $location='';
	my $default_location='/usr/share/man/man1';
	my $man_paths=qx(man --path 2>/dev/null);
	my $man_local='/usr/local/share/man';
	my $b_use_local=0;
	if ( $man_paths && $man_paths =~ /$man_local/ ){
		$b_use_local=1;
	}
	# for distro installs
	if ( -f "$default_location/inxi.1.gz" ){
		$location=$default_location;
	}
	else {
		if ( $b_use_local ){
			if ( ! -d "$man_local/man1" ){
				mkdir "$man_local/man1";
			}
			$location="$man_local/man1";
		}
	}
	if ( ! $location ){
		$location=$default_location;
	}
	return $location;
}

# update for updater output version info
# note, this is only now used for self updater function so it can get
# the values from the UPDATED file, NOT the running program!
sub set_version_data {
	open (my $fh, '<', "$self_path/$self_name");
	while( my $row = <$fh>){
		chomp $row;
		$row =~ s/'//g;
		if ($row =~ /^my \$self_name/ ){
			$self_name = (split /=/, $row)[1];
		}
		elsif ($row =~ /^my \$self_version/ ){
			$self_version = (split /=/, $row)[1];
		}
		elsif ($row =~ /^my \$self_date/ ){
			$self_date = (split /=/, $row)[1];
		}
		elsif ($row =~ /^my \$self_patch/ ){
			$self_patch = (split /=/, $row)[1];
		}
		elsif ($row =~ /^## END INXI INFO/){
			last;
		}
	}
	close $fh;
}


########################################################################
#### OPTIONS HANDLER
########################################################################

sub get_options{
	eval $start if $b_log;
	my (@args) = @_;
	$show{'short'} = 1;
	my ($b_downloader,$b_recommends,$b_updater,$b_version,$help_type,
	$self_download, $download_id);
	GetOptions (
	'A|audio' => sub {
		$show{'short'} = 0;
		$show{'audio'} = 1;},
	'b|basic' => sub {
		$show{'short'} = 0;
		$show{'battery'} = 1;
		$show{'cpu-basic'} = 1;
		$show{'raid-basic'} = 1;
		$show{'disk-total'} = 1;
		$show{'graphic'} = 1;
		$show{'info'} = 1;
		$show{'machine'} = 1;
		$show{'network'} = 1;
		$show{'system'} = 1;},
	'B|battery' => sub {
		$show{'short'} = 0;
		$show{'battery'} = 1;
		$show{'battery-forced'} = 1; },
	'c|color:i' => sub {
		my ($opt,$arg) = @_;
		if ( $arg >= 0 && $arg <= get_color_scheme('count') ){
			set_color_scheme($arg);
		}
		elsif ( $arg >= 94 && $arg <= 99 ){
			$colors{'selector'} = $arg;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'C|cpu' => sub {
		$show{'short'} = 0;
		$show{'cpu'} = 1; },
	'd|disk-all' => sub {
		$show{'short'} = 0;
		$show{'disk'} = 1;
		$show{'optical-full'} = 1; },
	'D' => sub {
		$show{'short'} = 0;
		$show{'disk'} = 1; },
	'f|flags' => sub {
		$show{'short'} = 0;
		$show{'cpu'} = 1;
		$show{'cpu-flag'} = 1; },
	'F|full' => sub {
		$show{'short'} = 0;
		$show{'audio'} = 1;
		$show{'battery'} = 1;
		$show{'cpu'} = 1;
		$show{'disk'} = 1;
		$show{'graphic'} = 1;
		$show{'info'} = 1;
		$show{'machine'} = 1;
		$show{'network'} = 1;
		$show{'network-advanced'} = 1;
		$show{'partition'} = 1;
		$show{'raid'} = 1;
		$show{'sensor'} = 1;
		$show{'system'} = 1; },
	'G|graphics' => sub {
		$show{'short'} = 0;
		$show{'graphic'} = 1; },
	'i|ip' => sub {
		$show{'short'} = 0;
		$show{'ip'} = 1;
		$show{'network'} = 1;
		$show{'network-advanced'} = 1;
		$b_downloader = 1 if ! check_program('dig');},
	'I|info' => sub {
		$show{'short'} = 0;
		$show{'info'} = 1; },
	'l|label' => sub {
		$show{'short'} = 0;
		$show{'label'} = 1;
		$show{'partition'} = 1; },
	'm|memory' => sub {
		$show{'short'} = 0;
		$show{'memory'} = 1; },
	'M|machine' => sub {
		$show{'short'} = 0;
		$show{'machine'} = 1; },
	'n|network-advanced' => sub {
		$show{'short'} = 0;
		$show{'network'} = 1;
		$show{'network-advanced'} = 1; },
	'N|network' => sub {
		$show{'short'} = 0;
		$show{'network'} = 1; },
	'o|unmounted' => sub {
		$show{'short'} = 0;
		$show{'unmounted'} = 1; },
	'p|partition-full' => sub {
		$show{'short'} = 0;
		$show{'partition'} = 1;
		$show{'partition-full'} = 1; },
	'P|partition' => sub {
		$show{'short'} = 0;
		$show{'partition'} = 1; },
	'r|repos' => sub {
		$show{'short'} = 0;
		$show{'repo'} = 1; },
	'R|raid' => sub {
		$show{'short'} = 0;
		$show{'raid'} = 1;
		$show{'raid-forced'} = 1; },
	's|sensors' => sub {
		$show{'short'} = 0;
		$show{'sensor'} = 1; },
	'S|system' => sub {
		$show{'short'} = 0;
		$show{'system'} = 1; },
	't|processes:s' => sub {
		my ($opt,$arg) = @_;
		$show{'short'} = 0;
		my $num = $arg;
		$num =~ s/^[cm]+// if $num;
		if ( $arg =~ /^([cm]+)([0-9]+)?$/ && (!$num || $num =~ /^\d+/) ){
			$show{'process'} = 1;
			if ($arg =~ /c/){
				$show{'ps-cpu'} = 1;
			}
			if ($arg =~ /m/){
				$show{'ps-mem'} = 1;
			}
			$ps_count = $num if $num;
		}
		else {
			error_handler('bad-arg',$opt,$arg);
		} },
	'u|uuid' => sub {
		$show{'short'} = 0;
		$show{'partition'} = 1;
		$show{'uuid'} = 1; },
	'v|verbosity:i' => sub {
		my ($opt,$arg) = @_;
		$show{'short'} = 0;
		if ( $arg =~ /^[0-7]$/ ){
			if ($arg == 0 ){
				$show{'short'} = 1;
			}
			if ($arg >= 1 ){
				$show{'cpu-basic'} = 1;
				$show{'disk-total'} = 1;
				$show{'graphic'} = 1;
				$show{'info'} = 1;
				$show{'system'} = 1;
			}
			if ($arg >= 2 ){
				$show{'battery'} = 1;
				$show{'disk-basic'} = 1;
				$show{'raid-basic'} = 1;
				$show{'machine'} = 1;
				$show{'network'} = 1;
			}
			if ($arg >= 3 ){
				$show{'network-advanced'} = 1;
				$show{'cpu'} = 1;
				$extra = 1;
			}
			if ($arg >= 4 ){
				$show{'disk'} = 1;
				$show{'partition'} = 1;
			}
			if ($arg >= 5 ){
				$show{'audio'} = 1;
				$show{'memory'} = 1;
				$show{'label'} = 1;
				$show{'memory'} = 1;
				$show{'raid'} = 1;
				$show{'sensor'} = 1;
				$show{'uuid'} = 1;
			}
			if ($arg >= 6 ){
				$show{'optical-full'} = 1;
				$show{'partition-full'} = 1;
				$show{'unmounted'} = 1;
				$extra = 2;
			}
			if ($arg >= 7 ){
				$b_downloader = 1 if ! check_program('dig');
				$show{'ip'} = 1;
				$show{'raid-forced'} = 1;
				$extra = 3;
			}
		}
		else {
			error_handler('bad-arg',$opt,$arg);
		} },
	'w|weather' => sub {
		my ($opt) = @_;
		$show{'short'} = 0;
		$b_downloader = 1;
		if ( $b_weather ){
			$show{'weather'} = 1;
		}
		else {
			error_handler('distro-block', $opt);
		} },
	'W|weather-location:s' => sub {
		my ($opt,$arg) = @_;
		$arg ||= '';
		$show{'short'} = 0;
		$b_downloader = 1;
		if ( $b_weather ){
			if ( $arg){
				$show{'weather'} = 1;
				$show{'weather-location'} = 1;
			}
			else {
				error_handler('bad-arg',$opt,$arg);
			}
		}
		else {
			error_handler('distro-block', $opt);
		} },
	'x|extra:i' => sub {
		my ($opt,$arg) = @_;
		if ($arg > 0){
			$extra = $arg;
		}
		else {
			$extra++;
		} },
	'y|width:i' => sub {
		my ($opt, $arg) = @_;
		if ( $arg =~ /\d/ && $arg >= 80 ){
			set_display_width($arg);
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'z|filter' => sub {
		$show{'filter'} = 1; },
	'Z|filter-override' => sub {
		$show{'filter-override'} = 1; },
	
	## Start non data options
	'alt:i' => sub { 
		my ($opt,$arg) = @_;
		if ($arg == 1) {$test[1] = 1}
		elsif ($arg == 2) {$test[2] = 1}
		elsif ($arg == 3) {$test[3] = 1}
		elsif ($arg == 4) {$test[4] = 1}
		elsif ($arg == 5) {$test[5] = 1}
		elsif ($arg == 30) {$b_irc = 0}
		elsif ($arg == 31) {$show{'host'} = 0}
		elsif ($arg == 32) {$show{'host'} = 1}
		elsif ($arg == 33) {$use{'dmidecode-force'}=1}
		elsif ($arg == 34) {$dl{'no-ssl-opt'}=1}
		elsif ($arg == 40) {
			$dl{'tiny'} = 0;
			$b_downloader = 1;}
		elsif ($arg == 41) {
			$dl{'curl'} = 0;
			$b_downloader = 1;}
		elsif ($arg == 42) {
			$dl{'fetch'} = 0;
			$b_downloader = 1;}
		elsif ($arg == 43) {
			$dl{'wget'} = 0;
			$b_downloader = 1;}
		elsif ($arg == 44) {
			$dl{'curl'} = 0;
			$dl{'fetch'} = 0;
			$dl{'wget'} = 0;
			$b_downloader = 1;}
		else {
			error_handler('bad-arg', $opt, $arg);
		}},
	'debug:i' => sub { 
		my ($opt,$arg) = @_;
		if ($arg =~ /^[1-3]|[1-2][0-2]$/){
			$debug=$arg;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'display:s' => sub { 
		my ($opt,$arg) = @_;
		if ($arg =~ /^:?([0-9]+)?$/){
			$display=$arg;
			$display ||= ':0';
			$display = ":$display" if $display !~ /^:/;
			$b_display = 1;
			$show{'display-data'} = 2;
			$display_opt = "-display $display";
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'downloader:s' => sub { 
		my ($opt,$arg) = @_;
		$arg = lc($arg);
		if ($arg =~ /^(curl|fetch|ftp|perl|wget)$/){
			# this dumps all the other data and resets %dl for only the
			# desired downloader.
			$arg = set_perl_downloader($arg);
			%dl = ('dl' => $arg, $arg => 1);
			$b_downloader = 1;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'ftp:s'  => sub { 
		my ($opt,$arg) = @_;
		# pattern: ftp.x.x/x
		if ($arg =~ /^ftp\..+\..+\/[^\/]+$/ ){
			$ftp_alt = $arg;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		}},
	'h|help|?' => sub {
		$help_type = 'standard'; },
	'H|help-full' => sub {
		$help_type = 'full'; },
	'output:s' => sub {
		my ($opt,$arg) = @_;
		if ($arg =~ /^csv|json|screen|xml$/){
			$output_type = $arg;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		}},
	'recommends' => sub {
		$b_recommends = 1; },
	'U|update:s' => sub { # 1,2,3 OR http://myserver/path/inxi
		my ($opt,$arg) = @_;
		$b_downloader = 1;
		if ( $b_update ){
			$b_updater = 1;
			if ( $arg =~ /^\d$/){
				$download_id = "branch $arg";
				$self_download = get_defaults("inxi-branch-$arg");
			}
			elsif ( $arg =~ /^http/){
				$download_id = 'alt server';
				$self_download = $arg;
			}
			else {
				$download_id = 'pinxi branch';
				$self_download = get_defaults('inxi-pinxi');
			}
# 			else {
# 				$download_id = 'main branch';
# 				$self_download = get_defaults('inxi-main');
# 			}
			if (!$self_download){
				error_handler('bad-arg', $opt, $arg);
			}
		}
		else {
			error_handler('distro-block', $opt);
		} },
	'V|version' => sub { 
		$b_version = 1 },
	'<>' => sub {
		my ($opt) = @_;
		error_handler('unknown-option', "$opt", "" ); }
	) ; #or error_handler('unknown-option', "@ARGV", '');
	## run all these after so that we can change widths, downloaders, etc
	eval $end if $b_log;
	CheckRecommends::run() if $b_recommends;
	set_downloader() if $b_downloader;
	show_version() if $b_version;
	show_options($help_type) if $help_type;
	update_me( $self_download, $download_id ) if $b_updater;
} 

sub show_options {
	error_handler('not-in-irc', 'help') if $b_irc;
	my ($type) = @_;
	my (@row,@rows,@data);
	my $line = '';
	my $color_scheme_count=12; # $(( ${#A_COLOR_SCHEMES[@]} - 1 ));
	my $partition_string='partition';
	my $partition_string_u='Partition';
	if ( $bsd_type ){
		$partition_string='slice';
		$partition_string_u='Slice';
	}
	# fit the line to the screen!
	for my $i ( 0 .. ( ( $size{'max'} / 2 ) - 2 ) ){
		$line = $line . '- ';
	}
	@rows = (
	['0', '', '', "$self_name supports the following options. You can combine 
	them, or list them one by one. Examples: $self_name^-v4^-c6 OR 
	$self_name^-bDc^6. If you start $self_name with no arguments, it will show 
	the short form." ],
	[0, '', '', '' ],
	['0', '', '', "The following options if used without -F, -b, or -v will show 
	just option line(s): A, B, C, D, G, I, M, N, P, R, S, f, i, m, n, o, p, l, 
	u, r, s, t - you can use these alone or together to show just the line(s) 
	you want to see. If you use them with -v^[level], -b or -F, it will show the 
	full output for that line along with the output for the chosen verbosity level." ],
	['0', '', '', $line ],
	['0', '', '', "Output Control Options:" ],
	['1', '-A', '--audio', "Audio/sound card information." ],
	['1', '-b', '--basic', "Basic output, short form. Like $self_name^-v^2, only minus hard 
	disk names." ],
	['1', '-B', '--battery', "Battery info, shows charge, condition, plus extra information 
	(if battery present)." ],
	['1', '-c', '--color', "Color schemes. Scheme number is required. Color selectors run a 
	color selector option prior to $self_name starting which lets you set the 
	config file value for the selection." ],
	['1', '', '', "Supported color schemes: 0-$color_scheme_count 
	Example:^$self_name^-c^11" ],
	['1', '', '', "Color selectors for each type display (NOTE: irc and global only 
	show safe color set):" ],
	['2', '94', '', "Console, out of X" ],
	['2', '95', '', "Terminal, running in X - like xTerm" ],
	['2', '96', '', "Gui IRC, running in X - like Xchat, Quassel, Konversation etc." ],
	['2', '97', '', "Console IRC running in X - like irssi in xTerm" ],
	['2', '98', '', "Console IRC not in  X" ],
	['2', '99', '', "Global - Overrides/removes all settings. Setting specific 
	removes global." ],
	['1', '-C', '--cpu', "CPU output, including per CPU clockspeed and max CPU speed 
	(if available)." ],
	['1', '-d', '--optical', "Optical drive data (and floppy disks, if present). Same as -Dd. 
	See also -x and -xx." ],
	['1', '-D', '--disk', "Full hard Disk info, not only model, ie: /dev/sda ST380817AS 
	80.0GB. See also -x and -xx. Disk total used percentage includes swap 
	partition size(s)." ],
	['1', '-f', '--flags', "All cpu flags, triggers -C. Not shown with -F to avoid spamming. 
	ARM cpus show 'features'." ],
	['1', '-F', '--full', "Full output for $self_name. Includes all Upper Case line letters, 
	plus -s and -n. Does not show extra verbose options like 
	-d -f -l -m -o -p -r -t -u -x" ],
	['1', '-G', '--graphics', "Graphic card information (card, display server type/version, 
	resolution, renderer, OpenGL version)." ],
	['1', '-i', '--ip', "Wan IP address, and shows local interfaces (requires ifconfig 
	network tool). Same as -Nni. Not shown with -F for user security reasons, 
	you shouldn't paste your local/wan IP." ],
	['1', '-I', '--info', "Information: processes, uptime, memory, irc client (or shell type),
	$self_name version." ],
	['1', '-l', '--label', "$partition_string_u labels. Default: short $partition_string -P. 
	For full -p output, use: -pl (or -plu)." ],
	['1', '-m', '--memory', "Memory (RAM) data. Physical system memory array(s), capacity, 
	how many devices (slots) supported, and individual memory devices 
	(sticks of memory etc). For devices, shows device locator, size, speed, 
	type (like: DDR3). If neither -I nor -tm are selected, also shows 
	ram used/total. Also see -x, -xx, -xxx" ],
	['1', '-M', '--machine', "Machine data. Device type (desktop, server, laptop, VM etc.), 
	Motherboard, Bios, and if present, System Builder (Like Lenovo). 
	Shows UEFI/BIOS/UEFI [Legacy]. Older systems/kernels without the 
	required /sys data can use dmidecode instead, run as root. 
	Dmidecode can be forced with -! 33" ],
	['1', '-n', '--network-advanced', "Advanced Network card information. Same as -Nn. Shows interface, 
	speed, mac id, state, etc." ],
	['1', '-N', '--network', "Network card information. With -x, shows PCI BusID, Port number." ],
	['1', '-o', '--unmounted', "Unmounted $partition_string information (includes UUID and 
	LABEL if available). Shows file system type if you have file installed, 
	if you are root OR if you have added to /etc/sudoers (sudo v. 1.7 or 
	newer) Example:^<username>^ALL^=^NOPASSWD:^/usr/bin/file^" ],
	['1', '-p', '--partitions-full', "Full $partition_string information (-P plus all other 
	detected ${partition_string}s)." ],
	['1', '-P', '--partitions', "Basic $partition_string information (shows what -v^4 would 
	show, but without extra data). Shows, if detected: 
	/ /boot /home /opt /tmp /usr /var /var/log /var/tmp . 
	Use -p to see all mounted ${partition_string}s." ],
	['1', '-r', '--repos', "Distro repository data. Supported repo types: APK; APT; PACMAN; 
	PISI; PORTAGE; PORTS (BSDs); SLACKPKG; URPMQ; YUM; ZYPP." ],
	['1', '-R', '--raid', "RAID data. Shows RAID devices, states, levels, and components, 
	and extra data with -x/-xx. md-raid: If device is resyncing, shows resync 
	progress line as well." ],
	['1', '-s', '--sensors', "Sensors output (if sensors installed/configured): mobo/cpu/gpu temp; 
	detected fan speeds. Gpu temp only for Fglrx/Nvidia drivers. Nvidia shows 
	screen number for > 1 screens." ],
	['1', '-S', '--system', "System information: host name, kernel, desktop environment 
	(if in X), distro" ],
	['1', '-t', '--processes', "Processes. Requires extra options: c^(cpu) m^(memory) cm^(cpu+memory). 
	If followed by numbers 1-X, shows that number of processes for each type 
	(default:^$ps_count; if in irc, max:^5): -t^cm10" ],
	['1', '', '', "Make sure to have no space between letters and numbers 
	(-t^cm10 - right, -t^cm^10 - wrong)." ],
	['1', '-u', '--uuid', "$partition_string_u UUIDs. Default: short $partition_string -P. 
	For full -p output, use: -pu (or -plu)." ],
	['1', '-v', '--verbosity', "Script verbosity levels. Verbosity level number is required. 
	Should not be used with -b or -F" ],
	['1', '', '', "Supported levels: 0-7 Example: $self_name^-v^4" ],
	['2', '0', '', "Short output, same as: $self_name" ],
	['2', '1', '', "Basic verbose, -S + basic CPU + -G + basic Disk + -I." ],
	['2', '2', '', "Networking card (-N), Machine (-M) data, if present, Battery (-B), 
	basic hard disk data (names only), and, if present, basic raid (devices only, 
	and if inactive, notes that). similar to: $self_name^-b" ],
	['2', '3', '', "Advanced CPU (-C), battery, network (-n) data, and switches on 
	-x advanced data option." ],
	['2', '4', '', "$partition_string_u size/filled data (-P) for (if present): /, 
	/home, /var/, /boot. Shows full disk data (-D)." ],
	['2', '5', '', "Audio card (-A); sensors^(-s), memory/ram^(-m), 
	$partition_string label^(-l) and UUID^(-u), short form of optical drives, 
	standard raid data (-R)." ],
	['2', '6', '', "Full $partition_string (-p), unmounted $partition_string (-o), 
	optical drive (-d), full raid; triggers -xx." ],
	['2', '7', '', "Network IP data (-i); triggers -xxx."]
	);
	push @data, @rows;
	# if distro maintainers don't want the weather feature disable it
	if ( $b_weather ){
		@rows = (
		['1', '-w', '--weather', "Local weather data/time. To check an alternate location, 
		see: -W^<location>. For extra weather data options see -x, -xx, and -xxx."],
		['1', '-W', '--weather-location', "<location> Supported options for <location>: postal code; 
		city, state/country; latitude, longitude. Only use if you want the weather 
		somewhere other than the machine running $self_name. Use only ascii 
		characters, replace spaces in city/state/country names with '+'. 
		Example:^$self_name^-W^new+york,ny"]
		);
		push @data, @rows;
	}
	@rows = (
	['1', '-x', '-extra', "Adds the following extra data (only works with verbose or line 
	output, not short form):" ],
	['2', '-B', '', "Vendor/model, status (if available)" ],
	['2', '-C', '', "CPU Flags, Bogomips on Cpu;CPU microarchitecture / revision if 
	found, like: (Sandy Bridge rev.2)" ],
	['2', '-d', '', "Extra optical drive data; adds rev version to optical drive." ],
	['2', '-D', '', "Hdd temp with disk data if you have hddtemp installed, if you are 
	root OR if you have added to /etc/sudoers (sudo v. 1.7 or newer) 
	Example:^<username>^ALL^=^NOPASSWD:^/usr/sbin/hddtemp" ],
	['2', '-G', '', "Direct rendering status for Graphics (in X)." ],
	['2', '-G', '', "(for single gpu, nvidia driver) screen number gpu is running on." ],
	['2', '-i', '', "For IPv6, show additional IP v6 scope addresses: Global, Site, 
	Temporary, Unknown." ],
	['2', '-I', '', "System GCC, default. With -xx, also show other installed 
	GCC versions. If running in console, not in IRC client, shows shell 
	version number, if detected. Init/RC Type and runlevel (if available)." ],
	['2', '-m', '', "Part number; Max memory module size (if available)." ],
	['2', '-N -A', '', "Version/port(s)/driver version (if available) for Network/Audio;" ],
	['2', '-N -A -G', '', "Network, audio, graphics, shows PCI Bus ID/Usb ID 
	number of card." ],
	['2', '-R', '', "md-raid: Shows component raid id. Adds second RAID Info line: 
	raid level; report on drives (like 5/5); blocks; chunk size; bitmap (if present). 
	Resync line, shows blocks synced/total blocks. zfs-raid:	Shows raid array 
	full size; available size; portion allocated to RAID" ],
	['2', '-S', '', "Desktop toolkit if available (GNOME/XFCE/KDE only); Kernel 
	gcc version" ],
	['2', '-t', '', "Memory use output to cpu (-xt c), and cpu use to memory (-xt m)." ]
	);
	push @data, @rows;
	if ( $b_weather eq 1 ){
		@rows = (['2', '-w -W', '', "Wind speed and time zone (-w only)." ]);
		push @data, @rows;
	}
	@rows = (
	['1', '-xx', '--extra 2', "Show extra, extra data (only works with verbose or line output, 
	not short form):" ],
	['2', '-A', '', "Chip vendor:product ID for each audio device." ],
	['2', '-B', '', "serial number, voltage (if available)." ],
	['2', '-C', '', "Minimum CPU speed, if available." ],
	['2', '-D', '', "Disk serial number; Firmware rev. if available." ],
	['2', '-G', '', "Chip vendor:product ID for each video card; (mir/wayland only) 
	compositor (alpha test); OpenGL compatibility version, if free drivers and 
	available." ],
	['2', '-I', '', "Other detected installed gcc versions (if present). System 
	default runlevel. Adds parent program (or tty) for shell info if not in IRC
	(like Konsole or Gterm). Adds Init/RC (if found) version number." ],
	['2', '-m', '', "Manufacturer, Serial Number, single/double bank (if found)." ],
	['2', '-M', '', "Chassis information, bios rom size (dmidecode only), if data for 
	either is available." ],
	['2', '-N', '', "Chip vendor:product ID for each nic." ],
	['2', '-R', '', "md-raid: Superblock (if present); algorythm, U data. Adds 
	system info line (kernel support,read ahead, raid events). If present, 
	adds unused device line. Resync line, shows progress bar." ],
	['2', '-S', '', "Display manager (dm) in desktop output, if in X 
	(like kdm, gdm3, lightdm)." ],
	);
	push @data, @rows;
	if ( $b_weather ){
		@rows = (['2', '-w -W', '', "Humidity, barometric pressure." ]);
		push @data, @rows;
	}
	@rows = (
	['1', '-xxx', '--extra 3', "Show extra, extra, extra data (only works with verbose or 
	line output, not short form):" ],
	['2', '-B', '', "chemistry, cycles, location (if available)." ],
	['2', '-m', '', "Width of memory bus, data and total (if present and greater 
	than data); Detail, if present, for Type; module voltage, if available." ],
	['2', '-S', '', "Panel/shell information in desktop output, if in X 
	(like gnome-shell, cinnamon, mate-panel); if available, dm version number." ]
	);
	push @data, @rows;
	if ( $b_weather ){
		@rows = (['2', '-w -W', '', "Location (uses -z/irc filter), weather 
		observation time, wind chill, heat index, dew point (shows extra lines 
		for data where relevant)." ] );
		push @data, @rows;
	}
	@rows = (
	['1', '-y', '--width', "Required extra option: integer, 80 or greater. Set the output 
	line width max. Overrides IRC/Terminal settings or actual widths. Example:^inxi^-y^130" ],
	['1', '-z', '--filter', "Security filters for IP/Mac addresses, location, user home 
	directory name. Default on for irc clients." ],
	['1', '-Z', '--filter-override', "Absolute override for output filters. Useful for debugging 
	networking issues in irc for example." ],
	[0, '', '', "$line" ],
	[0, '', '', "Additional Options:" ],
	['1', '-h', '--help', "This help menu." ],
	['1', '-H', '--help-full', "This help menu, plus developer options. Do not use dev options in 
	normal operation!" ],
	['1', '', '--recommends', "Checks $self_name application dependencies + recommends, 
	and directories, then shows what package(s) you need to install to add support 
	for that feature. " ]
	);
	push @data, @rows;
	if ( $b_update ){
		@rows = (
		['1', '-U', '--update', "Auto-update script. Will also install/update man page. 
		Note: if you installed as root, you must be root to update, otherwise user 
		is fine. Man page installs require root user mode. No arguments downloads from main 
		$self_name git repo." ],
		['1', '', '', "Use alternate sources for updating $self_name" ],
		
		['2', '1', '', "Get the git branch one version." ],
		['2', '2', '', "Get the git branch two version." ],
		['2', '<http>', '', "Get a version of $self_name from your own server if you want, 
		put the full download path, like: $self_name -U https://myserver.com/inxi" ]
		);
		push @data, @rows;
		
	}
	@rows = (
	['1', '-V', '--version', "$self_name version information. Prints information 
	then exits." ],
	[0, '', '', "$line" ],
	[0, '', '', "Debugging Options:" ],
	
	['1', '', '--debug', "Triggers debugging modes." ],
	['2', '1-3', '', "On screen $self_name debugger output" ],
	['2', '10', '', "Basic $self_name logging." ],
	['2', '11', '', "Full file/system info logging" ],
	['2', '12', '', "Plus Color logging." ],
	['1', '', ,'', "The following create a tar.gz file of system data, plus collecting 
	the inxi output to file. To automatically upload debugger data tar.gz file 
	to ftp.techpatterns.com: inxi^--debug^21" ],
	['2', '20', '', "Full system data collection: /sys; xorg conf and 
	log data, xrandr, xprop, xdpyinfo, glxinfo etc.; data from dev, disks, 
	${partition_string}s, etc." ],
	['2', '21', '', "Upload debugger dataset to $self_name debugger server 
	automatically." ],
	['1', '', '--ftp', "Use with --debugger 21 to trigger an alternate FTP server for upload. 
	Format:^[ftp.xx.xx/yy]. Must include a remote directory to upload to: 
	Example:^ftp.myserver.com/incoming" ],
	[0, '', '', "$line" ],
	[0, '', '', "Advanced Options:" ],
	[1, '', '--alt', "Trigger for various advanced options:" ],
	['2', '0', '', "Overrides defective or corrupted data." ],
	['2', '31', '', "Turns off hostname in output. Useful if showing output from 
	servers etc." ],
	['2', '32', '', "Turns on hostname in output. Overrides global \$b_host'" ],
	['2', '33', '', "Forces use of dmidecode data instead of /sys where 
	relevant (-M)." ],
	['2', '34', '', "Skips SSL certificate checks for all downloader activies 
	(wget/fetch/curl only). Must go before other options." ],
	['2', '40', '', "Bypass Perl as a downloader option." ],
	['2', '41', '', "Bypass Curl as a downloader option." ],
	['2', '42', '', "Bypass Fetch as a downloader option." ],
	['2', '43', '', "Bypass Wget as a downloader option." ],
	['2', '44', '', "Bypass Curl, Fetch, and Wget as a downloader options. Forces 
	Perl if HTTP::Tiny present." ],
	['1', '', '--display', "Will try to get display data out of X. Default gets it from display 0. 
	If you use this format: ---display 1 it would get it from display 1 instead, or any 
	display you specify" ],
	['1', '', '--downloader', "Force $self_name to use [curl|fetch|perl|wget] for downloads." ],
	['1', '', '--ftp', "Use alternate FTP server for --debug 20-22. Must be in format: ftp.site.com/incoming" ],
	['1', '', '--output', "Change data output type. Options: [csv|json|screen|xml]" ],
	['0', '', '', $line ],
	);
	push @data, @rows;
	if ( $type eq 'full' ){
		@rows = (
		[0, '', '', "Developer and Testing Options (Advanced):" ],
		['1', '', '--alt', "Trigger for dev/test options:" ],
		['2', '1', '', "Sets testing flag test1=1 to trigger 
		testing condition 1." ],
		['2', '2', '', "Sets testing flag test2=1 to trigger 
		testing condition 2." ],
		['2', '3', '', "Sets flags test3=1." ],
		['0', '', '', $line ]
		);
		push @data, @rows;
	}
	print_basic(@data); 
	exit 1;
}

########################################################################
#### STARTUP DATA
########################################################################

# StartClient
{
package StartClient;

# use warnings;
# use strict;

my $ppid = '';
my $pppid = '';

# NOTE: there's no reason to crete an object, we can just access
# the features statically. 
# args: none
# sub new {
# 	my $class = shift;
# 	my $self = {};
# 	# print "$f\n";
# 	# print "$type\n";
# 	return bless $self, $class;
# }

sub get_client_data {
	eval $start if $b_log;
	$ppid = getppid();
	main::set_ps_aux() if ! @ps_aux;
	if (!$b_irc){
		main::get_shell_data($ppid);
	}
	else {
		$show{'filter-output'} = (!$show{'filter-override'}) ? 1 : 0;
		get_client_name();
		if ($client{'konvi'} == 1 || $client{'konvi'} == 3){
			set_konvi_data();
		}
	}
	eval $end if $b_log;
}

sub get_client_name {
	eval $start if $b_log;
	my $client_name = '';
	
	# print "$ppid\n";
	if ($ppid && -e "/proc/$ppid/exe" ){
		$client_name = lc(readlink "/proc/$ppid/exe");
		$client_name =~ s/^.*\///;
		if ($client_name =~ /^bash|dash|sh|python.*|perl.*$/){
			$pppid = (main::grabber("ps -p $ppid -o ppid"))[1];
			#my @temp = (main::grabber("ps -p $ppid -o ppid 2>/dev/null"))[1];
			$pppid =~ s/^\s+|\s+$//g;
			$client_name =~ s/[0-9\.]+$//; # clean things like python2.7
			if ($pppid && -f "/proc/$pppid/exe" ){
				$client_name = lc(readlink "/proc/$pppid/exe");
				$client_name =~ s/^.*\///;
				$client{'native'} = 0;
			}
		}
		$client{'name'} = $client_name;
		get_client_version();
		# print "c:$client_name p:$pppid\n";
	}
	else {
		if (! check_modern_konvi() ){
			$ppid = getppid();
			$client_name = (main::grabber("ps -p $ppid"))[1];
			
			my @data = split /\s+/, $client_name;
			if ($bsd_type){
				$client_name = lc($data[5]);
			}
			# gnu/linux uses last value
			else {
				$client_name = lc($data[scalar @data - 1]);
			}
			$client_name =~ s/.*\|-(|)//;
			$client_name =~ s/[0-9\.]+$//; # clean things like python2.7
			if ($client_name){
				$client{'name'} = $client_name;
				$client{'native'} = 1;
				get_client_version();
			}
			else {
				$client{'name'} = "PPID='$ppid' - Empty?";
			}
		}
	}
	main::log_data("Client: $client{'name'} :: version: $client{'version'} :: konvi: $client{'konvi'} :: PPID: $ppid") if $b_log;
	eval $end if $b_log;
}
sub get_client_version {
	eval $start if $b_log;
	@app = main::program_values($client{'name'});
	my (@data,@working,$string);
	if (@app){
		$string = ($client{'name'} =~ /^gribble|limnoria|supybot$/) ? 'supybot' : $client{'name'};
		$client{'version'} = main::program_version($string,$app[0],$app[1],$app[2]);
		$client{'name-print'} = $app[3];
		$client{'console-irc'} = $app[4];
	}
	if ($client{'name'} =~ /^bash|dash|sh$/ ){
		$client{'name-print'} = 'shell wrapper';
		$client{'console-irc'} = 1;
	}
	elsif ($client{'name'} eq 'bitchx') {
		@data = main::grabber("$client{'name'} -v");
		$string = awk(\@data,'Version');
		if ($string){
			$string =~ s/[()]|bitchx-//g; 
			@data = split /\s+/, $string;
			$_=lc for @data;
			$client{'version'} = ($data[1] eq 'version') ? $data[2] : $data[1];
		}
	}
	# 'hexchat' => ['',0,'','HexChat',0,0], # special
	# the hexchat author decided to make --version/-v return a gtk dialogue box, lol...
	# so we need to read the actual config file for hexchat. Note that older hexchats
	# used xchat config file, so test first for default, then legacy. Because it's possible
	# for this file to be user edited, doing some extra checks here.
	elsif ($client{'name'} eq 'hexchat') {
		if ( -f '~/.config/hexchat/hexchat.conf' ){
			@data = main::reader('~/.config/hexchat/hexchat.conf','strip');
		}
		elsif ( -f '~/.config/hexchat/xchat.conf' ){
			@data = main::reader('~/.config/hexchat/xchat.conf','strip');
		}
		$client{'version'} = main::awk(\@data,'version',2,'\s*=\s*');
		$client{'name-print'} = 'HexChat';
	}
	# note: see legacy inxi konvi logic if we need to restore any of the legacy code.
	elsif ($client{'name'} eq 'konversation') {
		$client{'konvi'} = ( ! $client{'native'} ) ? 2 : 1;
	}
	elsif ($client{'name'} =~ /quassel/) {
		@data = main::grabber("$client{'name'} -v 2>/dev/null");
		foreach (@data){
			if ($_ =~ /^Quassel IRC:/){
				$client{'version'} = (split /\s+/, $_ )[2];
				last;
			}
			elsif ($_ =~ /quassel\s[v]?[0-9]/){
				$client{'version'} = (split /\s+/, $_ )[1];
				last;
			}
		}
		$client{'version'} ||= '(pre v0.4.1)?'; 
	}
	# then do some perl type searches, do this last since it's a wildcard search
	elsif ($client{'name'} =~ /^perl.*|ksirc|dsirc$/ ) {
		my @cmdline = main::get_cmdline();
		# Dynamic runpath detection is too complex with KSirc, because KSirc is started from
		# kdeinit. /proc/<pid of the grandparent of this process>/exe is a link to /usr/bin/kdeinit
		# with one parameter which contains parameters separated by spaces(??), first param being KSirc.
		# Then, KSirc runs dsirc as the perl irc script and wraps around it. When /exec is executed,
		# dsirc is the program that runs inxi, therefore that is the parent process that we see.
		# You can imagine how hosed I am if I try to make inxi find out dynamically with which path
		# KSirc was run by browsing up the process tree in /proc. That alone is straightjacket material.
		# (KSirc sucks anyway ;)
		foreach (@cmdline){
			if ( $_ =~ /dsirc/ ){
				$client{'version'} = main::program_version('ksirc','KSirc:',2,'-v',0);
				$client{'name'} = 'ksirc';
				$client{'name-print'} = 'KSirc';
			}
		}
		$client{'console-irc'} = 1;
		perl_python_client();
	}
	elsif ($client{'name'} =~ /python/) {
		perl_python_client();
	}
	if (!$client{'name-print'}) {
		$client{'name-print'} = 'Unknown Client: ' . $client{'name'};
	}
	eval $end if $b_log;
}
sub get_cmdline {
	eval $start if $b_log;
	my @cmdline;
	my $i = 0;
	$ppid = getppid();
	if (! -e "/proc/$ppid/cmdline" ){
		return 1;
	}
	local $\ = '';
	open( my $fh, '<', "/proc/$ppid/cmdline" ) or 
	  print_line("Open /proc/$ppid/cmdline failed: $!");
	my @rows = <$fh>;
	close $fh;
	
	foreach (@rows){
		push @cmdline, $_;
		$i++;
		last if $i > 31;
	}
	if ( $i == 0 ){
		$cmdline[0] = $rows[0];
		$i = ($cmdline[0]) ? 1 : 0;
	}
	main::log_data("cmdline: @cmdline count: $i") if $b_log;
	eval $end if $b_log;
	return @cmdline;
}
sub perl_python_client {
	eval $start if $b_log;
	return 1 if $client{'version'};
	# this is a hack to try to show konversation if inxi is running but started via /cmd
	# OR via script shortcuts, both cases in fact now
	# main::print_line("konvi: " . scalar grep { $_ =~ /konversation/ } @ps_cmd);
	if ( $b_display && ( scalar grep { $_ =~ /konversation/ } @ps_cmd ) > 0){
		@app = main::program_values('konversation');
		$client{'version'} = main::program_version('konversation',$app[0],$app[1],$app[2]);
		$client{'name'} = 'konversation';
		$client{'name-print'} = $app[3];
		$client{'console-irc'} = $app[4];
	}
	## NOTE: supybot only appears in ps aux using 'SHELL' command; the 'CALL' command
	## gives the user system irc priority, and you don't see supybot listed, so use SHELL
	elsif ( !$b_display && ( scalar grep { $_ =~ /supybot/ } @ps_cmd ) > 0  ){
		@app = main::program_values('supybot');
		$client{'version'} = main::program_version('supybot',$app[0],$app[1],$app[2]);
		if ($client{'version'}){
			if ( ( scalar grep { $_ =~ /gribble/ } @ps_cmd ) > 0){
				$client{'name'} = 'gribble';
				$client{'name-print'} = 'Gribble';
			}
			if ( ( scalar grep { $_ =~ /limnoria/ } @ps_cmd ) > 0){
				$client{'name'} = 'limnoria';
				$client{'name-print'} = 'Limnoria';
			}
			else {
				$client{'name'} = 'supybot';
				$client{'name-print'} = 'Supybot';
			}
		}
		else {
			$client{'name'} = 'supybot';
			$client{'name-print'} = 'Supybot';
		}
		$client{'console-irc'} = 1;
	}
	else {
		$client{'name-print'} = "Unknown $client{'name'} client";
	}
	main::log_data("namep: $client{'name-print'} name: $client{'name'} version: $client{'version'}") if $b_log;
	eval $end if $b_log;
}
## try to infer the use of Konversation >= 1.2, which shows $PPID improperly
## no known method of finding Konvi >= 1.2 as parent process, so we look to see if it is running,
## and all other irc clients are not running. As of 2014-03-25 this isn't used in my cases
sub check_modern_konvi {
	eval $start if $b_log;
	
	return 0 if ! $client{'qdbus'};
	my $b_modern_konvi = 0;
	my $konvi_version = '';
	my $konvi = '';
	my $pid = '';
	my (@temp);
	# main::log_data("name: $client{'name'} :: qdb: $client{'qdbus'} :: version: $client{'version'} :: konvi: $client{'konvi'} :: PPID: $ppid") if $b_log;
	# sabayon uses /usr/share/apps/konversation as path
	if ( -d '/usr/share/kde4/apps/konversation' || -d '/usr/share/apps/konversation' ){
		$pid = main::awk(\@ps_aux,'konversation',2,'\s+');
		main::log_data("pid: $pid") if $b_log;
		$konvi = readlink ("/proc/$pid/exe");
		$konvi =~ s/^.*\///; # basename
		@app = main::program_values('konversation');
		if ($konvi){
			@app = main::program_values('konversation');
			$konvi_version = main::program_version($konvi,$app[0],$app[1],$app[2]);
			@temp = split /\./, $konvi_version;
			$client{'console-irc'} = $app[4];
			$client{'konvi'} = 3;
			$client{'name'} = 'konversation';
			$client{'name-print'} = $app[3];
			$client{'version'} = $konvi_version;
			# note: we need to change this back to a single dot number, like 1.3, not 1.3.2
			$konvi_version = $temp[0] . "." . $temp[1];
			if ($konvi_version > 1.1){
				$b_modern_konvi = 1;
			}
		}
	}
	main::log_data("name: $client{'name'} name print: $client{'name-print'} 
	qdb: $client{'qdbus'} version: $konvi_version konvi: $konvi PID: $pid") if $b_log;
	main::log_data("b_is_qt4: $b_modern_konvi") if $b_log;
	## for testing this module
# 	my $ppid = getppid();
# 	system('qdbus org.kde.konversation', '/irc', 'say', $client{'dserver'}, $client{'dtarget'}, 
# 	"getpid_dir: $konvi_qt4 verNum: $konvi_version pid: $pid ppid: $ppid" );
	eval $end if $b_log;
	return $b_modern_konvi;
}

sub set_konvi_data {
	eval $start if $b_log;
	my $config_tool = '';
	# https://userbase.kde.org/Konversation/Scripts/Scripting_guide
	if ( $client{'konvi'} == 3 ){
		$client{'dserver'} = shift @ARGV;
		$client{'dtarget'} = shift @ARGV;
		$client{'dobject'} = 'default';
	}
	elsif ( $client{'konvi'} == 1 ){
		$client{'dport'} = shift @ARGV;
		$client{'dserver'} = shift @ARGV;
		$client{'dtarget'} = shift @ARGV;
		$client{'dobject'} = 'Konversation';
	}
	# for some reason this logic hiccups on multiple spaces between args
	@ARGV = grep { $_ ne '' } @ARGV;
	# there's no current kde 5 konvi config tool that we're aware of. Correct if changes.
	if ( main::check_program('kde4-config') ){
		$config_tool = 'kde4-config';
	}
	elsif ( main::check_program('kde5-config') ){
		$config_tool = 'kde5-config';
	}
	elsif ( main::check_program('kde-config') ){
		$config_tool = 'kde-config';
	}
	# The section below is on request of Argonel from the Konversation developer team:
	# it sources config files like $HOME/.kde/share/apps/konversation/scripts/inxi.conf
	if ($config_tool){
		my @data = main::grabber("$config_tool --path data 2>/dev/null",':');
		main::get_configs(@data);
	}
	eval $end if $b_log;
}
}

########################################################################
#### OUTPUT
########################################################################

#### -------------------------------------------------------------------
#### FILTERS AND TOOLS
#### -------------------------------------------------------------------

sub clean_characters {
	my ($data) = @_;
	# newline, pipe, brackets, + sign, with space, then clear doubled
	# spaces and then strip out trailing/leading spaces.
	$data =~ s/\n|\|\+|\[\s\]|\s\s+/ /g if $data; 
	$data =~ s/^\s+|\s+$//g if $data;
	return $data;
}


sub cleaner {
	my ($item) = @_;
	$item =~ s/chipset|components|computing|computer|corporation|communications|electronics|electrical|electric|gmbh|group|incorporation|industrial|international|nee|revision|semiconductor|software|technologies|technology|ltd\.|<ltd>|inc\.|<inc>|intl\.|co\.|<co>|corp\.|<corp>|\(tm\)|\(r\)|®|\(rev ..\)//gi;
	$item =~ s/,|\*/ /g;
	$item =~ s/\s\s+/ /g;
	return $item;
}

# not used, but keeping logic for now
sub increment_starters {
	my ($key,$indexes) = @_;
	my $result = $key;
	if (defined $$indexes{$key} ){
		$$indexes{$key}++;
		$result = "$key-$$indexes{$key}";
	}
	return $result;
}

#### -------------------------------------------------------------------
#### GENERATE OUTPUT
#### -------------------------------------------------------------------

sub output_handler {
	my (%data) = @_;
	# print Dumper \%data;
	if ($output_type eq 'screen'){
		print_data(%data);
	}
	elsif ($output_type eq 'csv'){
		generate_csv(%data);
	}
	elsif ($output_type eq 'json'){
		generate_json(%data);
	}
	elsif ($output_type eq 'xml'){
		generate_xml(%data);
	}
}
sub print_basic {
	my (@data) = @_;
	my $indent = 18;
	my $indent_static = 18;
	my $indent1_static = 5;
	my $indent2_static = 8;
	my $indent1 = 5;
	my $indent2 = 8;
	my $length =  @data;
	my ($start,$aref,$i,$j,$line);
	
	if ( $size{'max'} > 110 ){
		$indent_static = 22;
	}
	elsif ($size{'max'} < 90 ){
		$indent_static = 15;
	}
	# print $length . "\n";
	for my $i (0 .. $#data){
		$aref = $data[$i];
		#print "0: $data[$i][0]\n";
		if ($data[$i][0] == 0 ){
			$indent = 0;
			$indent1 = 0;
			$indent2 = 0;
		}
		elsif ($data[$i][0] == 1 ){
			$indent = $indent_static;
			$indent1 = $indent1_static;
			$indent2= $indent2_static;
		}
		elsif ($data[$i][0] == 2 ){
			$indent = ( $indent_static + 7 );
			$indent1 = ( $indent_static + 5 );
			$indent2 = 0;
		}
		$data[$i][3] =~ s/\n/ /g;
		$data[$i][3] =~ s/\s+/ /g;
		if ($data[$i][1] && $data[$i][2]){
			$data[$i][1] = $data[$i][1] . ', ';
		}
		$start = sprintf("%${indent1}s%-${indent2}s",$data[$i][1],$data[$i][2]);
		if ($indent > 1 && ( length($start) > ( $indent - 1) ) ){
			$line = sprintf("%-${indent}s\n", "$start");
			print_line($line);
			$start = '';
		}
		if ( ( $indent + length($data[$i][3]) ) < $size{'max'} ){
			$data[$i][3] =~ s/\^/ /g;
			$line = sprintf("%-${indent}s%s\n", "$start", $data[$i][3]);
			print_line($line);
		}
		else {
			my $holder = '';
			my $sep = ' ';
			foreach my $word (split / /, $data[$i][3]){
				#print "$word\n";
				if ( ( $indent + length($holder) + length($word) ) < $size{'max'} ) {
					$word =~ s/\^/ /g;
					$holder .= $word . $sep;
				}
				elsif ( ( $indent + length($holder) + length($word) ) > $size{'max'}){
					$line = sprintf("%-${indent}s%s\n", "$start", $holder);
					print_line($line);
					$start = '';
					$word =~ s/\^/ /g;
					$holder = $word . $sep;
				}
			}
			if ($holder !~ /^[ ]*$/){
				$line = sprintf("%-${indent}s%s\n", "$start", $holder);
				print_line($line);
			}
		}
	}
}
# this has to get a hash of hashes, at least for now.
# because perl does not retain insertion order, I use a prefix for each
# hash key to force sorts. 
sub print_data {
	my (%data) = @_;
	my $array = 0;
	my $counter=0;
	my $split_count = 0;
	my $hash = 0;
	my $holder = '';
	my $start = '';
	my $start2 = '';
	my $length = 0;
	my $indent = $size{'indent'};
	my (@temp,@working,@values,%ids,$holder2,%row);
	my ($key,$line,$val2,$val3);
	# $size{'max'} = 88;
	if ($size{'max'} < $size{'indent-min'}){
		$indent = 2;
	}
	foreach my $key1 (sort { (split/#/, $a)[0] <=> (split/#/, $b)[0] } keys %data) {
		$key = (split/#/, $key1)[1];
		if ($key ne 'SHORT' ) {
			$start = sprintf("$colors{'c1'}%-${indent}s$colors{'cn'}","$key$sep{'s1'}");
			if ($indent < 10){
				$line = "$start\n";
				print_line($line);
				$start = '';
				$line = '';
			}
		}
		else {
			$indent = 0;
		}
		if (ref($data{$key1}) eq 'ARRAY'){
			# @working = @{$data{$key1}};
			%ids = (
			'Battery' => 1,
			'Card' => 1,
			'Device' => 1,
			'Id' => 1,
			);
			foreach my $val1 (@{$data{$key1}}){
				$length = $indent;
				if (ref($val1) eq 'HASH'){
					#%row = %$val1;
					$counter=0;
					$split_count = 0;
					$hash = scalar %$val1;
					foreach my $key2 (sort { (split/#/, $a)[0] <=> (split/#/, $b)[0] } keys %$val1){
						$key = (split/#/, $key2)[1];
						if ($counter == 0 && defined $ids{$key}){
							$key .= '-' . $ids{$key}++;
						}
						$val2 = $$val1{$key2};
						if ($val2){
							$val2 .= " ";
						}
						# see: Use of implicit split to @_ is deprecated. Only get this warning
						# in Perl 5.08 oddly enough.
						@temp = split/\s+/, $val2;
						$split_count = scalar @temp;
						if ( ( length( "$key$sep{'s2'} $val2" ) + $length ) < $size{'max'} ) {
							$length += length("$key$sep{'s2'} $val2");
							$holder .= "$colors{'c1'}$key$sep{'s2'}$colors{'c2'} $val2";
							#print "one\n";
						}
						# handle case where the opening key/value pair is > max, and where 
						# there are a lot of terms, like cpu flags, raid types supported. Raid
						# can have the last row have a lot of devices, or many raid types
						elsif ( ( length( "$key$sep{'s2'} $val2" ) + $indent ) > $size{'max'} && 
								   !defined $ids{$key} && $split_count > 2 ) {
							@values = split/\s+/, $val2;
							$val3 = shift @values;
							# $length += length("$key$sep{'s2'} $val3 ") + $indent;
							$start2 = "$colors{'c1'}$key$sep{'s2'}$colors{'c2'} $val3 ";
							$holder2 = '';
							$length += length("$key$sep{'s2'} $val3 ");
							# print scalar @values,"\n";
							foreach (@values){
								# my $l =  (length("$_ ") + $length);
								#print "$l\n";
								if ( (length("$_ ") + $length) < $size{'max'} ){
									#print "a\n";
 									if ($start2){
										$holder2 .= "$start2$_ ";
										$start2 = '';
										#$length += $length2;
										#$length2 = 0;
									}
									else {
										$holder2 .= "$_ ";
									}
									$length += length("$_ ");
								}
								else {
									#print "three\n";
									if ($start2){
										$holder2 = "$start2$holder2";
									}
									else {
										$holder2 = "$colors{'c2'}$holder2";
									}
									#print "xx:$holder";
									$line = sprintf("%-${indent}s%s$colors{'cn'}\n","$start","$holder$holder2");
									print_line($line);
									$holder = '';
									
									$holder2 = "$_ ";
									#print "h2: $holder2\n";
									$length = length($holder2) + $indent;
									$start2 = '';
									$start = '';
									#$length2 = 0;
								}
							}
							if ($holder2 !~ /^\s*$/){
								#print "four\n";
								$holder2 = "$colors{'c2'}$holder2";
								$line = sprintf("%-${indent}s%s$colors{'cn'}\n","$start","$holder$holder2");
								print_line($line);
								$holder = '';
								$holder2 = '';
								$length = $indent;
								$start2 = '';
								$start = '';
								#$length2 = 0;
							}
						}
						else {
							#print "H: $counter $hash\n";
							if ($holder){
								#print "five\n";
								$line = sprintf("%-${indent}s%s$colors{'cn'}\n",$start,"$holder");
								$holder = "$colors{'c1'}$key$sep{'s2'}$colors{'c2'} $val2";
								$length = length("$key$sep{'s2'} $val2") + $indent;
								print_line($line);
								$start = '';
							}
							else {
								$holder = "$colors{'c1'}$key$sep{'s2'}$colors{'c2'} $val2";
								$line = sprintf("%-${indent}s%s$colors{'cn'}\n",$start,"$holder");
								$length = $indent;
								$holder = '';
							}
						}
						$counter++;
					}
					if ($holder !~ /^\s*$/){
						#print "six\n";
						$line = sprintf("%-${indent}s%s$colors{'cn'}\n",$start,"$start2$holder");
						print_line($line);
						$holder = '';
						$length = 0;
						$start = '';
					}
				}
				# only for repos?
				elsif (ref($val1) eq 'ARRAY'){
					$array=0;
					foreach my $item (@$val1){
						$array++;
						$line = "$colors{'c1'}$array$sep{'s2'} $colors{'c2'}$item$colors{'cn'}";
						$line = sprintf("%-${indent}s%s\n","","$line");
						print_line($line);
					}
				}
				else {
					
				}
			}
		}
	}
}

sub print_line {
	my ($line) = @_;
	if ($b_irc && $client{'test-konvi'}){
		$client{'konvi'} = 3;
		$client{'dobject'} = 'Konversation';
	}
	if ($client{'konvi'} == 1 && $client{'dcop'} ){
		# konvi doesn't seem to like \n characters, it just prints them literally
		$line =~ s/\n//g;
		#qx('dcop "$client{'dport'}" "$client{'dobject'}" say "$client{'dserver'}" "$client{'dtarget'}" "$line 1");
		system('dcop', $client{'dport'}, $client{'dobject'}, 'say', $client{'dserver'}, $client{'dtarget'}, "$line 1");
	}
	elsif ($client{'konvi'} == 3 && $client{'qdbus'} ){
		# print $line;
		$line =~ s/\n//g;
		#qx(qdbus org.kde.konversation /irc say "$client{'dserver'}" "$client{'dtarget'}" "$line");
		system('qdbus', 'org.kde.konversation', '/irc', 'say', $client{'dserver'}, $client{'dtarget'}, $line);
	}
	else {
		print $line;
	}
}

sub show_version {
	require Cwd;
	import Cwd;
	# if not in PATH could be either . or directory name, no slash starting
	my $working_path=$self_path;
	my (@data, @row, @rows, $link, $self_string);
	if ( $working_path eq '.' ){
		$working_path = getcwd();
	}
	elsif ( $working_path !~ /^\// ){
		$working_path = getcwd() . "/$working_path";
	}
	# handle if it's a symbolic link, rare, but can happen with directories 
	# in irc clients which would only matter if user starts inxi with -! 30 override 
	# in irc client
	if ( -l "$working_path/$self_name" ){
		$link="$working_path/$self_name";
		$working_path = readlink "$working_path/$self_name";
		$working_path =~ s/[^\/]+$//;
	}
	@row = [ 0, '', '', "$self_name $self_version-$self_patch ($self_date)"];
	push @data, @row;
	if ( ! $b_irc ){
		my $year = (split/-/, $self_date)[0];
		@row = [ 0, '', '', "Program Location: $working_path" ];
		push @data, @row;
		if ( $link ){
			@row = [ 0, '', '', "Started via symbolic link: $link" ];
			push @data, @row;
		}
		@rows = (
		[ 0, '', '', "Website:^https://github.com/smxi/inxi^or^http://smxi.org/" ],
		[ 0, '', '', "IRC:^irc.oftc.net channel:^#smxi" ],
		[ 0, '', '', "Forums:^http://techpatterns.com/forums/forum-33.html" ],
		[ 0, '', '', " " ],
		[ 0, '', '', "$self_name - the universal, portable, system information tool 
		for console and irc." ],
		[ 0, '', '', "Using Perl version: $]"],
		[ 0, '', '', " " ],
		[ 0, '', '', "This program started life as a fork of Infobash 3.02: 
		Copyright^(C)^2005-2007^Michiel^de^Boer^a.k.a.^locsmif." ],
		[ 0, '', '', "Subsequent changes and modifications (after Infobash 3.02): 
		Copyright^(C)^2008-$year^Harald^Hope^aka^h2. 
		CPU/Konversation^fixes:^Scott^Rogers^aka^trash80.
		USB^audio^fixes:^Steven^Barrett^aka^damentz." ],
		[ 0, '', '', '' ],
		[ 0, '', '', "This program is free software; you can redistribute it and/or modify 
		it under the terms of the GNU General Public License as published by the Free Software 
		Foundation; either version 3 of the License, or (at your option) any later version. 
		(http://www.gnu.org/licenses/gpl.html)" ]
		);
		push @data, @rows;
	}
	print_basic(@data); 
	exit 1;
}

########################################################################
#### DATA PROCESSORS
########################################################################

#### -------------------------------------------------------------------
#### GET DATA
#### -------------------------------------------------------------------

## Get AudioData 
{
package AudioData;

sub get {
	eval $start if $b_log;
	my (@audio,@rows);
	@rows = card_data();
	@audio = (@audio,@rows);
	eval $end if $b_log;
	return @audio;
}
# 'firewire',
# '0c00',
# '03:08',
# '0',
# 'VIA VT6306/7/8 [Fire II(M)] IEEE 1394 OHCI Controller',
# '1106:3044',
# '46',
# 'e800',
# 'firewire_ohci',
# 'firewire_ohci'

sub card_data {
	eval $start if $b_log;
	my (@rows,@data);
	my ($j) = (0);
	foreach (@pci){
		my $num = 1;
		my @row = @$_;
		if ($row[0] eq 'audio'){
			$j = scalar @rows;
			my $driver = $row[8];
			$driver ||= 'N/A';
			@data = (
			{
			$num++ . "#Card" => $row[4],
			$num++ . "#driver" => $driver,
			},
			);
			@rows = (@rows,@data);
			if ($extra > 1){
				if ($row[8] ){
					my $version = main::get_module_version($row[8]);
					if ($version){
						$rows[$j]{$num++ . "#v"} = main::get_module_version($row[8]);
					}
				}
			}
			if ($extra > 0){
				$rows[$j]{$num++ . "#bus ID"} = "$row[2].$row[3]";
			}
			if ($extra > 1){
				$rows[$j]{$num++ . "#chip ID"} = $row[5];
			}
		}
		#print "$row[0]\n";
	}
	#my $ref = $pci[-1];
	#print $$ref[0],"\n";
	eval $end if $b_log;
	return @rows;
}
}

sub get_compiler_version {
	eval $start if $b_log;
	my (@compiler);
	if (my $file = system_files('version') ) {
		@compiler = get_compiler_version_linux($file);
	}
	else {
		@compiler = get_compiler_version_bsd();
	}
	eval $end if $b_log;
	return @compiler;
}
sub get_compiler_version_bsd {
	eval $start if $b_log;
	my (@compiler);
	
	
	eval $end if $b_log;
	return @compiler;
}
sub get_compiler_version_linux {
	eval $start if $b_log;
	my ($file) = @_;
	my (@compiler,$type);
	my @data = reader($file);
	my $result = $data[0] if @data;
	if ($result){
		$result =~ /(gcc|clang).*version\s([\S]+)/;
		# $result = $result =~ /\*(gcc|clang)\*eval\*/;
		if ($1){
			$type = $2;
			$type ||= 'N/A'; # we don't really know what linux clang looks like!
			@compiler = ($1,$type);
		}
	}
	log_data(@compiler) if $b_log;
	
	eval $end if $b_log;
	return @compiler;
}
# Get DesktopEnvironment
## returns array:
# 0 - desktop name
# 1 - version
# 2 - toolkit
# 3 - toolkit version
# 4 - info extra desktop data
{
package DesktopEnvironment;
my ($b_xprop,$kde_session_version,$xdg_desktop,@desktop,@data,@xprop);
sub get {
	
	# NOTE $XDG_CURRENT_DESKTOP envvar is not reliable, but it shows certain desktops better.
	# most desktops are not using it as of 2014-01-13 (KDE, UNITY, LXDE. Not Gnome)
	$xdg_desktop = ( $ENV{'XDG_CURRENT_DESKTOP'} ) ? $ENV{'XDG_CURRENT_DESKTOP'} : '';
	$kde_session_version = ($ENV{'KDE_SESSION_VERSION'}) ? $ENV{'KDE_SESSION_VERSION'} : '';
	get_kde_data();
	
	if (!@desktop){
		get_env_de_data();
	}
	if (!@desktop){
		get_env_xprop_de_data();
	}
	if (!@desktop && $b_xprop ){
		get_xprop_de_data();
	}
	if (!@desktop){
		get_ps_de_data();
	}
	if ($extra > 2 && @desktop){
		set_info_data();
	}
	main::log_data('desktop data: ' . join '; ', @desktop) if $b_log;
	return @desktop;
}
sub get_kde_data {
	eval $start if $b_log;
	my ($program,@version_data,@version_data2);
	my $kde_full_session = ($ENV{'KDE_FULL_SESSION'}) ? $ENV{'KDE_FULL_SESSION'} : '';
	return 1 if ($xdg_desktop ne 'KDE' && !$kde_session_version && $kde_full_session ne 'true' );
	# works on 4, assume 5 will id the same, why not, no need to update in future
	# KDE_SESSION_VERSION is the integer version of the desktop
	# NOTE: as of plasma 5, the tool: about-distro MAY be available, that will show
	# actual desktop data, so once that's in debian/ubuntu, if it gets in, add that test
	if ($xdg_desktop eq 'KDE' || $kde_session_version ){
		if ($kde_session_version <= 4){
			@data = main::program_values("kded$kde_session_version");
			$desktop[0] = $data[3];
			$desktop[1] = main::program_version("kded$kde_session_version",$data[0],$data[1],$data[2],$data[5]);
		}
		else {
			# NOTE: this command string is almost certain to change, and break, with next 
			# major plasma desktop, ie, 6. 
			# qdbus org.kde.plasmashell /MainApplication org.qtproject.Qt.QCoreApplication.applicationVersion
			# Qt: 5.4.2
			# KDE Frameworks: 5.11.0
			# kf5-config: 1.0
			# for QT, and Frameworks if we use it
			if ($program = main::check_program("kded$kde_session_version")){
				@version_data = main::grabber("$program --version 2>/dev/null");
			}
			if ($program = main::check_program("plasmashell")){
				@version_data2 = main::grabber("$program --version 2>/dev/null");
				$desktop[1] = main::awk(\@version_data2,'^plasmashell',-1,'\s+');
			}
			$desktop[0] = 'KDE Plasma';
		}
		if (!$desktop[1]){
			$desktop[1] = $kde_session_version;
		}
		print Data::Dumper::Dumper \@version_data;
		if ($extra > 0 && @version_data){
			$desktop[2] = 'Qt';
			$desktop[3] = main::awk(\@version_data,'^Qt:', 2,'\s+');
		}
	}
	# KDE_FULL_SESSION property is only available since KDE 3.5.5.
	elsif ($kde_full_session eq 'true'){
		@version_data = main::grabber("kded --version 2>/dev/null");
		$desktop[0] = 'KDE';
		$desktop[1] = main::awk(\@version_data,'^KDE:',2,'\s+');
		if (!$desktop[1]){
			$desktop[1] = '3.5';
		}
		if ($extra > 0){
			$desktop[3] = main::awk(\@version_data,'^Qt:',2,'\s+');
		}
	}
	eval $end if $b_log;
}
sub get_env_de_data {
	eval $start if $b_log;
	my ($program,@version_data);
	
	if ($xdg_desktop eq 'Unity'){
		@data = main::program_values('unity');
		$desktop[0] = $data[3];
		$desktop[0] ||= 'Unity';
		$desktop[1] = main::program_version('cinnamon',$data[0],$data[1],$data[2],$data[5]);
		set_gtk_data() if $extra > 0;
	}
	elsif ( $xdg_desktop =~ /Budgie/i ){
		@data = main::program_values('budgie');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('budgie-desktop',$data[0],$data[1],$data[2],$data[5]);
		set_gtk_data() if $extra > 0;
	}
	elsif ( $xdg_desktop eq 'LXQT' ){
		@data = main::program_values('lxqt');
		$desktop[0] = $data[3];
		$desktop[0] ||= 'LXQT';
		$desktop[1] = main::program_version('lxqt-about',$data[0],$data[1],$data[2],$data[5]);
		if ( $extra > 0 ){
			if ($program = main::check_program("kded$kde_session_version") ){
				@version_data = main::grabber("$program --version 2>/dev/null");
				$desktop[2] = 'Qt';
				$desktop[3] = main::awk(\@version_data,'^Qt:',2);
			}
			elsif ($program = main::check_program("qtdiag") ){
				@data = main::program_values('qtdiag');
				$desktop[3] = main::program_version($program,$data[0],$data[1],$data[2],$data[5]);
				$desktop[2] = $data[3];
			}
		}
	}
	# note, X-Cinnamon value strikes me as highly likely to change, so just 
	# search for the last part
	elsif ( $xdg_desktop =~ /Cinnamon/i ){
		@data = main::program_values('cinnamon');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('cinnamon',$data[0],$data[1],$data[2],$data[5]);
		set_gtk_data() if $extra > 0;
	}
	eval $end if $b_log;
}
sub get_env_xprop_de_data {
	eval $start if $b_log;
	my ($program,@version_data);
	set_xprop();
	# note that cinnamon split from gnome, and and can now be id'ed via xprop,
	# but it will still trigger the next gnome true case, so this needs to go 
	# before gnome test eventually this needs to be better organized so all the 
	# xprop tests are in the same section, but this is good enough for now.
	if ($b_xprop && main::awk(\@xprop,'_muffin' )){
		@data = main::program_values('cinnamon');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('cinnamon',$data[0],$data[1],$data[2],$data[5]);
		set_gtk_data() if $extra > 0;
		$desktop[0] ||= 'Cinnamon';
	}
	elsif ($xdg_desktop eq 'MATE' || $b_xprop && main::awk(\@xprop,'_marco')){
		@data = main::program_values('mate');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('mate-about',$data[0],$data[1],$data[2],$data[5]);
		set_gtk_data() if $extra > 0;
		$desktop[0] ||= 'MATE';
	}
	# note, GNOME_DESKTOP_SESSION_ID is deprecated so we'll see how that works out
	# https://bugzilla.gnome.org/show_bug.cgi?id=542880
	elsif ($xdg_desktop eq 'GNOME' || $ENV{'GNOME_DESKTOP_SESSION_ID'}){
		if ($program = main::check_program('gnome-about') ) {
			@data = main::program_values('gnome-about');
			$desktop[1] = main::program_version('gnome-about',$data[0],$data[1],$data[2],$data[5]);
		}
		elsif ($program = main::check_program('gnome-shell') ) {
			@data = main::program_values('gnome-shell');
			$desktop[1] = main::program_version('gnome-shell',$data[0],$data[1],$data[2],$data[5]);
		}
		set_gtk_data() if $extra > 0;
		$desktop[0] = ($data[3])?$data[3] :'Gnome';
	}
	eval $end if $b_log;
}
sub get_xprop_de_data {
	eval $start if $b_log;
	my ($program,@version_data,$version);
	#print join "\n", @xprop, "\n";
	# String: "This is xfdesktop version 4.2.12"
	# alternate: xfce4-about --version > xfce4-about 4.10.0 (Xfce 4.10)
	if (main::awk(\@xprop,'xfce' )){
		if (main::awk(\@xprop, 'xfce4')){
			$version = '4';
		}
		elsif (main::awk(\@xprop, 'xfce5')){
			$version = '5';
		}
		else {
			$version = '4';
		}
		@data = main::program_values('xfdesktop');
		$desktop[0] = $data[3];
		@version_data = main::grabber('xfdesktop --version 2>/dev/null');
		# out of x, this error goes to stderr, so it's an empty result
		$desktop[1] = main::awk(\@version_data,$data[0],$data[1],'\s+');
		#$desktop[1] = main::program_version('xfdesktop',$data[0],$data[1],$data[2],$data[5]);
		if ( !$desktop[1] ){
			@data = main::program_values("xfce${version}-panel");
			# print Data::Dumper::Dumper \@data;
			# this returns an error message to stdout in x, which breaks the version
			$desktop[1] = main::program_version("xfce${version}-panel",$data[0],$data[1],$data[2],$data[5]);
			# out of x this kicks out an error: xfce4-panel: Cannot open display
			$desktop[1] = '' if $desktop[1] !~ /[0-9]\./; 
		}
		$desktop[0] ||= 'Xfce';
		$desktop[1] ||= 4;
		if ($extra > 0){
			@data = main::program_values('xfdesktop-toolkit');
			#$desktop[3] = main::program_version('xfdesktop',$data[0],$data[1],$data[2],$data[5]);
			$desktop[3] = main::awk(\@version_data,$data[0],$data[1],'\s+');
			$desktop[2] = $data[3];
		}
		
	}
	elsif ( main::awk(\@xprop,'blackbox_pid' )){
		if (grep {/fluxbox/} @ps_cmd){
			@data = main::program_values('fluxbox');
			$desktop[0] = $data[3];
			$desktop[1] = main::program_version('fluxbox',$data[0],$data[1],$data[2],$data[5]);
		}
		else {
			$desktop[0] = 'Blackbox';
		}
	}
	elsif ( main::awk(\@xprop,'openbox_pid' )){
		# note: openbox-lxde --version may be present, but returns openbox data
		@data = main::program_values('openbox');
		$desktop[1] = main::program_version('openbox',$data[0],$data[1],$data[2],$data[5]);
		if ($xdg_desktop eq 'LXDE' || main::awk(\@ps_cmd, 'lxsession')){
			$desktop[1] = "(Openbox $desktop[1])" if $desktop[1];
			$desktop[0] = 'LXDE';
		}
		elsif ($xdg_desktop eq 'Razor' || $xdg_desktop eq 'LXQt' || main::awk(\@ps_cmd, 'razor-desktop|lxqt-session')) {
			if (main::awk(\@ps_cmd,'lxqt-session' )){
				$desktop[0] = 'LXQt';
			}
			elsif (main::awk(\@ps_cmd, 'razor-desktop')){
				$desktop[0] = 'Razor-Qt';
			}
			else {
				$desktop[0] = 'LX-Qt-Variant';
			}
			$desktop[1] = "(Openbox $desktop[1])" if $desktop[1];
		}
		else {
			$desktop[0] = 'Openbox';
		}
	}
	elsif (main::awk(\@xprop,'icewm' )){
		@data = main::program_values('icewm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('icewm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@xprop,'enlightenment' )){
		$desktop[0] = 'Enlightenment';
		# no -v or --version but version is in xprop -root
		# ENLIGHTENMENT_VERSION(STRING) = "Enlightenment 0.16.999.49898"
		$desktop[1] = main::awk(\@xprop,'enlightenment_version',2,'\s+=\s+' );
		$desktop[1] = (split /"/, $desktop[1])[1] if $desktop[1];
		$desktop[1] = (split /\s+/, $desktop[1])[1] if $desktop[1];
	}
	elsif (main::awk(\@xprop,'^i3_' )){
		@data = main::program_values('i3');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('i3',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@xprop,'^windowmaker' )){
		@data = main::program_values('wmaker');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('wmaker',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@xprop,'^_wm2' )){
		@data = main::program_values('wm2');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('wm2',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@xprop,'herbstluftwm' )){
		@data = main::program_values('herbstluftwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('herbstluftwm',$data[0],$data[1],$data[2],$data[5]);
	}
	# need to check starts line because it's so short
	eval $end if $b_log;
}
sub get_ps_de_data {
	eval $start if $b_log;
	my ($program,@version_data);
	if ( main::awk(\@ps_cmd,'fvwm-crystal' )){
		@data = main::program_values('fvwm-crystal');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('fvwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@ps_cmd,'fvwm' )){
		@data = main::program_values('fvwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('fvwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@ps_cmd,'pekwm' )){
		@data = main::program_values('pekwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('pekwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@ps_cmd,'awesome' )){
		@data = main::program_values('awesome');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('awesome',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@ps_cmd,'scrotwm' )){
		@data = main::program_values('scrotwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('scrotwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@ps_cmd,'spectrwm' )){
		@data = main::program_values('spectrwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('spectrwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@ps_cmd,'(\s|\/)twm' )){
		# no version
		$desktop[0] = 'Twm';
	}
	elsif (main::awk(\@ps_cmd,'(\s|\/)dwm' )){
		@data = main::program_values('dwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('dwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@ps_cmd,'wmii2' )){
		@data = main::program_values('wmii2');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('wmii2',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@ps_cmd,'wmii' )){
		@data = main::program_values('wmii');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('wmii',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@ps_cmd,'(\s|\/)jwm' )){
		@data = main::program_values('jwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('jwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::awk(\@ps_cmd,'sawfish' )){
		@data = main::program_values('sawfish');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('sawfish',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif ( grep {/afterstep/} @ps_cmd){
		@data = main::program_values('afterstep');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('afterstep',$data[0],$data[1],$data[2],$data[5]);
	}
	eval $end if $b_log;
}

sub set_gtk_data {
	eval $start if $b_log;
	my ($version,$program,@data);
	# this is a hack, and has to be changed with every toolkit version change, and 
	# only dev systems 	# have this installed, but it's a cross distro command try it.
	if ($program = main::check_program('pkg-config')){
		@data = main::grabber("$program --modversion gtk+-4.0 2>/dev/null");
		$version = main::awk(\@data,'\S');
		# note: opensuse gets null output here, we need the command to get version and output sample
		if ( !$version ){
			@data = main::grabber("$program --modversion gtk+-3.0 2>/dev/null");
			$version = main::awk(\@data,'\S');
		}
		if ( !$version ){
			@data = main::grabber("$program --modversion gtk+-2.0 2>/dev/null");
			$version = main::awk(\@data,'\S');
		}
	}
	# now let's go to more specific version tests, this will never cover everything and that's fine.
	if (!$version){
		# we'll try some known package managers next. dpkg will handle a lot of distros 
		# this is the most likely order as of: 2014-01-13. Not going to try to support all 
		# package managers too much work, just the very biggest ones.
		if ($program = main::check_program('dpkg')){
			@data = main::grabber("$program -s libgtk-3-0 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s+');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -s libgtk-4-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s+');
			}
			if (!$version){
				@data = main::grabber("$program -s libgtk2.0-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s+');
			}
		}
		elsif ($program = main::check_program('pacman')){
			@data = main::grabber("$program -Qi gtk3 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -Qi gtk4 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
			if (!$version){
				@data = main::grabber("$program -Qi gtk2 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
		}
		elsif ($program = main::check_program('rpm')){
			@data = main::grabber("$program -qi libgtk-3-0 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -qi libgtk-4-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
			if (!$version){
				@data = main::grabber("$program -qi libgtk-3-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
		}
	}
	$desktop[2] = 'Gtk';
	eval $end if $b_log;
}
sub set_info_data {
	eval $start if $b_log;
	my (@data,@info,$item);
	if (@data = grep {/gnome-shell|gnome-panel|kicker|lxpanel|mate-panel|plasma-desktop|plasma-netbook|xfce4-panel/} @ps_cmd ) {
		# only one entry per type, can be multiple
		foreach $item (@data){
			if (! main::awk(\@info, "$item")){
				$item = main::trimmer($item);
				push @info, (split /\s+/, $item)[0];
			}
		}
	}
	$desktop[4] = join (',', @info) if @info;
	eval $end if $b_log;
}

sub set_xprop {
	eval $start if $b_log;
	if (my $program = main::check_program('xprop')){
		@xprop = main::grabber("xprop -root $display_opt 2>/dev/null");
		if (@xprop){
			@xprop = grep {/^\S/} @xprop;
			$_=lc for @xprop;
			$b_xprop = 1 if scalar @xprop > 5;
		}
	}
	eval $end if $b_log;
}

}

sub get_display_manager {
	eval $start if $b_log;
	my (@data,@found,$temp,$working);
	# ldm - LTSP display manager. Note that sddm does not appear to have a .pid 
	# extension in Arch note: to avoid positives with directories, test for -f 
	# explicitly, not -e
	my @dms = qw(entranced.pid gdm.pid gdm3.pid kdm.pid ldm.pid 
	lightdm.pid lxdm.pid mdm.pid nodm.pid sddm.pid sddm slim.lock 
	tint2.pid wdm.pid xdm.pid);
	# this is the only one I know of so far that has --version
	# lightdm outputs to stderr, so it has to be redirected
	my @dms_version = qw(lightdm);
	foreach my $id (@dms){
		# note: ${dm_id%.*}/$dm_id will create a dir name out of the dm id, then 
		# test if pid is in that note: sddm, in an effort to be unique and special, 
		# do not use a pid/lock file, but rather a random string inside a directory 
		# called /run/sddm/ so assuming the existence of the pid inside a directory named
		# from the dm. Hopefully this change will not have negative results.
		$working = $id;
		$working =~ s/\.\S+$//;
		# note: there's always been an issue with duplicated dm's in inxi, this should now correct it
		if ( ( -f "/run/$id" || -d "/run/$working" || -f "/var/run/$id" ) && ! grep {/$working/} @found ){
			if ($extra > 2 && awk( \@dms_version, $working) ){
				@data = main::grabber("$working --version 2>&1");
				$temp = awk(\@data,'\S',2,'\s+');
				$working .= ' ' . $temp if $temp;
			}
			push @found, $working;
		}
	}
	if (!@found && grep {/\/usr.*\/x/ && !/\/xprt/} @ps_cmd){
		if (awk (\@ps_cmd, 'startx') ){
			$found[0] = 'startx';
		}
	}
	# might add this in, but the rate of new dm's makes it more likely it's an 
	# unknown dm, so we'll keep output to N/A
	log_data('display manager: ' . join ',', @dms) if $b_log;
	eval $end if $b_log;
	return join ',', @found if @found;
}

## Get DistroData
{
package DistroData;
my ($distro);
sub get {
	if ($bsd_type){
		get_bsd_os();
	}
	else {
		get_linux_distro();
	}
	return $distro;
}

sub get_bsd_os {
	eval $start if $b_log;
	if ($bsd_type eq 'darwin'){
		my $file = '/System/Library/CoreServices/SystemVersion.plist';
		if (-f $file){
			my @data = main::reader($file);
			@data = grep {/(ProductName|ProductVersion)/} @data if @data;
			@data = grep {/<string>/} @data if @data;
			@data = map {s/<[\/]?string>//g; } @data if @data;
			$distro = join (' ', @data);
		}
	}
	else {
		my @uname = POSIX::uname();
		$distro = "$uname[0] $uname[2]";
	}
	
	eval $end if $b_log;
	return $distro;
}

sub get_linux_distro {
	eval $start if $b_log;
	my $distro_file = '';
	my (@working,$b_osr);
	my @derived = qw(antix-version aptosid-version kanotix-version knoppix-version 
	mandrake-release mx-version pardus-release porteus-version sabayon-release 
	siduction-version sidux-version slitaz-release solusos-release turbolinux-release 
	zenwalk-version);
	my $derived_s = join "|", @derived;
	my @primary = qw(arch-release gentoo-release redhat-release slackware-version 
	SuSE-release);
	my $primary_s = join "|", @primary;
	my $exclude_s = 'debian_version|devuan_version|ubuntu_version';
	my $lsb_good_s = 'mandrake-release|mandriva-release|mandrakelinux-release|manjaro-release';
	my $os_release_good_s = 'arch-release|SuSE-release';
	# note: always exceptions, so wild card after release/version: 
	# /etc/lsb-release-crunchbang
	# wait to handle since crunchbang file is one of the few in the world that 
	# uses this method
	my @distro_files = </etc/*[-_]{[rR]elease,[vV]ersion}*>;
	my $distro_files_s = join "|", @distro_files;
	my $lsb_release = '/etc/lsb-release';
	my $b_lsb = ( -f $lsb_release ) ? 1 : 0;
	my $issue = '/etc/issue';
	my $os_release = '/etc/os-release';
	my $b_os_release = ( -f $os_release ) ? 1 : 0;
	main::log_data( "distro files: " . join "; ",@distro_files);
	if ( $#distro_files == 1 ){
		$distro_file = $distro_files[0];
	}
	else {
		@working = (@derived,@primary);
		foreach my $file (@working){
			if ( "/etc/$file" =~ /($distro_files_s)$/){
				# Now lets see if the distro file is in the known-good working-lsb-list
				# if so, use lsb-release, if not, then just use the found file
				# this is for only those distro's with self named release/version files
				# because Mint does not use such, it must be done as below 
				## this if statement requires the spaces and * as it is, else it won't work
				if ($b_lsb && $file =~ /$lsb_good_s/){
					$distro_file = $lsb_release;
				}
				elsif ($b_os_release && $file =~ /($os_release_good_s)$/){
					$distro_file = $os_release;
				}
				else {
					$distro_file = "/etc/$file";
				}
				last;
			}
		}
		main::log_data("distro_file: $distro_file");
	}
	
	# first test for the legacy antiX distro id file
	if ( -f '/etc/antiX'){
		@working = main::reader('/etc/antiX');
		$distro = main::awk(\@working,'antix.*\.iso') if @working;
		$distro = main::clean_characters($distro) if $distro;
	}
	# this handles case where only one release/version file was found, and it's lsb-release. 
	# This would never apply for ubuntu or debian, which will filter down to the following 
	# conditions. In general if there's a specific distro release file available, that's to 
	# be preferred, but this is a good backup.
	elsif ($distro_file && $b_lsb && ($distro_file =~ /\/etc\/($lsb_good_s)$/ || $distro_file eq $lsb_release) ){
		$distro = get_lsb_release();
	}
	elsif ($distro_file eq $os_release){
		$distro = get_os_release();
		$b_osr = 1;
	}
	# if distro id file was found and it's not in the exluded primary distro file list, read it
	elsif ( $distro_file && -s $distro_file && $distro_file !~ /\/etc\/($exclude_s)$/){
		# new opensuse uses os-release, but older ones may have a similar syntax, so just use 
		# the first line
		if ($distro_file eq '/etc/SuSE-release'){
			# leaving off extra data since all new suse have it, in os-release, this file has 
			# line breaks, like os-release  but in case we  want it, it's: 
			# CODENAME = Mantis  | VERSION = 12.2 
			# for now, just take first occurrence, which should be the first line, which does 
			# not use a variable type format
			@working = main::reader($distro_file);
			$distro = main::awk(\@working,'suse');
			$distro = main::clean_characters($distro) if $distro;
		}
		else {
			$distro = (main::reader($distro_file))[0];
		}
	}
	# otherwise try  the default debian/ubuntu /etc/issue file
	elsif (-f $issue){
		@working = main::reader($issue);
		my $b_mint = scalar (grep {/mint/i} @working); 
		# os-release/lsb gives more manageable and accurate output than issue, 
		# but mint should use issue for now.
		if ($b_os_release && !$b_mint){
			$distro = get_os_release();
			$b_osr = 1;
		}
		elsif ($b_lsb && !$b_mint){
			$distro = get_lsb_release();
		}
		else {
			# debian issue can end with weird escapes like \n \l
			@working = main::reader($issue);
			$distro = (map {s/\\[a-z]|,|\*|\\||\"|[:\47]|^\s+|\s+$|n\/a//ig; $_} @working)[0] if @working;
			# this handles an arch bug where /etc/arch-release is empty and /etc/issue 
			# is corrupted only older arch installs that have not been updated should 
			# have this fallback required, new ones use os-release
			if ( $distro =~ /arch linux/i){
				$distro = 'Arch Linux';
			}
		}
	}
	# a final check. If a long value, before assigning the debugger output, if os-release
	# exists then let's use that if it wasn't tried already. Maybe that will be better.
	# not handling the corrupt data, maybe later if needed
	if ($distro && length($distro) > 50 ){
		if (!$b_osr && $b_os_release){
			$distro = get_os_release();
		}
	}
	# test for /etc/lsb-release as a backup in case of failure, in cases 
	# where > one version/release file were found but the above resulted 
	# in null distro value. 
	if (!$distro){
		if ($b_os_release){
			$distro = get_os_release();
		}
		elsif ($b_lsb){
			$distro = get_lsb_release();
		}
	}
	# now some final null tries
	if (!$distro ){
		# if the file was null but present, which can happen in some cases, then use 
		# the file name itself to set the distro value. Why say unknown if we have 
		# a pretty good idea, after all?
		if ($distro_file){
			$distro_file =~ s/[-_]|release|version//g;
		}
	}
	## finally, if all else has failed, give up
	$distro ||= 'unknown';
	eval $end if $b_log;
	return $distro;
}
sub get_lsb_release {
	eval $start if $b_log;
	my ($distro,$id,$release,$codename,$description,) = ('','','','','');
	my @content = main::reader('/etc/lsb-release');
	@content = map {s/,|\*|\\||\"|[:\47]|^\s+|\s+$|n\/a//ig; $_} @content if @content;
	foreach (@content){
		my @working = split /\s*=\s*/, $_;
		if ($working[0] eq 'DISTRIB_ID' && $working[1]){
			if ($working[1] =~ /^Arch$/i){
				$id = 'Arch Linux';
			}
			else {
				$id = $working[1];
			}
		}
		if ($working[0] eq 'DISTRIB_RELEASE' && $working[1]){
			$release = $working[1];
		}
		if ($working[0] eq 'DISTRIB_CODENAME' && $working[1]){
			$codename = $working[1];
		}
		# sometimes some distros cannot do their lsb-release files correctly, 
		# so here is one last chance to get it right.
		if ($working[0] eq 'DISTRIB_DESCRIPTION' && $working[1]){
			$description = $working[1];
		}
	}
	if (!$id && !$release && !$codename && $description){
		$distro = $description;
	}
	else {
		$distro = "$id $release $codename";
		$distro =~ s/^\s+|\s\s+|\s+$//g; # get rid of double and trailling spaces 
	}
	
	eval $end if $b_log;
	return $distro;
}
sub get_os_release {
	eval $start if $b_log;
	my ($pretty_name,$name,$version_name,$version_id,
	$distro_name,$distro) = ('','','','','','');
	my @content = main::reader('/etc/os-release');
	@content = map {s/\\||\"|[:\47]|^\s+|\s+$|n\/a//ig; $_} @content if @content;
	foreach (@content){
		my @working = split /\s*=\s*/, $_;
		if ($working[0] eq 'PRETTY_NAME' && $working[1]){
			$pretty_name = $working[1];
		}
		if ($working[0] eq 'NAME' && $working[1]){
			$name = $working[1];
		}
		if ($working[0] eq 'VERSION' && $working[1]){
			$version_name = $working[1];
		}
		if ($working[0] eq 'VERSION_ID' && $working[1]){
			$version_id = $working[1];
		}
	}
	# NOTE: tumbleweed has pretty name but pretty name does not have version id
	if ($pretty_name && $pretty_name !~ /tumbleweed/i){
		$distro = $pretty_name;
	}
	elsif ($name){
		$distro = $name;
		if ($version_name){
			$distro .= ' ' . $version_name;
		}
		elsif ($version_id){
			$distro .= ' ' . $version_id;
		}
		
	}
	eval $end if $b_log;
	return $distro;
}
}

## Get GraphicData 
{
package GraphicData;

sub get {
	eval $start if $b_log;
	my (@graphic,@rows);
	@rows = card_data();
	@graphic = (@graphic,@rows);
	eval $end if $b_log;
	return @graphic;
}
# 'firewire',
# '0c00',
# '03:08',
# '0',
# 'VIA VT6306/7/8 [Fire II(M)] IEEE 1394 OHCI Controller',
# '1106:3044',
# '46',
# 'e800',
# 'firewire_ohci',
# 'firewire_ohci'
# not using 3D controller yet, needs research: |3D controller |display controller
# note: this is strange, but all of these can be either a separate or the same
# card. However, by comparing bus id, say: 00:02.0 we can determine that the
# cards are  either the same or different. We want only the .0 version as a valid
# card. .1 would be for example: Display Adapter with bus id x:xx.1, not the right one
sub card_data {
	eval $start if $b_log;
	my (@rows,@data);
	my ($j) = (0);
	foreach (@pci){
		my $num = 1;
		my @row = @$_;
		#print "$row[0] $row[3]\n";
		if ($row[3] == 0 && ( $row[0] eq 'vga' || $row[0] eq 'display' || $row[0] eq '3d' ) ){
			#print "$row[0] $row[3]\n";
			$j = scalar @rows;
			my $driver = $row[8];
			$driver ||= 'N/A';
			@data = (
			{
			$num++ . "#Card" => $row[4],
			$num++ . "#driver" => $driver,
			},
			);
			@rows = (@rows,@data);
			if ($row[8]){
				my $version = main::get_module_version($row[8]);
				$version ||= 'N/A';
				$rows[$j]{$num++ . "#v"} = $version;
			}
			if ($extra > 0){
				$rows[$j]{$num++ . "#bus ID"} = "$row[2].$row[3]";
			}
			if ($extra > 1){
				$rows[$j]{$num++ . "#chip ID"} = $row[5];
			}
		}
		#print "$row[0]\n";
	}
	#my $ref = $pci[-1];
	#print $$ref[0],"\n";
	eval $end if $b_log;
	return @rows;
}
}

sub get_init_data {
	eval $start if $b_log;
	my $runlevel = get_runlevel_data();
	my $default = ($extra > 1) ? get_runlevel_default() : '';
	my ($init,$init_version,$rc,$rc_version,$program) = ('','','','','');
	my $comm = ( -e '/proc/1/comm' ) ? (reader('/proc/1/comm'))[0] : '';
	my (@data);
	# this test is pretty solid, if pid 1 is owned by systemd, it is systemd
	# otherwise that is 'init', which covers the rest of the init systems.
	# more data may be needed for other init systems.
	if ($comm && $comm =~ /systemd/ ){
		$init = 'systemd';
		if ( $program = check_program('systemd')){
			$init_version = program_version($program,'^systemd','2','--version');
		}
		if (!$init_version && ($program = check_program('systemctl') ) ){
			$init_version = program_version($program,'^systemd','2','--version');
		}
	}
	else {
		# /sbin/init --version == init (upstart 1.12.1)
		if ($comm =~ /upstart/){
			$init = 'Upstart';
			$init_version = program_version('init', 'upstart', '3','--version');
		}
		# epoch version == Epoch Init System 1.0.1 "Sage"
		elsif ($comm =~ /epoch/){
			$init = 'Epoch';
			$init_version = program_version('epoch', '^Epoch', '4','version');
		}
		# missing data: note, runit can install as a dependency without being the 
		# init system: http://smarden.org/runit/sv.8.html
		# NOTE: the proc test won't work on bsds, so if runit is used on bsds we 
		# will need more data
		elsif ($comm =~ /runit/){
			$init = 'runit';
		}
		elsif (check_program('launchctl')){
			$init = 'launchd';
		}
		elsif ( -f '/etc/inittab' ){
			$init = 'SysVinit';
			if (check_program('strings')){
				@data = data_dumper('strings /sbin/init');
				$init_version = awk(\@data,'version\s+[0-9]');
				$init_version = get_piece($init_version,2) if $init_version;
			}
		}
		elsif ( -f '/etc/ttys' ){
			$init = 'init (BSD)';
		}
		if ( grep { /openrc/ } </run/*> ){
			$rc = 'OpenRC';
			# /sbin/openrc --version == openrc (OpenRC) 0.13
			if ($program = check_program('openrc')){
				$rc_version = program_version($program, '^openrc', '3','--version');
			}
			# /sbin/rc --version == rc (OpenRC) 0.11.8 (Gentoo Linux)
			elsif ($program = check_program('rc')){
				$rc_version = program_version($program, '^rc', '3','--version');
			}
			if ( -e '/run/openrc/softlevel' ){
				$runlevel = (reader('/run/openrc/softlevel'))[0];
			}
			elsif ( -e '/var/run/openrc/softlevel'){
				$runlevel = (reader('/var/run/openrc/softlevel'))[0];
			}
			elsif ( $program = check_program('rc-status')){
				$runlevel = (grabber("$program -r 2>/dev/null"))[0];
			}
		}
	}
	my %init = (
	'init-type' => $init,
	'init-version' => $init_version,
	'rc-type' => $rc,
	'rc-version' => $rc_version,
	'runlevel' => $runlevel,
	'default' => $default,
	);
	eval $end if $b_log;
	return %init;
}

sub get_memory_data {
	eval $start if $b_log;
	my ($memory);
	if (my $file = system_files('meminfo') ) {
		$memory = get_memory_data_linux($file);
	}
	else {
		$memory = get_memory_data_bsd();
	}
	eval $end if $b_log;
	return $memory;
}

sub get_memory_data_linux {
	eval $start if $b_log;
	my ($file) = @_;
	my $memory = '';
	my $total = 0;
	my $not_used = 0;
	my @data = reader($file);
	foreach (@data){
		if ($_ =~ /^MemTotal:/){
			$total = get_piece($_,2);
		}
		elsif ($_ =~ /^(MemFree|Buffers|Cached):/){
			$not_used +=  get_piece($_,2);
		}
	}
	my $used = $total - $not_used;
	my $percent = ($used && $total) ? sprintf(" (%.1f%%)", ($used/$total)*100) : '';
	$memory = sprintf("%.1f/%.1f MB", $used/1024, $total/1024) . $percent;
	log_data("memory: $memory") if $b_log;
	eval $end if $b_log;
	return $memory;
}
# openbsd/linux
# procs    memory       page                    disks    traps          cpu
# r b w    avm     fre  flt  re  pi  po  fr  sr wd0 wd1  int   sys   cs us sy id
# 0 0 0  55256 1484092  171   0   0   0   0   0   2   0   12   460   39  3  1 96
# freebsd:
# procs      memory      page                    disks     faults         cpu
# r b w     avm    fre   flt  re  pi  po    fr  sr ad0 ad1   in   sy   cs us sy id
# 0 0 0  21880M  6444M   924  32  11   0   822 827   0   0  853  832  463  8  3 88
# with -H
# 2 0 0 14925812  936448    36  13  10   0    84  35   0   0   84   30   42 11  3 86
# dragonfly
#  procs      memory      page                    disks     faults      cpu
#  r b w     avm    fre  flt  re  pi  po  fr  sr ad0 ad1   in   sy  cs us sy id
#  0 0 0       0  84060 30273993 2845 12742 1164 407498171 320960902   0   0 ....
sub get_memory_data_bsd {
	eval $start if $b_log;
	my $memory = 'BSD-dev';
	my $total = 0;
	my $avg = 0;
	my (@data,$b_free);
	
	if (my $program = check_program('vmstat')){
		# see above, it's the last line
		my $row = (grabber('vmstat -H 2>/dev/null','\n','strip'))[-1];
		if ( $row ){
			@data = split /\s+/, $row;
			# dragonfly can have 0 avg, but they may fix that so make test dynamic
			if ($data[3] != 0){
				$avg = sprintf ('%.1f',$data[3]/1024);
			}
			elsif ($data[4] != 0){
				$b_free = 1;
				$avg = sprintf ('%.1f',$data[4]/1024);
			}
		}
	}
	## code to get total goes here:
	my $type = ($b_free) ? ' free':'' ;
	if ($avg && !$total){
		$memory = "$avg$type/(total N/A) MB";
	}
	elsif ($avg && $total) {
		my $used = (!$b_free) ? $avg : $total - $avg;
		my $percent = ($used && $total) ? sprintf(" (%.1f%%)", ($used/$total)*100) : '';
		$memory = "$used$type/$total MB" . $percent;
	}
	eval $end if $b_log;
	return $memory;
}

## Get NetworkData 
{
package NetworkData;

sub get {
	eval $start if $b_log;
	my (@network,@rows);
	@rows = card_data();
	@network = (@network,@rows);
	eval $end if $b_log;
	return @network;
}
# 'firewire',
# '0c00',
# '03:08',
# '0',
# 'VIA VT6306/7/8 [Fire II(M)] IEEE 1394 OHCI Controller',
# '1106:3044',
# '46',
# 'e800',
# 'firewire_ohci',
# 'firewire_ohci'
sub card_data {
	eval $start if $b_log;
	my (@rows,@data);
	my ($j) = (0);
	foreach (@pci){
		my $num = 1;
		my @row = @$_;
		#print "$row[0] $row[3]\n";
		if ($row[0] eq 'network' || $row[0] eq 'ethernet' ){
			#print "$row[0] $row[3]\n";
			$j = scalar @rows;
			my $driver = $row[8];
			$driver ||= 'N/A';
			@data = (
			{
			$num++ . "#Card" => $row[4],
			$num++ . "#driver" => $driver,
			},
			);
			@rows = (@rows,@data);
			
			if ($extra > 0){
				if ($row[8]){
					my $version = main::get_module_version($row[8]);
					$version ||= 'N/A';
					$rows[$j]{$num++ . "#v"} = $version;
				}
				$rows[$j]{$num++ . "#port"} = "$row[7]";
				$rows[$j]{$num++ . "#bus ID"} = "$row[2].$row[3]";
			}
			if ($extra > 1){
				$rows[$j]{$num++ . "#chip ID"} = $row[5];
			}
		}
		#print "$row[0]\n";
	}
	#my $ref = $pci[-1];
	#print $$ref[0],"\n";
	eval $end if $b_log;
	return @rows;
}
}

## Get ProcessData 
{
package ProcessData;

sub get {
	eval $start if $b_log;
	my (@processes,@rows);
	if ($show{'ps-cpu'}){
		@rows = cpu_processes();
		@processes = (@processes,@rows);
	}
	if ($show{'ps-mem'}){
		@rows = mem_processes();
		@processes = (@processes,@rows);
	}
	return @processes;
	eval $end if $b_log;
}
sub cpu_processes {
	eval $start if $b_log;
	my ($j,$num,$cpu,$cpu_mem,$mem) = (0,0,'','','');
	my (@processes);
	my $count = ($b_irc)? 5: $ps_count;
	my @rows = sort { 
		my @a = split(/\s+/,$a); 
		my @b = split(/\s+/,$b); 
		$b[2] <=> $a[2] } @ps_aux;
	@rows = splice @rows,0,$count;
	$cpu_mem = ' - Memory: MB / % used' if $extra > 0;
	$j = scalar @rows;
	my $throttled = throttled($ps_count,$count,$j);
	my @data = (
	{$num++ . "#CPU  % used - Command - pid$cpu_mem - top" => "$count$throttled",},
	);
	@processes = (@processes,@data);
	my $i = 1;
	foreach (@rows){
		$num = 1;
		$j = scalar @processes;
		my @row = split /\s+/, $_;
		my @command = process_starter(scalar @row, $row[10],$row[11]);
		@data = (
		{
		$num++ . "#" . $i++ => '',
		$num++ . "#cpu" => $row[2] . '%',
		$num++ . "#command" => $command[0],
		},
		);
		@processes = (@processes,@data);
		if ($command[1]) {
			$processes[$j]{$num++ . "#started by"} = $command[1];
		}
		$processes[$j]{$num++ . "#pid"} = $row[1];
		if ($extra > 0){
			my $decimals = ($row[5]/1024 > 10 ) ? 1 : 2;
			$mem = (defined $row[5]) ? sprintf( "%.${decimals}f", $row[5]/1024 ) . 'MB' : 'N/A';
			$mem .= ' (' . $row[3] . '%)';
			$processes[$j]{$num++ . "#mem"} = $mem;
		}
		#print Data::Dumper::Dumper \@processes, "i: $i; j: $j ";
	}
	eval $end if $b_log;
	return @processes;
}
sub mem_processes {
	eval $start if $b_log;
	my ($j,$num,$cpu,$cpu_mem,$mem) = (0,0,'','','');
	my (@data,@processes,$memory);
	my $count = ($b_irc)? 5: $ps_count;
	my @rows = sort { 
		my @a = split(/\s+/,$a); 
		my @b = split(/\s+/,$b); 
		$b[5] <=> $a[5] } @ps_aux;
	@rows = splice @rows,0,$count;
	if (!$show{'info'}){
		$memory = main::get_memory_data();
		$memory ||= 'N/A';
		@data = (
		{$num++ . "#System Memory" => '',
		$num++ . "#Used/Total" => $memory,},
		);
		@processes = (@processes,@data);
	}
	$cpu_mem = ' - CPU: % used' if $extra > 0;
	$j = scalar @rows;
	my $throttled = throttled($ps_count,$count,$j);
	@data = (
	{$num++ . "#Memory MB/% used - Command - pid$cpu_mem - top" => "$count$throttled",},
	);
	@processes = (@processes,@data);
	my $i = 1;
	foreach (@rows){
		$num = 1;
		$j = scalar @processes;
		my @row = split /\s+/, $_;
		my $decimals = ($row[5]/1024 > 10 ) ? 1 : 2;
		$mem = ($row[5]) ? sprintf( "%.${decimals}f", $row[5]/1024 ) . ' MB' : 'N/A';
		my @command = process_starter(scalar @row, $row[10],$row[11]);
		if ($extra > 0){
			$mem .= " (" . $row[2] . "%)"; 
		}
		@data = (
		{
		$num++ . "#" . $i++ => '',
		$num++ . "#mem" => $mem,
		$num++ . "#command" => $command[0],
		},
		);
		@processes = (@processes,@data);
		if ($command[1]) {
			$processes[$j]{$num++ . "#started by"} = $command[1];
		}
		$processes[$j]{$num++ . "#pid"} = $row[1];
		if ($extra > 0){
			$cpu = $row[3] . '%';
			$processes[$j]{$num++ . "#cpu"} = $cpu;
		}
		#print Data::Dumper::Dumper \@processes, "i: $i; j: $j ";
	}
	eval $end if $b_log;
	return @processes;
}
sub process_starter {
	my ($count, $row10, $row11) = @_;
	my (@return);
	# note: [migration/0] would clear with a simple basename
	if ($count > 11 && $row11 =~ /^\//){
		$row11 =~ s/^\/.*\///;
		$return[0] = $row11;
		$row10 =~ s/^\/.*\///;
		$return[1] = $row10;
	}
	else {
		$row10 =~ s/^\/.*\///;
		$return[0] = $row10;
		$return[1] = '';
	}
	return @return;
}
sub throttled {
	my ($ps_count,$count,$j) = @_;
	my $throttled = '';
	if ($count > $j){
		$throttled = " (only $j processes)";
	}
	elsif ($count < $ps_count){
		$throttled = " (throttled from $ps_count)";
	}
	return $throttled;
}
}

## Get RepoData
{
package RepoData;
my $num = 0;
my (@content,@data,@data2,@data3,@repos,@repo_files,@dbg_files,$working,$debugger_dir);

sub get {
	my ($debugger_dir) = @_;
	if ($bsd_type){
		get_repos_bsd();
	}
	else {
		get_repos_linux();
	}
	if ($debugger_dir){
		return @dbg_files;
	}
	else {
		if (!@repos){
			my $pm = (!$bsd_type) ? 'package manager': 'OS type';
			@data = (
			{$num++ . '#Alert' => "No repo data detected. Does $self_name support your $pm?"},
			);
			@repos = (@data);
		}
		return @repos;
	}
}

sub get_repos_linux {
	eval $start if $b_log;
	my $apk = '/etc/apk/repositories';
	my $apt = '/etc/apt/sources.list';
	my $pacman = '/etc/pacman.conf';
	my $slackpkg = '/etc/slackpkg/mirrors';
	my $slackpkg_plus = '/etc/slackpkg/slackpkgplus.conf';
	
	# apt - debian, buntus, also sometimes some yum/rpm repos may create 
	# apt repos here as well
	if (-f $apt || -d "$apt.d"){
		@repo_files = </etc/apt/sources.list.d/*.list>;
		push @repo_files, $apt;
		main::log_data('apt repo files: ' . join('; ', @repo_files) ) if $b_log;
		foreach ( sort @repo_files){
			repo_builder($_,'apt','^\s*deb') if -r $_;
		}
	}
	# pacman: Arch and derived
	if (-f $pacman){
		@repo_files =  main::reader($pacman,'strip');
		@repo_files = grep {/^\s*Include/i} @repo_files if @repo_files;
		@repo_files = map {
			my @working = split( /\s+=\s+/, $_); 
			$working[1];
		} @repo_files if @repo_files;
		@repo_files = sort(@repo_files);
		@repo_files = main::uniq(@repo_files);
		foreach (sort @repo_files){
			if (-f $_){
				repo_builder($_,'pacman','^[[:space:]]*Server','\s*=\s*',1);
			}
			else {
				push @dbg_files, $_ if $debugger_dir;
				@data = (
				{$num++ . "#File listed in" => $pacman},
				[("$_ does not seem to exist.")],
				);
				@repos = (@repos,@data);
			}
		}
	}
	# slackware
	elsif (-f $slackpkg || -f $slackpkg_plus){
		if (-f $slackpkg){
			repo_builder($slackpkg,'slackpkg','^[[:space:]]*#*');
		}
		if (-f $slackpkg_plus){
			push @dbg_files, $slackpkg_plus if $debugger_dir;
			@data =  main::reader($slackpkg_plus,'strip');
			my (@repoplus_list,$active_repos);
			foreach my $row (@data){
				@data2 = split /\s*=\s*/, $row;
				@data2 = map { $_ =~ s/^\s+|\s+$//g ; $_ } @data2;
				last if $data2[0] =~ /^SLACKPKGPLUS/ && $data2[1] eq 'off';
				# REPOPLUS=( slackpkgplus restricted alienbob ktown multilib slacky)
				if ($data2[0] =~ /^REPOPLUS/){
					@repoplus_list = split /\s+/, $data2[1];
					@repoplus_list = map {s/\(|\)//g; $_} @repoplus_list;
					$active_repos = join ('|',@repoplus_list);
					
				}
				# MIRRORPLUS['multilib']=http://taper.alienbase.nl/mirrors/people/alien/multilib/14.1/
				if ($active_repos && $data2[0] =~ /^MIRRORPLUS/){
					$data2[0] =~ s/MIRRORPLUS\[\'|\'\]//g;
					if ($data2[0] =~ /$active_repos/){
						push @content,"$data2[0] ~ $data2[1]";
					}
				}
			}
			@content = ('No slackpkg+ sources found in file') if ! @content;
			@content = url_cleaner(@content);
			@data = (
			{$num++ . "#slackpkg+ sources" => $slackpkg_plus},
			[@content],
			);
			@data = url_cleaner(@data);
			@repos = (@repos,@data);
			@content = ();
		}
	}
	# Alpine linux
	elsif (-f $apk){
		repo_builder($apk,'apk','^\s*[^#]+');
	}
	# print Dumper \@repos;
	eval $end if $b_log;
}
sub get_repos_bsd {
	eval $start if $b_log;
	my $bsd_pkg = '/usr/local/etc/pkg/repos/';
	my $freebsd = '/etc/freebsd-update.conf';
	my $freebsd_pkg = '/etc/pkg/FreeBSD.conf';
	my $netbsd = '/usr/pkg/etc/pkgin/repositories.conf';
	my $openbsd = '/etc/pkg.conf';
	my $portsnap =  '/etc/portsnap.conf';
	if ( -f $portsnap || -f $freebsd || -d $bsd_pkg){
		if ( -f $portsnap ) {
			repo_builder($portsnap,'portsnap','^\s*SERVERNAME','\s*=\s*',1);
		}
		if ( -f $freebsd ){
			repo_builder($freebsd,'freebsd','^\s*ServerName','\s+',1);
		}
		if ( -f $freebsd_pkg ){
			repo_builder($freebsd_pkg,'freebsd-pkg','^\s*url',':\s+',1);
		}
		if ( -d $bsd_pkg){
			@repo_files = </usr/local/etc/pkg/repos/*.conf>;
			if (@repo_files){
				my ($url);
				foreach (@repo_files){
					push @dbg_files, $_ if $debugger_dir;
					# these will be result sets separated by an empty line
					# first dump all lines that start with #
					@content =  main::reader($_,'strip');
					# then do some clean up on the lines
					@content = map { $_ =~ s/{|}|,|\*//g; } @content if @content;
					# get all rows not starting with a # and starting with a non space character
					my $url = '';
					foreach (@content){
						if (!/^\s*$/){
							my @data2 = split /\s*:\s*/, $_;
							@data2 = map { $_ =~ s/^\s+|\s+$//g; $_; } @data2;
							$url = "$data2[1]:$data2[2]" if $data2[0] eq 'url';
							#print "url:$url\n" if $url;
							if ($url && $data2[0] eq 'enabled'){
								if ($data2[1] eq 'yes'){
									push @data3, "$url"
								}
								$url = '';
							}
						}
					}
					@data3 = url_cleaner(@data3);
					@data3 = ('No pkg enabled servers found in file') if ! @data3;
					@data = (
					{$num++ . "#BSD pkg enabled servers" => $_},
					[@data3],
					);
					@repos = (@repos,@data);
					@data3 = ();
				}
			}
		}
	}
	elsif (-f $openbsd) {
		repo_builder($openbsd,'openbsd','^installpath','\s*=\s*',1);
	}
	elsif (-f $netbsd){
		# not an empty row, and not a row starting with #
		repo_builder($netbsd,'netbsd','^\s*[^#]+$');
	}
	
	eval $start if $b_log;
}
sub repo_builder {
	my ($file,$type,$search,$split,$count) = @_;
	my ($missing,$key);
	my %unfound = (
	'apk' => 'No repos found in this file',
	'apt' => 'No repos found in this file',
	'bsd-package' => 'No package servers found in this file',
	'pacman' => 'No repos found in this file',
	'portsnap' => 'No ports servers found in this file',
	'freebsd' => 'No update servers found in this file',
	'freebsd-pkg' => 'No default pkg server found in this file',
	'openbsd' => 'No pkg mirrors found in this file',
	'netbsd' => 'No pkg servers found in this file',
	'slackpkg' => 'No sources found in this file',
	'slackpkg-plus' => 'No sources found in this file',
	);
	$missing = $unfound{$type};
	my %keys = (
	'apk' => 'APK repo',
	'apt' => 'Active apt sources in',
	'bsd-package' => 'BSD pkg server',
	'pacman' => 'Active Pacman repo servers in',
	'freebsd' => 'FreeBSD update server',
	'freebsd-pkg' => 'FreeBSD default pkg server',
	'portsnap' => 'BSD ports server',
	'openbsd' => 'OpenBSD pkg mirror',
	'netbsd' => 'NetBSD pkg servers',
	'slackpkg' => 'slackpkg sources',
	'slackpkg-plus' => 'slackpkg+ sources',
	);
	$key = $keys{$type};

	push @dbg_files, $file if $debugger_dir;
	@content =  main::reader($file);
	@content = grep {/$search/i && !/^\s*$/} @content if @content;
	@content = data_cleaner(@content);
	if ($split){
		@content = map { 
		my @inner = split (/$split/, $_);
		$inner[$count];
		} @content;
	}
	@content = url_cleaner(@content);
	@content = ($missing) if ! @content;
	@data = (
	{$num++ . "#$key" => $file},
	[@content],
	);
	@repos = (@repos,@data);
	@content = ();
}
sub data_cleaner {
	my (@content) = @_;
	# basics: trim white space, get rid of double spaces
	@content = map { $_ =~ s/^\s+|\s+$//g; $_ =~ s/\s\s+/ /g; $_} @content;
	return @content;
}
# clean if irc
sub url_cleaner {
	my (@content) = @_;
	@content = map { $_ =~ s/:\//: \//; $_} @content if $b_irc;
	return @content;
}
sub file_path {
	my ($filename,$dir) = @_;
	my ($working);
	$working = $filename;
	$working =~ s/^\///;
	$working =~ s/\//-/g;
	$working = "$dir/file-repo-$working.txt";
	return $working;
}
}

# # check? /var/run/nologin for bsds?
sub get_runlevel_data {
	eval $start if $b_log;
	my $runlevel = '';
	if ( my $program = check_program('runlevel')){
		$runlevel = (grabber($program))[0];
		$runlevel =~ s/[^\d]//g;
		#print_line($runlevel . ";;");
	}
	eval $end if $b_log;
	return $runlevel;
}
# note: it appears that at least as of 2014-01-13, /etc/inittab is going 
# to be used for default runlevel in upstart/sysvinit. systemd default is 
# not always set so check to see if it's linked.
sub get_runlevel_default {
	eval $start if $b_log;
	my @data;
	my $default = '';
	my $b_systemd = 0;
	my $inittab = '/etc/inittab';
	my $systemd = '/etc/systemd/system/default.target';
	my $upstart = '/etc/init/rc-sysinit.conf';
	# note: systemd systems do not necessarily have this link created
	if ( -e $systemd){
		$default = readlink($systemd);
		$default =~ s/.*\/// if $default; 
		$b_systemd = 1;
	}
	# http://askubuntu.com/questions/86483/how-can-i-see-or-change-default-run-level
	# note that technically default can be changed at boot but for inxi purposes 
	# that does not matter, we just want to know the system default
	elsif ( -e $upstart){
		# env DEFAULT_RUNLEVEL=2
		@data = reader($upstart);
		$default = awk(\@data,'^env\s+DEFAULT_RUNLEVEL',2,'=');
	}
	# handle weird cases where null but inittab exists
	if (!$default && -e $inittab ){
		@data = reader($inittab);
		$default = awk(\@data,'^id.*initdefault',2,':');
	}
	eval $end if $b_log;
	return $default;
}

#### -------------------------------------------------------------------
#### SPECIAL DATA HANDLERS - INITIALIZE DATA VALUES
#### -------------------------------------------------------------------
sub pci_cleaner {
	my ($string) = @_;
	$string =~ s/\[[^\]]+\]$|compatible\scontroller|device|controller|multimedia|\([^)]+\)//g;
	return $string;
}

sub set_pci_data {
	eval $start if $b_log;
	if ( $show{'audio'} || $show{'graphic'} || $show{'network'} ){
		if (!$bsd_type){
			if ($alerts{'lspci'}{'action'} eq 'use' ){
				set_lspci_data();
			}
		}
		else {
			if ($alerts{'pciconf'}{'action'} eq 'use'){
				set_pciconf_data();
			}
		}
	}
	eval $end if $b_log;
}

sub set_lspci_data {
	eval $start if $b_log;
	my ($busid,$busid_nu,$port,$driver,$modules,$device,$device_id,$rev,
	$type,$type_id,@temp);
	# my @pcis = grabber('lspci -nnv','\n','strip');
	my @pcis = split /\n/, qx(lspci -nnv);
	#print scalar @pcis;
	@pcis = map {$_ =~ s/^\s+//; $_} @pcis;
	foreach (@pcis){
		#print "$_\n";
		if ($device){
			if ($_ =~ /^\s*$/) {
				@temp = ($type,$type_id,$busid,$busid_nu,$device,$device_id,$rev,$port,$driver,$modules);
				@pci = (@pci,[@temp]);
				$device = '';
				#print "$busid $device_id r:$rev p: $port\n$type\n$device\n";
			}
			elsif ($_ =~ /^I\/O\sports/){
				$port = (split /\s+/,$_)[3];
				#print "p:$port\n";
			}
			elsif ($_ =~ /^Kernel\sdriver\sin\suse/){
				$driver = (split /:\s*/,$_)[1];
			}
			elsif ($_ =~ /^Kernel\smodules/i){
				$modules = (split /:\s*/,$_)[1];
			}
		}
		elsif ($_ =~ /^([0-9]{2}:[0-9]{2})[.:]([0-9]+)\s(.*)\s\[([0-9a-f]{4}:[0-9a-f]{4})\](\s\(rev\s([^\)]+)\))?/){
			$busid = $1;
			$busid_nu = $2;
			my @working = split /:\s+/, $3;
			$device = $working[1];
			$type = $working[0];
			$device_id = $4;
			$rev = ($6)?$6 : '';
			$device = cleaner($device);
			$working[0] =~ /\[([^\]]+)\]$/;
			$type_id = $1;
			$type = pci_cleaner($type);
			$type =~ s/\s+$//;
			$type = lc($type);
			$port = '';
			$driver = '';
			$modules = '';
		}
	}
	if ($device && $busid){
		@temp = ($type,$type_id,$busid,$busid_nu,$device,$device_id,$rev,$port,$driver,$modules);
		@pci = (@pci,[@temp]);
		$device = '';
	}
	if ($test[2]){
		print Dumper \@pci;
	}
	eval $end if $b_log;
}

sub set_pciconf_data {
	eval $start if $b_log;
	
	eval $end if $b_log;
}

sub set_ps_aux {
	eval $start if $b_log;
	@ps_aux = split "\n",qx(ps aux);;
	shift @ps_aux; # get rid of header row
	$_=lc for @ps_aux; # this is a super fast way to set to lower
	# this is for testing for the presence of the command
	@ps_cmd = map {
		my @split = split /\s+/, $_;
		# slice out 10th to last elements of ps aux rows
		my $final = $#split;
		# some stuff has a lot of data, chrome for example
		$final = ($final > 12) ? 12 : $final;
		@split = @split[10 .. $final ];
		join " ", @split;
	} @ps_aux;
	eval $end if $b_log;
}

#### -------------------------------------------------------------------
#### SPECIAL DATA HANDLERS - UTILITIES FOR DATA LINES
#### -------------------------------------------------------------------

sub get_gcc_data {
	eval $start if $b_log;
	my ($gcc,@data,@gccs);
	# NOTE: We can't use program_version because we don't yet know where
	# the version number is
	if (my $program = check_program('gcc') ){
		@data = grabber("$program --version 2>/dev/null");
		$gcc = awk(\@data,'^gcc');
	}
	if ($gcc){
		# strip out: gcc (Debian 6.3.0-18) 6.3.0 20170516
		# gcc (GCC) 4.2.2 20070831 prerelease [FreeBSD]
		$gcc =~ s/\([^\)]*\)//g;
		$gcc = get_piece($gcc,2);
	}
	
	if ($extra > 1){
		# glob /usr/bin for gccs, strip out all non numeric values
		@gccs = grep { s/.*\/gcc-[^0-9]+.*|.*\/gcc-// } </usr/bin/gcc-*>;
		@gccs = grep { /\S/ } @gccs; # remove empty values
	}
	unshift @gccs, $gcc;
	log_data("gccs: " . join '; ', @gccs) if $b_log;
	eval $end if $b_log;
	return @gccs;
}
sub get_hostname {
	eval $start if $b_log;
	my $hostname = '';
	if ( $ENV{'HOSTNAME'} ){
		$hostname = $ENV{'HOSTNAME'};
	}
	else {
		$hostname = hostname;
	}
	$hostname ||= 'N/A';
	eval $end if $b_log;
	return $hostname;
}
sub get_kernel_data {
	eval $start if $b_log;
	my ($kernel,$ksplice) = ('','');
	# Linux; yawn; 4.9.0-3.1-liquorix-686-pae; #1 ZEN SMP PREEMPT liquorix 4.9-4 (2017-01-14); i686
	# FreeBSD; siwi.pair.com; 8.2-STABLE; FreeBSD 8.2-STABLE #0: Tue May 31 14:36:14 EDT 2016     erik5@iddhi.pair.com:/usr/obj/usr/src/sys/82PAIRx-AMD64; amd64
	my @uname = uname();
	if (@uname){
		$kernel = $uname[2];
		if (check_program('uptrack-uname') && $kernel){
			$ksplice = qx(uptrack-uname -rm);
			$ksplice = trimmer($ksplice);
			$kernel = ($ksplice) ? $ksplice . ' (ksplice)' : $kernel;
		}
		$kernel .= ' ' . $uname[scalar @uname - 1];
		$kernel = ($bsd_type) ? $uname[0] . ' ' . $kernel : $kernel;
	}
	
	$kernel ||= 'N/A';
	log_data("kernel: $kernel ksplice: $ksplice") if $b_log;
	eval $end if $b_log;
	return $kernel;
}
sub get_kernel_bits {
	eval $start if $b_log;
	my $bits = '';
	my @uname = uname();
	if (@uname){
		$bits = $uname[scalar @uname - 1];
		$bits = ($bits =~ /64/ ) ? 64 : 32;
	}
	$bits ||= 'N/A';
	eval $end if $b_log;
	return $bits;
}
sub get_module_version {
	eval $start if $b_log;
	my ($module) = @_;
	return if ! $module;
	my ($version);
	if (my $path = check_program('modinfo')){
		my @data = grabber("$path $module");
		$version = awk(\@data,'^version',2,':\s+');
	}
	$version ||= '';
	eval $end if $b_log;
	return $version;
}
sub get_self_version {
	eval $start if $b_log;
	my $patch = $self_patch;
	if ( $patch ne '' ){
		# for cases where it was for example: 00-b1 clean to -b1
		$patch =~ s/^[0]+-?//;
		$patch = "-$patch";
	}
	eval $end if $b_log;
	return $self_version . $patch;
}
sub get_shell_data {
	eval $start if $b_log;
	my ($ppid) = @_;
	my $shell = qx(ps -p $ppid -o comm= 2>/dev/null);
	chomp($shell);
	if ($shell){
		# when run in debugger subshell, would return sh as shell,
		# and parent as perl, that is, pinxi itself, which is actually right.
		if ($shell eq 'sh' && $shell ne $ENV{'SHELL'}){
			$shell = $ENV{'SHELL'};
			$shell =~ s/^.*\///;
		}
		# sh because -v/--version doesn't work on it, ksh because
		# it takes too much work to handle all the variants
		if ( $shell ne 'sh' && $shell ne 'ksh' ) {
			@app = main::program_values(lc($shell));
			if ($app[0]){
				$client{'version'} = main::program_version($shell,$app[0],$app[1],$app[2]);
			}
			# guess that it's two and --version
			else {
				$client{'version'} = main::program_version($shell,2,'');
			}
			$client{'version'} =~ s/(\(.*|-release|-version)//;
		}
		$client{'name'} = lc($shell);
		$client{'name-print'} = $shell;
	}
	else {
		$client{'name'} = 'shell';
		$client{'name-print'} = 'Unknown Shell';
	}
	eval $end if $b_log;
}
sub get_shell_source {
	eval $start if $b_log;
	my (@data);
	my ($script_parent,$shell_parent) = ('','');
	my $ppid = getppid();
	$script_parent = get_start_parent($ppid);
	if ($script_parent){
		$shell_parent = get_shell_parent($script_parent);
		# no idea why have to do script_parent action twice in su case, but you do.
		if ( $shell_parent && $shell_parent eq 'su' ){
			$script_parent = get_start_parent($script_parent);
			$script_parent = get_start_parent($script_parent);
			$shell_parent = get_shell_parent($script_parent);
		}
	}
	log_data("parents: script: $script_parent shell: $shell_parent") if $b_log;
	eval $end if $b_log;
	return $shell_parent;
}
# utilities for get_shell_source 
# arg: 1 - parent id
sub get_start_parent {
	my ($parent) = @_;
	my @data = grabber("ps -j -fp $parent");
	my $script_parent = awk(\@data,"$parent",3,'\s+');
	return $script_parent;
}
# arg: 1 - parent id
sub get_shell_parent {
	my ($parent) = @_;
	my @data = grabber("ps -j -p $parent");
	my $shell_parent = awk(\@data, "$parent",-1,'\s+',);
	return $shell_parent;
}

sub get_tty_console_irc {
	eval $start if $b_log;
	my $ppid = getppid();
	my $tty = awk(\@ps_aux,".*$ppid.*$client{'name'}",7,'\s+');
	$tty =~ s/^[^[0-9]+// if $tty;
	$tty = '' if ! defined $tty;
	log_data("conole-irc-tty:$tty") if $b_log;
	eval $end if $b_log;
	return $tty;
}
sub get_tty_number {
	eval $start if $b_log;
	my $tty = POSIX::ttyname(1);
	#variants: /dev/pts/1 /dev/tty1 /dev/pts/5 /dev/ttyp2 /dev/pts/1
	$tty =~ s/.*\/[^0-9]*//g if defined $tty;
	$tty = '' if ! defined $tty;
	log_data("tty:$tty") if $b_log;
	eval $end if $b_log;
	return $tty;
}

# 2:58PM  up 437 days,  8:18, 3 users, load averages: 2.03, 1.72, 1.77
sub get_uptime {
	eval $start if $b_log;
	my $uptime = '';
	if (check_program('uptime')){
		$uptime = qx(uptime);
		$uptime = trimmer($uptime);
		$uptime = (split /,\s+/, $uptime)[0];
		my @temp = split /\s+/, $uptime;
		# units only start with days, not hours
		$uptime = ($temp[3]) ? $temp[2] . ' ' . $temp[3] : $temp[2];
	}
	$uptime ||= 'N/A';
	eval $end if $b_log;
	return $uptime;
}

########################################################################
#### GENERATE LINES
########################################################################

#### -------------------------------------------------------------------
#### DATA CONTROLLERS
#### -------------------------------------------------------------------

sub assign_data {
	my (%row) = @_;
	return if ! %row;
	if ($output_type eq 'screen'){
		print_data(%row);
	}
	else {
		%rows = (%rows,%row);
	}
}

sub generate_data {
	eval $start if $b_log;
	my (%row);
	set_pci_data();
	set_ps_aux() if ! @ps_aux;
	if ($test[3]){
		%row = generate_test_data();
		assign_data(%row);
		return 1;
	}
	if ( $show{'short'} ){
		%row = generate_short_data();
		assign_data(%row);
	}
	else {
		if ( $show{'system'} ){
			%row = generate_system_data();
			assign_data(%row);
		}
		if ( $show{'machine'} ){
			%row = generate_machine_data();
			assign_data(%row);
		}
		if ( $show{'battery'} ){
			%row = generate_battery_data();
			assign_data(%row);
		}
		if ( $show{'cpu'} ){
			%row = generate_cpu_data();
			assign_data(%row);
		}
		if ( $show{'memory'} ){
			%row = generate_memory_data();
			assign_data(%row);
		}
		if ( $show{'graphic'} ){
			%row = generate_graphic_data();
			assign_data(%row);
		}
		if ( $show{'audio'} ){
			%row = generate_audio_data();
			assign_data(%row);
		}
		if ( $show{'network'} ){
			%row = generate_network_data();
			assign_data(%row);
		}
		if ( $show{'disk'} ){
			%row = generate_disk_data();
			assign_data(%row);
		}
		if ( $show{'partition'} ){
			%row = generate_partition_data();
			assign_data(%row);
		}
		if ( $show{'raid'} ){
			%row = generate_raid_data();
			assign_data(%row);
		}
		if ( $show{'unmounted'} ){
			%row = generate_unmounted_data();
			assign_data(%row);
		}
		if ( $show{'sensor'} ){
			%row = generate_sensor_data();
			assign_data(%row);
		}
		if ( $show{'repo'} ){
			%row = generate_repo_data();
			assign_data(%row);
		}
		if ( $show{'process'} ){
			%row = generate_process_data();
			assign_data(%row);
		}
		if ( $show{'weather'} ){
			%row = generate_weather_data();
			assign_data(%row);
		}
		if ( $show{'info'} ){
			%row = generate_info_data();
			assign_data(%row);
		}
	}
	if ( $output_type ne 'screen' ){
		output_handler(%rows);
	}
	# log_data('cat', '/proc/mounts') if $b_log;
	# print "stub: " . (caller(0))[3] . "\n";
	eval $end if $b_log;
}

#### -------------------------------------------------------------------
#### SHORT AND DEBUG
#### -------------------------------------------------------------------

sub generate_short_data {
	eval $start if $b_log;
	my $num = 0;
	my $kernel_os = ($bsd_type) ? 'OS' : 'Kernel';
	my $client = $client{'name-print'};
	my $client_shell = ($b_irc) ? 'Client' : 'Shell';
	if ($client{'version'}){
		$client .= ' ' . $client{'version'};
	}
	my $memory = get_memory_data();
	$memory ||= 'N/A';
	my %row = (
	$prefix . '#SHORT' => [
		{
		$num++ . '#CPU' => 'N/A',
		$num++ . '#speed' => 'N/A',
		$num++ . '#' . $kernel_os => &get_kernel_data(),
		$num++ . '#Up' => &get_uptime(),
		$num++ . '#Mem' => $memory,
		$num++ . '#HD' => 'N/A',
		# could make -1 for ps aux itself, -2 for ps aux and self
		$num++ . '#Procs' => scalar @ps_aux, 
		$num++ . '#' . $client_shell => $client,
		$num++ . '#' . $self_name => &get_self_version(),
		},
	],
	);
	eval $end if $b_log;
	return %row;
}

sub generate_test_data {
	eval $start if $b_log;
	my %data = (
	$prefix++ . '#System' => [
		{
		'1#Host' => 'fred',
		'02#Kernel' => '4.9.0-3.1-liquorix-686-pae i686',
		'3#bits' => '32',
		'4#gcc' => '6.2.1',
		},
		{
		'5#Desktop' => 'Xfce 4.12.3 (Gtk 2.24.31)',
		'6#info' => 'xfce4-panel',
		'7#dm' => 'lightdm',
		'08#Distro' => 'sidux-20070102-d:1',
		},
		
	],
	$prefix++ . '#CPU' => [
		{
		"0#CPU flags" => '3dnow 3dnowext 3dnowprefetch apic clflush cmov 
		cmp_legacy cr8_legacy cx16 cx8 de eagerfpu extapic extd_apicid fpu
		fxsr fxsr_opt ht lahf_lm lbrv lm mca mce mmx mmxext msr mtrr nx pae
		pat pge pni pse pse36 rdtscp rep_good sep sse sse2 svm syscall tsc
		vme vmmcall',
		},
	],
	$prefix++ . '#Network' => [
		{
		'0#Card' => 'Realtek RTL8101/2/6E PCI Express Fast/Gigabit Ethernet controller',
		'1#driver' => 'r8169',
		'2#v' => '2.3LK-NAPI',
		'3#port' => '2000',
		'4#bus-ID' => '02:00.0',
		'5#chip-ID' => '10ec:8136 fred bob george same gus byron henry george gus fred sandy jeff',
		},
		{
		'0#IF' => 'enp2s0',
		'1#state' => 'up',
		'2#speed' => '100 Mbps',
		'3#duplex' => 'full',
		'4#mac' => '00:23:8b:cd:27:82',
		},
		{
		'0#Card' => 'Realtek RTL8187B Wireless 802.11g 54Mbps Network Adapter',
		'1#usb-ID' => '001-003',
		'2#chip-ID' => '0bda:8189',
		},
		{
		'1#IF' => 'null-if-id',
		'2#state' => 'N/A',
		'3#mac' => 'N/A',
		},
	],
	$prefix++ . '#Repos' => [
		{
		'0#Active apt sources in file' => '/etc/apt/sources.list',
		},
		[
		'deb http: //mirrors.kernel.org/debian unstable main contrib non-free',
		'deb http: //mirrors.kernel.org/debian buster main contrib non-free',
		'deb http: //www.deb-multimedia.org/ buster main non-free',
		'deb http: //deb.opera.com/opera-stable stable non-free',
		'deb http: //liquorix.net/debian unstable main',
		],
		{
		'0#Active apt sources in file' => '/etc/apt/sources.list.d/google-earth.list',
		},
		[
		'deb http: //dl.google.com/linux/earth/deb/ stable main',
		],
	],
	);
	eval $end if $b_log;
	return %data;
}

#### -------------------------------------------------------------------
#### PRIMARY
#### -------------------------------------------------------------------

sub generate_audio_data {
	eval $start if $b_log;
	my (%data);
	my $data_name = $prefix++ . '#Audio';
	my @audio = AudioData::get();
	if (@audio){
		%data = ($data_name => \@audio,);
	}
	eval $end if $b_log;
	return %data;
}

sub generate_battery_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$key1,$val1);
	my $data_name = $prefix++ . '#Battery';
	$ref = $alerts{'dmidecode'};
	if ( ( $bsd_type || $use{'dmidecode-force'} ) && $$ref{'action'} ne 'use'){
		$key1 = $$ref{'action'};
		$val1 = $$ref{$key1};
		$key1 = ucfirst($key1);
	}
	else {
		$key1 = 'Status';
		$val1 = 'under development';
	}
	
	%row = (
	$num++ . "#$key1" => $val1,
	);
	my %data = (
	$data_name => [
		\%row,
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	
	eval $end if $b_log;
	return %data;
}

sub generate_cpu_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$val1);
	my $data_name = $prefix++ . '#CPU';
	
	my %data = (
	$data_name => [
		{
		$num++ . '#Status' => 'under development',
		},
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	
	eval $end if $b_log;
	return %data;
}

sub generate_disk_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$val1);
	my $data_name = $prefix++ . '#Drives';
	
	my %data = (
	$data_name => [
		{
		$num++ . '#Status' => 'under development',
		},
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	
	eval $end if $b_log;
	return %data;
}

sub generate_graphic_data {
	eval $start if $b_log;
	my (%data);
	my (%row,$ref,$index,$val1);
	my $data_name = $prefix++ . '#Graphics';
	my @graphic = GraphicData::get();
	if (@graphic){
		%data = ($data_name => \@graphic,);
	}
	eval $end if $b_log;
	return %data;
}

sub generate_info_data {
	eval $start if $b_log;
	my $num = 0;
	my $gcc_alt = '';
	my $running_in = '';
	my $data_name = $prefix++ . '#Info';
	my (%row,$gcc,$index,$ref,$val1);
	my $client_shell = ($b_irc) ? 'Client' : 'Shell';
	my $client = $client{'name-print'};
	my @gccs = get_gcc_data();
	if (@gccs){
		$gcc = shift @gccs;
		if ($extra > 1 && @gccs){
			$gcc_alt = join '/', @gccs;
		}
	}
	$gcc ||= 'N/A';
	if ($client{'version'}){
		$client .= ' ' . $client{'version'};
	}
	if (!$b_irc && $extra > 1 ){
		if ($b_display){
			$val1 = get_shell_source();
		}
		else {
			$val1 = get_tty_number();
			$val1 = "tty $val1" if $val1 ne '';
		}
		if ($val1 eq 'login'){
			$val1 = undef;
		}
		# can be tty 0 so test for defined
		$running_in = $val1 if defined $val1;
	}
	my $memory = get_memory_data();
	$memory ||= 'N/A';
	
	my %data = (
	$data_name => [
		{
		$num++ . '#Processes' => scalar @ps_aux, 
		$num++ . '#Uptime' => &get_uptime(),
		$num++ . '#Memory' => $memory,
		},
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	if ( !$show{'display-data'} || $extra > 0 ){
		my %init = get_init_data();
		my $init_type = ($init{'init-type'}) ? $init{'init-type'}: 'N/A';
		$data{$data_name}[$index]{$num++ . '#Init'} = $init_type;
		if ($extra > 1 ){
			my $init_version = ($init{'init-version'}) ? $init{'init-version'}: 'N/A';
			$data{$data_name}[$index]{$num++ . '#v'} = $init_version;
		}
		if ($init{'runlevel'}){
			$data{$data_name}[$index]{$num++ . '#runlevel'} = $init{'runlevel'};
		}
		if ($extra > 1 ){
			if ($init{'default'}){
				my $default = ($init{'init-type'} eq 'systemd' && $init{'default'} =~ /[^0-9]$/ ) ? 'target' : 'default';
				$data{$data_name}[$index]{$num++ . "#$default"} = $init{'default'};
			}
		}
	}
	if ($extra > 0 ){
		$data{$data_name}[$index]{$num++ . '#GCC System'} = $gcc;
		if ($gcc_alt && $extra > 1 ){
			$data{$data_name}[$index]{$num++ . '#alt'} = $gcc_alt;
		}
	}
	$data{$data_name}[$index]{$num++ . '#' . $client_shell} =  $client;
	if ( $running_in ){
		$data{$data_name}[$index]{$num++ . '#running in'} = $running_in;
	}
	
	$data{$data_name}[$index]{$num++ . '#' . $self_name} = &get_self_version();
	
	eval $end if $b_log;
	return %data;
}

sub generate_machine_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$key1,$val1);
	my $data_name = $prefix++ . '#Machine';
	$ref = $alerts{'dmidecode'};
	if ( ( $bsd_type || $use{'dmidecode-force'} ) && $$ref{'action'} ne 'use'){
		$key1 = $$ref{'action'};
		$val1 = $$ref{$key1};
		$key1 = ucfirst($key1);
	}
	else {
		$key1 = 'Status';
		$val1 = 'under development';
	}
	
	%row = (
	$num++ . "#$key1" => $val1,
	);
	my %data = (
	$data_name => [
		\%row,
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	
	eval $end if $b_log;
	return %data;
}

sub generate_memory_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$key1,$val1);
	my $data_name = $prefix++ . '#Memory';
	#print Dumper \%alerts;
	$ref = $alerts{'dmidecode'};
	if ( $$ref{'action'} ne 'use'){
		$key1 = $$ref{'action'};
		$val1 = $$ref{$key1};
		$key1 = ucfirst($key1);
	}
	else {
		$key1 = 'Status';
		$val1 = 'under development';
	}
	
	%row = (
	$num++ . "#$key1" => $val1,
	);
	my %data = (
	$data_name => [
		\%row,
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	
	eval $end if $b_log;
	return %data;
}

sub generate_network_data {
	eval $start if $b_log;
	my (%data);
	my (%row,$ref,$index,$val1);
	my $data_name = $prefix++ . '#Network';
	my @network = NetworkData::get();
	if (@network){
		%data = ($data_name => \@network,);
	}
	eval $end if $b_log;
	return %data;
	
	eval $end if $b_log;
	return %data;
}

sub generate_partition_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$val1);
	my $data_name = $prefix++ . '#Partition';
	
	my %data = (
	$data_name => [
		{
		$num++ . '#Status' => 'under development',
		},
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	
	eval $end if $b_log;
	return %data;
}

sub generate_process_data {
	eval $start if $b_log;
	my (%data);
	my $data_name = $prefix++ . '#Processes';
	my @processes = ProcessData::get();
	if (@processes){
		%data = ($data_name => \@processes,);
	}
	eval $end if $b_log;
	return %data;
}

sub generate_raid_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$val1);
	my $data_name = $prefix++ . '#RAID';
	
	my %data = (
	$data_name => [
		{
		$num++ . '#Status' => 'under development',
		},
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	
	eval $end if $b_log;
	return %data;
}

sub generate_repo_data {
	eval $start if $b_log;
	my $num = 0;
	my (%data);
	my $data_name = $prefix++ . '#Repos';
	my @repos = RepoData::get();
	if (@repos){
		%data = ($data_name => \@repos,);
	}
	eval $end if $b_log;
	return %data;
}

sub generate_sensor_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$key1,$val1);
	my $data_name = $prefix++ . '#Sensors';
	
	$ref = $alerts{'sensors'};
	if ( $$ref{'action'} ne 'use'){
		$key1 = $$ref{'action'};
		$val1 = $$ref{$key1};
		$key1 = ucfirst($key1);
	}
	else {
		$key1 = 'Status';
		$val1 = 'under development';
	}
	my %data = (
	$data_name => [
		{
		$num++ . "#$key1" => $val1,
		},
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	
	eval $end if $b_log;
	return %data;
}

sub generate_system_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$val1);
	my $data_name = $prefix++ . '#System';
	my ($desktop,$desktop_info,$desktop_key) = ('','','Desktop');
	my (@desktop_data,$desktop_version);
	
	my %data = (
	$data_name => [{}],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	if ($show{'host'}){
		$data{$data_name}[$index]{$num++ . '#Host'} = &get_hostname();
	}
	$data{$data_name}[$index]{$num++ . '#Kernel'} = &get_kernel_data();
	$data{$data_name}[$index]{$num++ . '#bits'} = &get_kernel_bits;
	if ($extra > 0){
		my @compiler = get_compiler_version(); # get compiler data
		if (scalar @compiler != 2){
			@compiler = ('compiler', 'N/A');
		}
		$data{$data_name}[$index]{$num++ . "#$compiler[0]"} = $compiler[1];
	}
	# note: tty can have the value of 0 but the two tools 
	# return '' if undefined, so we test for explicit ''
	
	if ($b_display){
		my @desktop_data = DesktopEnvironment::get();
		$desktop = $desktop_data[0] if $desktop_data[0];
		$desktop_version = $desktop_data[1] if $desktop_data[1];
		$desktop .= ' ' . $desktop_version if $desktop_version;
		if ($extra > 0 && $desktop_data[3]){
			$desktop .= ' (' . $desktop_data[2];
			$desktop .= ( $desktop_data[3] ) ? ' ' . $desktop_data[3] . ')' : ')';
		}
		if ($extra > 2 && $desktop_data[4]){
			$desktop_info = $desktop_data[4];
		}
	}
	if (!$b_display || ( ! $desktop && $b_root)) {
		my $tty = get_tty_number();
		if (!$desktop){
			$desktop_info = '';
		}
		# it is defined, as ''
		if ( $tty eq '' && $client{'console-irc'}){
			$tty = get_tty_console_irc();
		}
		$desktop = "tty $tty" if $tty ne '';
		$desktop_key = 'Console';
	}
	$desktop ||= 'N/A';
	$data{$data_name}[$index]{$num++ . "#$desktop_key"} = $desktop;
	if ($extra > 2){
		if ($desktop_info){
			$data{$data_name}[$index]{$num++ . '#info'} = $desktop_info;
		}
	}
	if ($extra > 1){
		my $dms = get_display_manager();
		$dms ||= 'N/A';
		$data{$data_name}[$index]{$num++ . '#dm'} = $dms;
	}
	my $distro_key = ($bsd_type) ? 'OS': 'Distro' ;
	my $distro = DistroData::get();
	$distro ||= 'N/A';
	$data{$data_name}[$index]{$num++ . "#$distro_key"} = $distro;
	
	eval $end if $b_log;
	return %data;
}

sub generate_unmounted_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$val1);
	my $data_name = $prefix++ . '#Unmounted';
	
	my %data = (
	$data_name => [
		{
		$num++ . '#Status' => 'under development',
		},
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	
	eval $end if $b_log;
	return %data;
}
sub generate_weather_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$val1);
	my $data_name = $prefix++ . '#Weather';
	
	my %data = (
	$data_name => [
		{
		$num++ . '#Status' => 'under development',
		},
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	
	eval $end if $b_log;
	return %data;
}

#######################################################################
#### LAUNCH
########################################################################

main(); ## From the End comes the Beginning

## note: this EOF is needed for smxi handling, this is what triggers the full download ok
###**EOF**###
