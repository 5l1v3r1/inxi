#!/usr/bin/env perl
## INXI INFO ##
my $self_name='pinxi';
my $self_version='2.9.00';
my $self_date='2017-12-20';
my $self_patch='035-p';

## infobash: Copyright (C) 2005-2007  Michiel de Boer a.k.a. locsmif
## inxi: Copyright (C) 2008-2017 Harald Hope
##       Additional features (C) Scott Rogers - kde, cpu info
## Further fixes (listed as known): Horst Tritremmel <hjt at sidux.com>
## Steven Barrett (aka: damentz) - usb audio patch; swap percent used patch
## Jarett.Stevens - dmidecode -M patch for older systems with the /sys
##
## License: GNU GPL v3 or greater
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## If you don't understand what Free Software is, please read (or reread)
## this page: http://www.gnu.org/philosophy/free-sw.html

use strict;
use warnings;
# use diagnostics;
use 5.008;

use Cwd; # qw(abs_path);
# use Data::Dump qw(dump); # damn, not in core modules
use Data::Dumper qw(Dumper); # print_r
use File::Basename;
use File::Find;
# use Getopt::Long qw(GetOptionsFromArray); # :config no_ignore_case bundling_values
use Getopt::Long qw(GetOptions);
# Note: default auto_abbrev is enabled, that's fine
Getopt::Long::Configure ('bundling', 'no_ignore_case', 
'no_getopt_compat', 'no_auto_abbrev','pass_through');
use Net::FTP;
# use Path::Class; # maybe use, maybe not, for ls /sys
use POSIX qw(uname strftime);
use Sys::Hostname;
use Term::ANSIColor;
# use feature qw(state);

### INITIALIZE VARIABLES ###

## Self data
my ($self_config_dir, $self_data_dir, $self_path);

## Debuggers
my $debug=0;
my ($fh_l,$fh_c,$fh_j,$fh_x); # log, csv, json, xml file handles.
my $log_file;
my $end='log_data("fe", (caller(1))[3], "");';
my $start='log_data("fs", (caller(1))[3], @_);';

## Hashes
my ( %colors, %dl, %files, %client, %sep, %size, %show, 
%system_files, %test );

# we only want to use HTTP::Tiny if it's present in user system.
# It is NOT part of core modules.
$dl{'tiny'} = 1;
eval "use HTTP::Tiny"; # if not found, return has error messages etc
#print $@ . "\n";
if ( $@ ) {
	$dl{'tiny'} = 0;
}
#print $dl{'tiny'} . "\n";
#my $opt_parser = Getopt::Long::Parser->new;

## Booleans
my $b_console_irc = 0;
my $b_display = 0;
my $b_force_dmidecode = 0;
my $b_irc = 0;
my $b_log = 0;
my $b_log_colors = 0;
my $b_log_full = 0;
my $b_root = 0;
my $b_running_in_display = 0;
my $b_update = 1;
my $b_weather = 1;

## System
my $bsd_type = '';
my $cpu_sleep = 0.3;
my $dl_timeout = 4;
my $os = '';
my $ps_count = 5;
my $sensors_cpu_nu = 0;

## Tools
my $ftp_alt;

## Output
my $filter_string = '<filter>';
my $line1 = "----------------------------------------------------------------------\n";
my $line2 = "======================================================================\n";
my $line3 = "----------------------------------------\n";
my $output_type = 'print-line';
# These two determine separators in single line output, to force irc clients 
# not to break off sections

$sep{'s-1'}='~';
$sep{'s-2'}=' ';
# these will assign a separator to non irc states. Important! Using ':' can 
# trigger stupid emoticon
# behaviors in output on IRC, so do not use those.
$sep{'irc'}='';
$sep{'console'}=':';

$show{'extra'}=0; # supported values: 0-3
$show{'host'} = 1;

$size{'console'} = 115;
# Default indentation level. NOTE: actual indent is 1 greater to allow for 
# spacing
$size{'indent'} = 10;
$size{'inner'}=0; # for width minus $indent
$size{'irc'} = 130;
$size{'max'}=0;
$size{'no-display'} = 130;

# these will be set dynamically in set_display_width()
$size{'term'}=80;
$size{'term-lines'}=100;

## debug temp tools
$client{'test-konvi'} = 0;


########################################################################
#### STARTUP
########################################################################

#### -------------------------------------------------------------------
#### MAIN
#### -------------------------------------------------------------------



sub main {
# 	print Dumper \@ARGV;
	initialize();
	# https://userbase.kde.org/Konversation/Scripts/Scripting_guide
	if ($client{'test-konvi'}){
		$client{'dserver'} = shift @ARGV;
		$client{'dtarget'} = shift @ARGV;
	}
	get_options();
	set_debugger(); # right after so it's set
	# generate_data('fred', 'gus', 'sam');
	# print download_file('stdout','https://') . "\n";
	generate_data();
	cleanup();
	
}

#### -------------------------------------------------------------------
#### INITIALIZE
#### -------------------------------------------------------------------

sub initialize {
	set_os();
	set_path();
	set_user_paths();
	set_basics();
	system_files('set');
	set_configs();
	set_downloader();
	set_display_width('live');
}
sub set_basics {
	### LOCALIZATION - DO NOT CHANGE! ###
	# set to default LANG to avoid locales errors with , or .
	# Make sure every program speaks English.
	$ENV{'LANG'}='C';
	$ENV{'LC_ALL'}='C';
	# remember, perl uses the opposite t/f return as shell!!!
	if ( system('tty>/dev/null') ) {
		$b_irc=1;
	}
	# print "birc: $b_irc\n";
	if ( $ENV{'DISPLAY'} ){
		$b_display=1;
	}
	if ( $ENV{'HOME'} eq '/root' ){
		$b_root=1;
	}
	# tiny has been set above via test for module
	$dl{'dl'} = 'curl';
	$dl{'curl'} = 1;
	$dl{'wget'} = 1;
	$dl{'fetch'} = 1;
	$client{'dcop'} = '';
	$client{'qdbus'} = '';
	$client{'konvi'} = 0;
}

sub set_configs {
	my ($file, $key, $val);
	my @config_files = (
	qq(/etc/$self_name.conf), 
	qq($self_config_dir/$self_name.conf)
	);
	# Config files should be passed in an array as a param to this function.
	# Default intended use: global @CONFIGS;
	foreach $file (@config_files) {
		next unless open (CONFIG, "$file");
		while (<CONFIG>) {
			chomp;
			s/#.*//;
			s/^\s+//;
			s/\s+$//;
			s/'//g;
			s/true/1/; # switch to 1/0 perl boolean
			s/false/0/; # switch to 1/0 perl boolean
			next unless length;
			($key, $val) = split(/\s*=\s*/, $_, 2);
			set_config($key,$val);
			# print "f: $file key: $key val: $val\n";
		}
		
	}
}
# args: 0: key; 1: value
sub set_config {
	my ($key,$val) = @_;
	for ($key){
		if (/^B_ALLOW_UPDATE$/) {$b_update = $val}
		elsif (/^B_ALLOW_WEATHER$/) {$b_weather = $val}
		elsif (/^CPU_SLEEP$/) {$cpu_sleep = $val}
		elsif (/^DL_TIMEOUT$/) {$dl_timeout = $val}
		elsif (/^DOWNLOADER$/) {
		if ($val =~ /^(curl|fetch|ftp|perl|wget)$/){
			# this dumps all the other data and resets %dl for only the
			# desired downloader.
			$val = set_perl_downloader($val);
			%dl = ('dl' => $val, $val => 1);
		}}
		elsif (/^FILTER_STRING$/) {$filter_string = $val}
		elsif (/^PS_COUNT$/) {$ps_count = $val}
		elsif (/^SENSORS_CPU_NO$/) {$sensors_cpu_nu = $val}
		# layout
		elsif (/^CONSOLE_COLOR_SCHEME$/) {$colors{'console'} = $val}
		elsif (/^IRC_CONS_COLOR_SCHEME$/) {$colors{'console-irc'} = $val}
		elsif (/^IRC_X_TERM_COLOR_SCHEME$/) {$colors{'irc-x-term'} = $val}
		elsif (/^IRC_COLOR_SCHEME$/) {$colors{'irc'} = $val}
		elsif (/^VIRT_TERM_COLOR_SCHEME$/) {$colors{'virt-term'} = $val}
		elsif (/^SEP1$/) {$sep{'s-1'} = $val}
		elsif (/^SEP2$/) {$sep{'s-2'} = $val}
		elsif (/^SEP3_IRC$/) {$sep{'irc'} = $val}
		elsif (/^SEP3_CONSOLE$/) {$sep{'console'} = $val}
		# size
		elsif (/^COLS_MAX_CONSOLE$/) {$size{'console'} = $val}
		elsif (/^COLS_MAX_IRC$/) {$size{'irc'} = $val}
		elsif (/^COLS_MAX_NO_DISPLAY$/) {$size{'no-display'} = $val}
	}
	#  print "mc: key: $key val: $val\n";
	# print Dumper (keys %size) . "\n";
}

# args: $1 - default OR override default cols max integer count
sub set_display_width {
	my ($width_override)=@_;
	
	if ( $width_override eq 'live' ){
		## sometimes tput will trigger an error (mageia) if irc client
		if ( ! $b_irc ){
			if ( check_program('tput') ) {
				chomp($size{'term'}=qx/tput cols/);
				chomp($size{'term-lines'}=qx/tput lines/);
			}
			# print "tc: $size{'term'} cmc: $size{'console'}\n";
			# double check, just in case it's missing functionality or whatever
			if ( $size{'term'} == 0 || $size{'term'} !~ /\d/ ){ 
				$size{'term'}=80;
				$size{'term-lines'}=100;
			}
		}
		# this lets you set different size for in or out of display server
		# if ( ! $b_running_in_display && $configs{'COLS_MAX_NO_DISPLAY'} != 0 ){
		# 	$size{'console'}=$configs{'COLS_MAX_NO_DISPLAY'};
		# }
		# term_cols is set in top globals, using tput cols
		# print "tc: $size{'term'} cmc: $size{'console'}\n";
		if ( $size{'term'} < $size{'console'} ){
			$size{'console'}=$size{'term'};
		}
		# adjust, some terminals will wrap if output cols == term cols
		$size{'console'}=( $size{'console'} - 2 );
		# echo cmc: $size{'console'}
		# comes after source for user set stuff
		if ( ! $b_irc ){
			$size{'max'}=$size{'console'};
		}
		else {
			$size{'max'}=$size{'irc'};
		}
	}
	else {
		$size{'max'}=$width_override;
	}
	$size{'inner'}= ( $size{'max'} - $size{'indent'} - 1 );
	# print "tc: $size{'term'} cmc: $size{'console'} cm: $size{'max'} ci: $size{'inner'}\n";
}

sub set_os {
	my @uname = uname();
	$os = lc($uname[0]);
	if ( $os =~ /(bsd|dragonfly|darwin)/ ){
		if ( $os =~ /openbsd/ ){
			$os = 'openbsd';
		}
		elsif ($os =~ /darwin/){
			$os = 'darwin';
		}
		if ($os =~ /kfreebsd/){
			$bsd_type = 'debian-bsd';
		}
		else {
			$bsd_type = 'bsd';
		}
	}
}

sub set_path {
	my $added_paths = '';
	# Extra path variable to make execute failures less likely, merged below
	my @path = split ':', $ENV{'PATH'};
	my @extra_paths=split ':', '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/opt/local/bin';
	#print "PATH=$ENV{'PATH'}\n";
	# this needs to be set here because various options call the parent 
	# initialize function directly.
	$self_path=dirname "$0";
	# Create a difference of $PATH and $extra_paths and add that to $PATH:
	foreach (@extra_paths) {
		if ( ! grep(/$_/, @path) ){
			$added_paths="$added_paths:$_";
			# print "$path\n";
		}
	}
	$ENV{'PATH'} = $ENV{'PATH'} . $added_paths;
	# print "PATH=$ENV{'PATH'}\n";
	##/bin/sh -c 'echo "PATH in subshell=\"$PATH\""'
}

sub set_user_paths {
	my ( $b_conf, $b_data );
	
	if ( defined $ENV{'XDG_CONFIG_HOME'} && $ENV{'XDG_CONFIG_HOME'} ){
		$self_config_dir=$ENV{'XDG_CONFIG_HOME'};
		$b_conf=1;
	}
	elsif ( -d "$ENV{'HOME'}/.config" ){
		$self_config_dir="$ENV{'HOME'}/.config";
		$b_conf=1;
	}
	else {
		$self_config_dir="$ENV{'HOME'}/.$self_name";
	}
	if ( defined $ENV{'XDG_DATA_HOME'} && $ENV{'XDG_DATA_HOME'} ){
		$self_data_dir="$ENV{'XDG_DATA_HOME'}/$self_name";
		$b_data=1;
	}
	elsif ( -d "$ENV{'HOME'}/.local/share" ){
		$self_data_dir="$ENV{'HOME'}/.local/share/$self_name";
		$b_data=1;
	}
	else {
		$self_data_dir="$ENV{'HOME'}/.$self_name";
	}
	# note, this used to be created/checked in specific instance, but we'll just do it
	# universally so it's done at script start.
	if ( ! -d $self_data_dir ){
		mkdir $self_data_dir;
		system "echo", "Made: $self_data_dir";
	}
	if ( $b_conf && -f "$ENV{'HOME'}/.$self_name/$self_name.conf" ){
		#system 'mv', "-f $ENV{'HOME'}/.$self_name/$self_name.conf", $self_config_dir;
		print "WOULD: Moved $self_name.conf from $ENV{'HOME'}/.$self_name to $self_config_dir\n";
	}
	if ( $b_data && -d "$ENV{'HOME'}/.$self_name" ){
		#system 'mv', '-f', "$ENV{'HOME'}/.$self_name/*", $self_data_dir;
		#system 'rm', '-Rf', "$ENV{'HOME'}/.$self_name";
		print "WOULD: Moved data dir $ENV{'HOME'}/.$self_name to $self_data_dir\n";
	}
	$log_file="$self_data_dir/$self_name.log";
	#system 'echo', "$ENV{'HOME'}/.$self_name/* $self_data_dir";
	# print "scd: $self_config_dir sdd: $self_data_dir \n";
}
# args: 1: set|hash key to return either null or path
sub system_files {
	my ($type) = @_;
	
	if ( $type eq 'set'){
		%files = (
		'asound-cards' => '/proc/asound/cards',
		'asound-modules' => '/proc/asound/modules',
		'asound-version' => '/proc/asound/version',
		'cpuinfo' => '/proc/cpuinfo',
		'dmesg-boot' => '/var/run/dmesg.boot',
		'lsb-release' => '/etc/lsb-release',
		'mdstat' => '/proc/mdstat',
		'meminfo' => '/proc/meminfo',
		'modules' => '/proc/modules',
		'mounts' => '/proc/mounts',
		'os-release' => '/etc/os-release',
		'partitions' => '/proc/partitions',
		'scsi' => '/proc/scsi/scsi',
		'xorg-log' => '/var/log/Xorg.0.log'
		);
		foreach my $key ( keys %files ){
			$system_files{$key} = -e $files{$key} ? $files{$key} : '';
		}
		if ( ! $system_files{'xorg-log'} && check_program('xset') ){
			my $data = qx(xset q 2>/dev/null);
			foreach ( split /\n/, $data){
				if ($_ =~ /Log file/i){
					$system_files{'xorg-log'} = get_piece($_,3);
					last;
				}
			}
		}
	}
	else {
		return $system_files{$type};
	}
}

########################################################################
#### UTILITIES
########################################################################

#### -------------------------------------------------------------------
#### COLOR SELECTOR
#### -------------------------------------------------------------------


#### -------------------------------------------------------------------
#### DEBUGGERS
#### -------------------------------------------------------------------

sub set_debugger {
	if ( $debug < 10 || $debug > 12){
		$end = '';
		$start = '';
		if ( $debug >= 20 ){
			if ( $b_irc ){
				error_handler('not-in-irc', 'debug data generator');
			}
			my $ob_sys = SystemDebugger->new('full');
			$ob_sys->run_debugger();
			if ( $debug > 20 ){
				$ob_sys->upload_file($ftp_alt);
			}
		}
	}
	elsif ($debug >= 10 && $debug <= 12){
		$b_log = 1;
		if ($debug == 11){
			$b_log_full = 1;
		}
		elsif ($debug == 12){
			$b_log_colors = 1;
		}
		begin_logging();
	}
}

{
package SystemDebugger;

use warnings;
use strict;
use diagnostics;
use 5.008;
use Net::FTP;
use File::Find q(find);
no warnings 'File::Find';
use File::Spec::Functions;
use File::Copy;
use POSIX qw(strftime);

my $type = 'full';
my $upload = '';
my $data_dir = '';
my $debug_dir = '';
my $debug_gz = '';
my @content = (); 

# args: 1 - type
# args: 2 - upload
sub new {
	my $class = shift;
	($type) = @_;
	my $self = {};
	# print "$f\n";
	# print "$type\n";
	return bless $self, $class;
}

sub run_debugger {
	print "Starting $self_name debugging data collector...\n";
	create_debug_directory();
	print "Note: for dmidecode data you must be root.\n" if $b_root;
	print $line3;
	disk_data();
	display_data();
	network_data();
	perl_modules();
	system_data();
	system_files();
	print $line3;
	if ( -d '/sys' && main::count_dir_files('/sys') ){
		sys_tree();
		sys_traverse_data();
	}
	else {
		print "Skipping /sys data collection. /sys not present, or empty.\n";
	}
	print $line3;
	run_self();
	print $line3;
	compress_dir();
}

sub create_debug_directory {
	my $host = main::get_hostname();
	$host =~ s/ /-/g;
	$host ||= 'no-host';
	my $bsd_string = '';
	my $root_string = '';
	# note: Time::Piece was introduced in perl 5.9.5
	my ($sec,$min,$hour,$mday,$mon,$year) = localtime;
	$year = $year+1900;
	$mon += 1;
	if (length($sec)  == 1) {$sec = "0$sec";}
	if (length($min)  == 1) {$min = "0$min";}
	if (length($hour) == 1) {$hour = "0$hour";}
	if (length($mon)  == 1) {$mon = "0$mon";}
	if (length($mday) == 1) {$mday = "0$mday";}
	
	my $today = "$year-$mon-${mday}_$hour$min$sec";
	# my $date = strftime "-%Y-%m-%d_", localtime;
	if ($b_root){
		$root_string = '-root';
	}
	if ( $bsd_type ){
		$bsd_string = "-$bsd_type-$os";
	}
	$debug_dir = "$self_name$bsd_string-$host-$today$root_string";
	$debug_gz = "$debug_dir.tar.gz";
	$data_dir = "$self_data_dir/$debug_dir";
	if ( -d $data_dir ){
		unlink $data_dir or main::error_handler('remove', "$data_dir", "$!");
	}
	mkdir $data_dir or main::error_handler('mkdir', "$data_dir", "$!");
	if ( -e "$self_data_dir/$debug_gz" ){
		unlink "$self_data_dir$debug_gz" or main::error_handler('remove', "$self_data_dir/$debug_gz", "$!");
	}
	print "Data going into: $data_dir\n";
}
sub compress_dir {
	print "Creating tar.gz compressed file of this material...\n";
	system("cd $self_data_dir
tar -czf $debug_gz $debug_dir
");
	print "Removing $data_dir...\n";
	unlink $data_dir;
}
## NOTE: >/dev/null 2>&1 is sh, and &>/dev/null is bash, fix this
# ls -w 1 /sysrs > tester 2>&1
sub disk_data {
	print "Collecting dev, label, disk, uuid data, df...\n";
	no warnings 'uninitialized';
	system("PATH=$ENV{'PATH'}
ls -l /dev > $data_dir/dev-data.txt 2>&1
ls -l /dev/disk > $data_dir/dev-disk-data.txt 2>&1
ls -l /dev/disk/by-id > $data_dir/dev-disk-id-data.txt 2>&1
ls -l /dev/disk/by-label > $data_dir/dev-disk-label-data.txt 2>&1
ls -l /dev/disk/by-uuid > $data_dir/dev-disk-uuid-data.txt 2>&1
# http://comments.gmane.org/gmane.linux.file-systems.zfs.user/2032
ls -l /dev/disk/by-wwn > $data_dir/dev-disk-wwn-data.txt 2>&1
ls -l /dev/disk/by-path > $data_dir/dev-disk-path-data.txt 2>&1
ls -l /dev/mapper > $data_dir/dev-disk-mapper-data.txt 2>&1
readlink /dev/root > $data_dir/dev-root.txt 2>&1
df -h -T -P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 --exclude-type=devfs --exclude-type=linprocfs --exclude-type=sysfs --exclude-type=fdescfs > $data_dir/df-h-T-P-excludes.txt 2>&1
df -T -P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 --exclude-type=devfs --exclude-type=linprocfs --exclude-type=sysfs --exclude-type=fdescfs > $data_dir/df-T-P-excludes.txt 2>&1
df -T -P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 --exclude-type=devfs --exclude-type=linprocfs --exclude-type=sysfs --exclude-type=fdescfs --total > $data_dir/df-T-P-excludes-total.txt 2>&1
df -h -T > $data_dir/bsd-df-h-T-no-excludes.txt 2>&1
df -h > $data_dir/bsd-df-h-no-excludes.txt 2>&1
df -k -T > $data_dir/bsd-df-k-T-no-excludes.txt 2>&1
df -k > $data_dir/bsd-df-k-no-excludes.txt 2>&1
atacontrol list > $data_dir/bsd-atacontrol-list.txt 2>&1
camcontrol devlist > $data_dir/bsd-camcontrol-devlist.txt 2>&1
# bsd tool
mount > $data_dir/mount.txt 2>&1
if which btrfs >/dev/null 2>&1; then
	btrfs filesystem show  > $data_dir/btrfs-filesystem-show.txt 2>&1
	btrfs filesystem show --mounted  > $data_dir/btrfs-filesystem-show-mounted.txt 2>&1
	# btrfs filesystem show --all-devices > $data_dir/btrfs-filesystem-show-all-devices.txt 2>&1
else
	touch $data_dir/btrfs-absent
fi
gpart list > $data_dir/bsd-gpart-list.txt 2>&1
gpart show > $data_dir/bsd-gpart-show.txt 2>&1
gpart status > $data_dir/bsd-gpart-status.txt 2>&1
swapctl -l -k > $data_dir/bsd-swapctl-l-k.txt 2>&1
swapon -s > $data_dir/swapon-s.txt 2>&1
sysctl -b kern.geom.conftxt > $data_dir/bsd-sysctl-b-kern.geom.conftxt.txt 2>&1
sysctl -b kern.geom.confxml > $data_dir/bsd-sysctl-b-kern.geom.confxml.txt 2>&1
zfs list > $data_dir/zfs-list.txt 2>&1
zpool list > $data_dir/zpool-list.txt 2>&1
zpool list -v > $data_dir/zpool-list-v.txt 2>&1
df -P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 > $data_dir/df-P-excludes.txt 2>&1
df -P > $data_dir/bsd-df-P-no-excludes.txt 2>&1
cat /proc/mdstat > $data_dir/proc-mdstat.txt 2>&1
cat /proc/partitions > $data_dir/proc-partitions.txt 2>&1
cat /proc/scsi/scsi > $data_dir/proc-scsi.txt 2>&1
cat /proc/mounts > $data_dir/proc-mounts.txt 2>&1
cat /proc/mdstat > $data_dir/proc-mdstat.txt 2>&1
cat /proc/sys/dev/cdrom/info > $data_dir/proc-cdrom-info.txt 2>&1
ls /proc/ide/ > $data_dir/proc-ide.txt 2>&1
cat /proc/ide/*/* > $data_dir/proc-ide-hdx-cat.txt 2>&1
cat /etc/fstab > $data_dir/etc-fstab.txt 2>&1
cat /etc/mtab > $data_dir/etc-mtab.txt 2>&1
if which nvme >/dev/null 2>&1; then
	touch $data_dir/nvme-present
else
	touch $data_dir/nvme-absent
fi
");
}
sub display_data {
	my $working = '';
	if ( ! $b_display ){
		print "Warning: only some of the data collection can occur if you are not in X\n";
		system("touch $data_dir/warning-user-not-in-x");
	}
	if ( $b_root ){
		print "Warning: only some of the data collection can occur if you are running as Root user\n";
		system("touch $data_dir/warning-root-user");
	}
	print "Collecting Xorg log and xorg.conf files...\n";
	if ( -d "/etc/X11/xorg.conf.d/" ){
		my @files = glob q("/etc/X11/xorg.conf.d/*");
		if (scalar @files > 0 ){
			foreach (@files){
				$working =~ s/\/etc\/X11\/xorg.conf.d\///;
				system("cat $_ > $data_dir/xorg-conf-d-$working.txt 2>&1");
			}
		}
	}
	else {
		system("touch $data_dir/xorg-conf-d-files-absent");
	}
	my $xorg_log = $files{'xorg-log'};
	no warnings 'uninitialized';
	system("PATH=$ENV{'PATH'}
if [ -e '$xorg_log' ];then
	cat $xorg_log > $data_dir/xorg-log-file.txt 2>&1
else
	touch $data_dir/xorg-log-file-absent
fi
if [ -e /etc/X11/xorg.conf ];then
	cat /etc/X11/xorg.conf > $data_dir/xorg-conf.txt 2>&1
else
	touch $data_dir/xorg-conf-file-absent
fi
");
	print "Collecting X, xprop, glxinfo, xrandr, xdpyinfo data, wayland, weston...\n";
	no warnings 'uninitialized';
	system("PATH=$ENV{'PATH'}
if which weston-info >/dev/null 2>&1; then
	weston-info > $data_dir/weston-info.txt 2>&1
else
	touch $data_dir/weston-info-absent
fi
if which weston >/dev/null 2>&1; then
	weston --version > $data_dir/weston-version.txt 2>&1
else
	touch $data_dir/weston-absent
fi
if which xprop >/dev/null 2>&1; then
	xprop -root > $data_dir/xprop_root.txt 2>&1
else
	touch $data_dir/xprop-absent
fi
if which glxinfo >/dev/null 2>&1; then
	glxinfo > $data_dir/glxinfo-full.txt 2>&1
	glxinfo -B > $data_dir/glxinfo-B.txt 2>&1
else
	touch $data_dir/glxinfo-absent
fi
if which xdpyinfo >/dev/null 2>&1; then
	xdpyinfo > $data_dir/xdpyinfo.txt 2>&1
else
	touch $data_dir/xdpyinfo-absent
fi
if which xrandr >/dev/null 2>&1; then
	xrandr > $data_dir/xrandr.txt 2>&1
else
	touch $data_dir/xrandr-absent
fi
if which X >/dev/null 2>&1; then
	X -version > $data_dir/x-version.txt 2>&1
else
	touch $data_dir/x-absent
fi
if which Xorg >/dev/null 2>&1; then
	Xorg -version > $data_dir/xorg-version.txt 2>&1
else
	touch $data_dir/xorg-absent
fi
echo $ENV{'GNOME_DESKTOP_SESSION_ID'} > $data_dir/gnome-desktop-session-id.txt 2>&1
# kde 3 id
echo $ENV{'KDE_FULL_SESSION'} > $data_dir/kde3-full-session.txt 2>&1
echo $ENV{'KDE_SESSION_VERSION'} > $data_dir/kde-gte-4-session-version.txt 2>&1
if which kf5-config >/dev/null 2>&1; then
	kf5-config --version > $data_dir/kde-kf5-config-version-data.txt 2>&1
elif which kf6-config >/dev/null 2>&1; then
	kf6-config --version > $data_dir/kde-kf6-config-version-data.txt 2>&1
elif which kf$ENV{'KDE_SESSION_VERSION'}-config >/dev/null 2>&1; then
	kf$ENV{'KDE_SESSION_VERSION'}-config --version > $data_dir/kde-kf$ENV{'KDE_SESSION_VERSION'}-KSV-config-version-data.txt 2>&1
else
	touch $data_dir/kde-kf-config-absent
fi
if which plasmashell >/dev/null 2>&1; then
	plasmashell --version > $data_dir/kde-plasmashell-version-data.txt 2>&1
else
	touch $data_dir/kde-plasmashell-absent
fi
if which kwin_x11 >/dev/null 2>&1; then
	kwin_x11 --version > $data_dir/kde-kwin_x11-version-data.txt 2>&1
else
	touch $data_dir/kde-kwin_x11-absent
fi
if which kded4 >/dev/null 2>&1; then
	kded4 --version > $data_dir/kded4-version-data.txt 2>&1
elif which kded5 >/dev/null 2>&1; then
	kded5 --version > $data_dir/kded5-version-data.txt 2>&1
elif which kded >/dev/null 2>&1; then
	kded --version > $data_dir/kded-version-data.txt 2>&1
else
	touch $data_dir/kded-$ENV{'KDE_SESSION_VERSION'}-absent
fi
# kde 5/plasma desktop 5, this is maybe an extra package and won't be used
if which about-distro >/dev/null 2>&1; then
	about-distro > $data_dir/kde-about-distro.txt 2>&1
else
	touch $data_dir/kde-about-distro-absent
fi
echo $ENV{'XDG_CURRENT_DESKTOP'} > $data_dir/xdg-current-desktop.txt 2>&1
echo $ENV{'XDG_SESSION_DESKTOP'} > $data_dir/xdg-session-desktop.txt 2>&1
echo $ENV{'DESKTOP_SESSION'} > $data_dir/desktop-session.txt 2>&1
echo $ENV{'GDMSESSION'} > $data_dir/gdmsession.txt 2>&1
# wayland data collectors:
echo $ENV{'XDG_SESSION_TYPE'} > $data_dir/xdg-session-type.txt 2>&1
echo $ENV{'WAYLAND_DISPLAY'} > $data_dir/wayland-display.txt 2>&1
echo $ENV{'GDK_BACKEND'} > $data_dir/gdk-backend.txt 2>&1
echo $ENV{'QT_QPA_PLATFORM'} > $data_dir/qt-qpa-platform.txt 2>&1
echo $ENV{'CLUTTER_BACKEND'} > $data_dir/clutter-backend.txt 2>&1
echo $ENV{'SDL_VIDEODRIVER'} > $data_dir/sdl-videodriver.txt 2>&1
if which loginctl >/dev/null 2>&1;then
	loginctl --no-pager list-sessions > $data_dir/loginctl-list-sessions.txt 2>&1
else
	touch $data_dir/loginctl-absent
fi
");
}
sub network_data {
	print "Collecting networking data...\n";
	no warnings 'uninitialized';
	system("PATH=$ENV{'PATH'}
if which ifconfig >/dev/null 2>&1;then
	ifconfig > $data_dir/ifconfig.txt 2>&1
else
	touch $data_dir/ifconfig-absent
fi
if which ip >/dev/null 2>&1;then
	ip addr > $data_dir/ip-addr.txt 2>&1
else
	touch $data_dir/ip-absent
fi
");
}
sub perl_modules {
	print "Collecting Perl module data (this can take a while)...\n";
	my @modules = ();
	my $mods = '';
	my $filename = 'perl-modules.txt';
# 	foreach (@INC){
# 		print "$_\n";
# 	}
	find { wanted => sub { push @modules, canonpath $_ if /\.pm\z/  }, no_chdir => 1 }, @INC;
	@modules = sort(@modules);
	foreach (@modules){
		$mods = $mods . $_ . "\n";
	}
	open (my $fh, '>', "$data_dir/$filename");
	print $fh $mods;
	close $fh;
}
sub system_data {
	print "Collecting system data...\n";
	
	no warnings 'uninitialized';
	system("PATH=$ENV{'PATH'}
# bsd tools http://cb.vu/unixtoolbox.xhtml
# freebsd
if which pciconf >/dev/null 2>&1;then
	pciconf -l -cv > $data_dir/bsd-pciconf-cvl.txt 2>&1
	pciconf -vl > $data_dir/bsd-pciconf-vl.txt 2>&1
	pciconf -l > $data_dir/bsd-pciconf-l.txt 2>&1
else
	touch $data_dir/bsd-pciconf-absent
fi
# openbsd
if which pcidump >/dev/null 2>&1;then
	pcidump > $data_dir/bsd-pcidump-openbsd.txt 2>&1
	pcidump -v > $data_dir/bsd-pcidump-v-openbsd.txt 2>&1
else
	touch $data_dir/bsd-pcidump-openbsd-absent
fi
# netbsd
if which pcictl >/dev/null 2>&1;then
	pcictl list > $data_dir/bsd-pcictl-list-netbsd.txt 2>&1
	pcictl list -n > $data_dir/bsd-pcictl-list-n-netbsd.txt 2>&1
else
	touch $data_dir/bsd-pcictl-netbsd-absent
fi
if which sysctl >/dev/null 2>&1;then
	sysctl -a > $data_dir/bsd-sysctl-a.txt 2>&1
else
	touch $data_dir/bsd-sysctl-absent
fi
if which usbdevs >/dev/null 2>&1;then
	usbdevs -v > $data_dir/bsd-usbdevs-v.txt 2>&1
else
	touch $data_dir/bsd-usbdevs-absent
fi
if which kldstat >/dev/null 2>&1;then
	kldstat > $data_dir/bsd-kldstat.txt 2>&1
else
	touch $data_dir/bsd-kldstat-absent
fi
# diskinfo -v <disk>
# fdisk <disk>
dmidecode > $data_dir/dmidecode.txt 2>&1
dmesg > $data_dir/dmesg.txt 2>&1
if which lscpu > /dev/null 2>&1;then
	lscpu > $data_dir/lscpu.txt 2>&1
else
	touch $data_dir/lscpu-absent
fi
if which lspci > /dev/null 2>&1;then
	lspci > $data_dir/lspci.txt 2>&1
	lspci -k > $data_dir/lspci-k.txt 2>&1
	lspci -knn > $data_dir/lspci-knn.txt 2>&1
	lspci -n > $data_dir/lspci-n.txt 2>&1
	lspci -nn > $data_dir/lspci-nn.txt 2>&1
	lspci -mm > $data_dir/lspci-mm.txt 2>&1
	lspci -mmnn > $data_dir/lspci-mmnn.txt 2>&1
	lspci -mmnnv > $data_dir/lspci-mmnnv.txt 2>&1
	lspci -v > $data_dir/lspci-v.txt 2>&1
else 
	touch $data_dir/lspci-absent
fi
if which lspci > /dev/null 2>&1;then
	lsusb > $data_dir/lsusb.txt 2>&1
else
	touch $data_dir/lsusb-absent
fi
if which hciconfig >/dev/null 2>&1;then
	hciconfig -a > $data_dir/hciconfig-a.txt 2>&1
else
	touch $data_dir/hciconfig-absent
fi
ps aux > $data_dir/ps-aux.txt 2>&1
ps -e > $data_dir/ps-e.txt 2>&1
ps -p 1 > $data_dir/ps-p-1.txt 2>&1
if which runlevel > /dev/null 2>&1;then
	runlevel > $data_dir/runlevel.txt 2>&1
else
	touch $data_dir/runlevel-absent
fi
if which rc-status >/dev/null 2>&1;then
	rc-status -a > $data_dir/rc-status-a.txt 2>&1
	rc-status -l > $data_dir/rc-status-l.txt 2>&1
	rc-status -r > $data_dir/rc-status-r.txt 2>&1
else
	touch $data_dir/rc-status-absent
fi
if which systemctl >/dev/null 2>&1;then
	systemctl list-units > $data_dir/systemctl-list-units.txt 2>&1
	systemctl list-units --type=target > $data_dir/systemctl-list-units-target.txt 2>&1
else
	touch $data_dir/systemctl-absent
fi
if which initctl >/dev/null 2>&1;then
	initctl list > $data_dir/initctl-list.txt 2>&1
else
	touch $data_dir/initctl-absent
fi
if which sensors >/dev/null 2>&1;then
	sensors > $data_dir/sensors.txt 2>&1
else
	touch $data_dir/sensors-absent
fi
if which strings >/dev/null 2>&1;then
	touch $data_dir/strings-present
else
	touch $data_dir/strings-absent
fi
# leaving this commented out to remind that some systems do not
# support strings --version, but will just simply hang at that command
# which you can duplicate by simply typing: strings then hitting enter, you will get hang.
# strings --version > $data_dir/strings.txt 2>&1
if which nvidia-smi >/dev/null 2>&1;then
	nvidia-smi -q > $data_dir/nvidia-smi-q.txt 2>&1
	nvidia-smi -q -x > $data_dir/nvidia-smi-xq.txt 2>&1
else
	touch $data_dir/nvidia-smi-absent
fi
echo $ENV{'CC'} > $data_dir/cc-content.txt 2>&1
ls /usr/bin/gcc* > $data_dir/gcc-sys-versions.txt 2>&1
if which gcc >/dev/null 2>&1;then
	gcc --version > $data_dir/gcc-version.txt 2>&1
else
	touch $data_dir/gcc-absent
fi
if which clang >/dev/null 2>&1;then
	clang --version > $data_dir/clang-version.txt 2>&1
else
	touch $data_dir/clang-absent
fi
if which systemd-detect-virt >/dev/null 2>&1;then
	systemd-detect-virt > $data_dir/systemd-detect-virt-info.txt 2>&1
else
	touch $data_dir/systemd-detect-virt-absent
fi
");
}
sub system_files {
	print "Collecting system files data...\n";
	# main::get_repo_data($data_dir);
	# main::check_recommends() > $data_dir/check-recommends.txt 2>&1
	no warnings 'uninitialized';
	my $id_dir='/sys/class/power_supply/';
	my $ids=qx( ls $id_dir 2>/dev/null );
	if ($ids){
		foreach ($ids){
			system("cat $id_dir$_/uevent > $data_dir/sys-power-supply-$_.txt 2>&1");
		}
	}
	else {
		system("touch $data_dir/sys-power-supply-none");
	}
	# chdir "/etc";
	my @files = glob q("/etc/*[-_]{[rR]elease,[vV]ersion}");
	my $working = '';
	push @files, '/etc/issue';
	foreach (@files){
		if ( -f "$_" ){
			$working = $_;
			$working =~ s/\//-/g;
			system("cat $_ > $data_dir/distro-file$working.txt 2>&1");
			# print "File: $_ W: $working\n";
		}
	}
	
	system("PATH=$ENV{'PATH'}
cat /proc/1/comm > $data_dir/proc-1-comm.txt 2>&1
head -n 1 /proc/asound/card*/codec* > $data_dir/proc-asound-card-codec.txt 2>&1
if [ -f /proc/version ];then
	cat /proc/version > $data_dir/proc-version.txt 2>&1
else
	touch $data_dir/proc-version-absent
fi
cat /etc/src.conf > $data_dir/bsd-etc-src-conf.txt 2>&1
cat /etc/make.conf > $data_dir/bsd-etc-make-conf.txt 2>&1
cat /etc/issue > $data_dir/etc-issue.txt 2>&1
cat /etc/lsb-release > $data_dir/lsb-release.txt 2>&1
cat /etc/os-release > $data_dir/os-release.txt 2>&1
cat /proc/asound/cards > $data_dir/proc-asound-device.txt 2>&1
cat /proc/asound/version > $data_dir/proc-asound-version.txt 2>&1
cat /proc/cpuinfo > $data_dir/proc-cpu-info.txt 2>&1
cat /proc/meminfo > $data_dir/proc-meminfo.txt 2>&1
cat /proc/modules > $data_dir/proc-modules.txt 2>&1
cat /proc/net/arp > $data_dir/proc-net-arp.txt  2>&1
# bsd data
cat /var/run/dmesg.boot > $data_dir/bsd-var-run-dmesg.boot.txt  2>&1
echo $size{'inner'} > $data_dir/cols-inner.txt 2>&1
echo $ENV{'XDG_CONFIG_HOME'} > $data_dir/xdg_config_home.txt 2>&1
echo $ENV{'XDG_CONFIG_DIRS'} > $data_dir/xdg_config_dirs.txt 2>&1
echo $ENV{'XDG_DATA_HOME'} > $data_dir/xdg_data_home.txt 2>&1
echo $ENV{'XDG_DATA_DIRS'} > $data_dir/xdg_data_dirs.txt 2>&1
# just on the off chance bsds start having a fake /sys
ls -w 1 /sys > $data_dir/sys-tree-ls-1-basic.txt 2>&1
");
}

sub run_self {
	print "Creating $self_name output file now. This can take a few seconds...\n";
	print "Starting $self_name from: $self_path\n";
	my $cmd = "$self_path/$self_name -FRfrploudmxxx -c 0 --debug=10 -y 120 > $data_dir/inxi-FRfrploudmxxxy120.txt";
	system($cmd);
	copy($log_file, "$data_dir/") or main::error_handler('copy-failed', "$log_file", "$!");
}

sub sys_tree {
	print "Constructing /sys tree data...\n";
	if ( main::check_program('tree') ){
		my $dirname = '/sys';
		my $cmd;
		system("tree -a -L 10 /sys > $data_dir/sys-tree-full-10.txt");
		opendir my($dh), $dirname or die "Couldn't open dir '$dirname': $!";
		my @files = readdir $dh;
		closedir $dh;
		foreach (@files){
			next if /^\./;
			$cmd = "tree -a -L 10 $dirname/$_ > $data_dir/sys-tree-$_-10.txt";
			#print "$cmd\n";
			system($cmd);
		}
	}
	else {
		sys_ls(1);
		sys_ls(2);
		sys_ls(3);
		sys_ls(4);
	}
}
sub sys_ls {
	my ( $depth) = @_;
	my $cmd = do {
		if ( $depth == 1 ){ '/sys/' }
		elsif ( $depth == 2 ){ 'ls -l /sys/*/ 2>/dev/null' }
		elsif ( $depth == 3 ){ 'ls -l /sys/*/*/ 2>/dev/null' }
		elsif ( $depth == 4 ){ 'ls -l /sys/*/*/*/ 2>/dev/null' }
		elsif ( $depth == 5 ){ 'ls -l /sys/*/*/*/*/ 2>/dev/null' }
		elsif ( $depth == 5 ){ 'ls -l /sys/*/*/*/*/ 2>/dev/null' }
	};
	my @working = ();
	my $output = '';
	my ($line, $type, $fh);
	my $result = qx($cmd);
	open $fh, '<', \$result or die $!;
	while ( $line = <$fh> ){
		chomp($line);
		$line =~ s/^\s+|\s+$//g;
		@working = split /\s+/, $line;
		$working[0] ||= '';
		if ( scalar @working > 7 ){
			if ($working[0] =~ /^d/ ){
				$type = "d - ";
			}
			elsif ($working[0] =~ /^l/){
				$type = "l - ";
			}
			else {
				$type = "f - ";
			}
			$working[9] ||= '';
			$working[10] ||= '';
			$output = $output . "  $type$working[8] $working[9] $working[10]\n";
		}
		elsif ( $working[0] !~ /^total/ ){
			$output = $output . $line . "\n";
		}
	}
	close $fh;
	open $fh, '>', "$data_dir/sys-tree-ls-$depth.txt" or die $!;
	print $fh $output;
	close $fh;
	# print "$output\n";
}

sub sys_traverse_data {
	print "Parsing /sys files...\n";
	find( \&wanted, "/sys");
	process_data();
}
sub wanted {
	return if -d; # not directory
	return unless -e; # Must exist
	return unless -r; # Must be readable
	return unless -f; # Must be file
	# note: a new file in 4.11 /sys can hang this, it is /parameter/ then
	# a few variables. Since inxi does not need to see that file, we will
	# not use it. Also do not need . files or __ starting files
	return if $File::Find::name =~ /\/(\.[a-z]|__|parameters\/|debug\/)/;
	# comment this one out if you experience hangs or if 
	# we discover syntax of foreign language characters
	# Must be ascii like. This is questionable and might require further
	# investigation, it is removing some characters that we might want
	return unless -T; 
	# print $File::Find::name . "\n";
	push @content, $File::Find::name;
	return;
}
sub process_data {
	my ($data,$fh,$result,$row,$sep);
	my $filename = "sys-tree-parse.txt";
	# no sorts, we want the order it comes in
	# @content = sort @content; 
	foreach (@content){
		$data='';
		$sep='';
		open($fh, "<$_");
		while ($row = <$fh>) {
			chomp $row;
			$data .= $sep . '"' . $row . '"';
			$sep=', ';
		}
		$result .= "$_:[$data]\n";
		# print "$_:[$data]\n"
	}
	# print scalar @content . "\n";
	open ($fh, '>', "$data_dir/$filename");
	print $fh $result;
	close $fh;
	# print $fh "$result";
}
# args: 1 - path to file to be uploaded
# args: 2 - optional: alternate ftp upload url
# NOTE: must be in format: ftp.site.com/incoming
sub upload_file {
	my ($self, $ftp_url) = @_;
	my ($ftp, $domain, $host, $user, $pass, $dir, $error);
	$ftp_url ||= main::get_defaults('ftp-upload');
	$ftp_url =~ s/\/$//g; # trim off trailing slash if present
	my @url = split(/\//, $ftp_url);
	my $file_path = "$self_data_dir/$debug_gz";
	$host = $url[0];
	$dir = $url[1];
	$domain = $host;
	$domain =~ s/^ftp\.//;
	$user = "anonymous";
	$pass = "anonymous\@$domain";
	
	print $line3;
	print "Uploading to: $ftp_url\n";
	# print "$host $domain $dir $user $pass\n";
	print "File to be uploaded: $file_path\n";
	
	if ($host && ( $file_path && -e $file_path ) ){
		# NOTE: important: must explicitly set to passive true/1
		$ftp = Net::FTP->new($host, Debug => 0, Passive => 1);
		$ftp->login($user, $pass) || main::error_handler('ftp-login', $ftp->message);
		$ftp->binary();
		$ftp->cwd($dir);
		print "Connected to FTP server.\n";
		$ftp->put($file_path) || main::error_handler('ftp-upload', $ftp->message);
		$ftp->quit;
		print "Uploaded file successfully!\n";
		print $ftp->message;
	}
	else {
		main::error_handler('ftp-bad-path', "$file_path");
	}
}
};
1;
{
package SystemDebuggerXX;
my $type = 'full';
my $upload = '';
my $data_dir = '';
my $debug_dir = '';
my $debug_gz = '';
my @content = (); 

# args: 1 - type
# args: 2 - upload
sub new {
	my $class = shift;
	($type) = @_;
	my $self = {};
	# print "$f\n";
	print "$type\n";
	return bless $self, $class;
}

sub run_debugger {
	print "Starting $self_name debugging data collector...\n";
}
sub upload_file {}
}


#### -------------------------------------------------------------------
#### DOWNLOADER
#### -------------------------------------------------------------------

sub download_file {
	my ($type, $url, $file) = @_;
	my ($cmd,$args,$timeout);
	my $result = 1;
	$dl{'no-ssl-opt'} ||= '';
	$dl{'spider'} ||= '';
	if ( ! $dl{'dl'} ){
		return 0;
	}
	if ($dl{'timeout'}){
		$timeout = "$dl{'timeout'}$dl_timeout";
	}
	# print "$dl{'no-ssl-opt'}\n";
	# print "$dl{'dl'}\n";
	# tiny supports spider sort of
	if ($dl{'dl'} eq 'tiny' ){
		$result = get_file($type, $url, $file);
	}
	else {
		if ($type eq 'stdout'){
			$args = $dl{'stdout'};
			$cmd = "$dl{'dl'} $dl{'no-ssl-opt'} $timeout $args $url $dl{'null'}";
			$result = qx($cmd);
		}
		elsif ($type eq 'file') {
			$args = $dl{'file'};
			$cmd = "$dl{'dl'} $dl{'no-ssl-opt'} $timeout $args $file $url $dl{'null'}";
			system($cmd);
			$result = $?;
		}
		elsif ( $dl{'dl'} eq 'wget' && $type eq 'spider'){
			$cmd = "$dl{'dl'} $dl{'no-ssl-opt'} $timeout $dl{'spider'} $url";
		}
	}
	return $result;
}

sub get_file {
	my ($type, $url, $file) = @_;
	my $response = HTTP::Tiny->new->get($url);
	my $return = 1;
	my $debug = 0;
	my $fh;
	
	if ( ! $response->{success} ){
		print "Failed to connect to server/file!\n";
		$return = 0;
	}
	else {
		if ( $debug ){
			print "$response->{success}\n";
			print "$response->{status} $response->{reason}\n";
			while (my ($key, $value) = each %{$response->{headers}}) {
				for (ref $value eq "ARRAY" ? @$value : $value) {
					print "$key: $_\n";
				}
			}
		}
		if ( $type eq "stdout" || $type eq "ua-stdout" ){
			$return = $response->{content};
		}
		elsif ($type eq "spider"){
			# do nothing, just use the return value
		}
		elsif ($type eq "file"){
			open($fh, ">", $file);
			print $fh $response->{content}; # or die "can't write to file!\n";
			close $fh;
		}
	}
	return $return;
}

sub set_downloader {
	$dl{'no-ssl'} = '';
	$dl{'null'} = '';
	$dl{'spider'} = '';
	if ($dl{'tiny'}){
		$dl{'dl'} = 'tiny';
		$dl{'file'} = '';
		$dl{'stdout'} = '';
		$dl{'timeout'} = '';
	}
	elsif ( $dl{'curl'} && check_program('curl')  ){
		$dl{'dl'} = 'curl';
		$dl{'file'} = '  -L -s -o ';
		$dl{'no-ssl'} = ' --insecure';
		$dl{'stdout'} = ' -L -s ';
		$dl{'timeout'} = ' -y ';
	}
	elsif ($dl{'wget'} && check_program('wget') ){
		$dl{'dl'} = 'wget';
		$dl{'file'} = ' -q -O ';
		$dl{'no-ssl'} = ' --no-check-certificate';
		$dl{'spider'} = ' -q --spider';
		$dl{'stdout'} = '  -q -O -';
		$dl{'timeout'} = ' -T ';
	}
	elsif ($dl{'fetch'} && check_program('fetch')){
		$dl{'dl'} = 'fetch';
		$dl{'file'} = ' -q -o ';
		$dl{'no-ssl'} = ' --no-verify-peer';
		$dl{'stdout'} = ' -q -o -';
		$dl{'timeout'} = ' -T ';
	}
	elsif ( $bsd_type eq 'openbsd' && check_program('ftp') ){
		$dl{'dl'} = 'ftp';
		$dl{'file'} = ' -o ';
		$dl{'null'} = ' 2>/dev/null';
		$dl{'stdout'} = ' -q -O - ';
		$dl{'timeout'} = '';
	}
	else {
		$dl{'dl'} = '';
	}
}

sub set_perl_downloader {
	my ($downloader) = @_;
	$downloader =~ s/perl/tiny/;
	return $downloader;
}

#### -------------------------------------------------------------------
#### ERROR HANDLER
#### -------------------------------------------------------------------

sub error_handler {
	my ( $err, $one, $two) = @_;
	my $errno = 0;
	my $b_help = 0;
	my $message = do {
		if ( $err eq 'empty' ) { 'empty value' }
		## Basic rules
		elsif ( $err eq 'not-in-irc' ) { 
			$errno=1; "You can't run option $one in an IRC client!" }
		## Internal/external options
		elsif ( $err eq 'bad-arg' ) { 
			$errno=10; $b_help=1; "Unsupported value: $two for option: $one" }
		elsif ( $err eq 'bad-arg-int' ) { 
			$errno=11; "Bad internal argument: $one" }
		elsif ( $err eq 'distro-block' ) { 
			$errno=20; "Option: $one has been disabled by the $self_name distribution maintainer." }
		elsif ( $err eq 'unknown-option' ) { 
			$errno=21; $b_help=1; "Unsupported option: $one" }
		## Files:
		elsif ( $err eq 'copy-failed' ) { 
			$errno=30; "Error copying file: $one \nError: $two" }
		elsif ( $err eq 'downloader-error' ) { 
			$errno=30; "Error downloading file: $one \nfor download source: $two" }
		elsif ( $err eq 'file-corrupt' ) { 
			$errno=31; "Downloaded file is corrupted: $one" }
		elsif ( $err eq 'mkdir' ) { 
			$errno=32; "Error creating directory: $one \nError: $two" }
		elsif ( $err eq 'open' ) { 
			$errno=32; "Error opening file: $one \nError: $two" }
		elsif ( $err eq 'not-writable' ) { 
			$errno=33; "The file: $one is not writable!" }
		elsif ( $err eq 'open-dir-failed' ) { 
			$errno=33; "The directory: $one failed to open with error: $two" }
		elsif ( $err eq 'remove' ) { 
			$errno=33; "Failed to remove file: $one Error: $two" }
		elsif ( $err eq 'rename' ) { 
			$errno=34; "There was an error moving files: $one\nError: $two" }
		elsif ( $err eq 'write-error' ) { 
			$errno=35; "Failed writing file: $one - Error: $two!" }
		## FTP
		elsif ( $err eq 'ftp-bad-path' ) { 
			$errno=50; "Unable to locate for FTP upload file:\n$one" }
		elsif ( $err eq 'ftp-login' ) { 
			$errno=50; "There was an error with login to ftp server: $one" }
		elsif ( $err eq 'ftp-login' ) { 
			$errno=51; "There was an error with upload to ftp server: $one" }
		## DEFAULT
		else {
			$errno=255; "Error handler ERROR!! Unsupported options: $err!"}
	};
	print_screen_line("Error $errno: $message\n");
	if ($b_help){
		print_screen_line("Check -h for correct parameters.\n");
	}
	exit 0;
}

#### -------------------------------------------------------------------
#### LOGGING
#### -------------------------------------------------------------------

# called in the initial -@ 10 script args setting so we can get logging 
# as soon as possible # will have max 3 files, inxi.log, inxi.1.log, 
# inxi.2.log
sub begin_logging {
	my $log_file_2="$self_data_dir/$self_name.1.log";
	my $log_file_3="$self_data_dir/$self_name.2.log";
	my $data = '';
	
	my $now = strftime "%Y-%m-%d %H:%M:%S", localtime;
	# do the rotation if logfile exists
	if ( -f $log_file ){
		# copy if present second to third
		if ( -f $log_file_2 ){
			rename $log_file_2, $log_file_3 or error_handler('rename', "$log_file_2 -> $log_file_3", "$!");
		}
		# then copy initial to second
		rename $log_file, $log_file_2 or error_handler('rename', "$log_file -> $log_file_2", "$!");
	}
	# now create the logfile
	# print "Opening log file for reading: $log_file\n";
	open $fh_l, '>', $log_file or error_handler(4, $log_file, "$!");
	# and echo the start data
	$data = $line2;
	$data = $data . "START $self_name LOGGING:\n";
	$data = $data . "$now\n";
	$data = $data .  $line2;
	print $fh_l $data;
}

# NOTE: no logging available until get_parameters is run, since that's what 
# sets logging # in order to trigger earlier logging manually set $b_log
# to true in top variables.
# arg: $one alone: logs data; $two with or without $three logs func start/end.
# arg: $one type (fs/fe/cat/raw) or logged data; 
# [$two is function name; [$three - function args]]
sub log_data {
	return if ! $b_log;
	my ($one, $two, @args) = @_;
	my $args = '';
	my $data = '';
	my $spacer = '   ';
	# print "1: $one 2: $two 3: $three\n";
	for ($one){
		if (/^fs$/) {
			if (@args){
				$args = "\n${spacer}Args: " . join(', ', @args) . '; ';
			}
			else {
				$args = "\n${spacer}Args: None; ";
			}
			$data = "Start: Function: $two$args\n";
			$spacer='';
		}
		elsif (/^fe$/) {
			$data = "End: Function: $two\n";
			$spacer='';
		}
		elsif (/^cat$/) {
			if ( $b_log_full ){
				for my $file ($two){
					my $contents = do { local( @ARGV, $/ ) = $file; <> }; # or: qx(cat $file)
					$data = "$data${line3}Full file data: $file\n\n$contents\n$line3\n";
				}
				$spacer='';
			}
		}
		elsif (/^raw$/) {
			if ( $b_log_full ){
				$data = "\n${line3}Raw System Data:\n\n$two\n$line3";
				$spacer='';
			}
		}
		else {
			$data = "$one\n";
		}
	}
	# print "d: $data";
	if ($data){
		print $fh_l "$spacer$data";
	}
}

#### -------------------------------------------------------------------
#### RECOMMENDS
#### -------------------------------------------------------------------

sub check_recommends {}

#### -------------------------------------------------------------------
#### TOOLS
#### -------------------------------------------------------------------


## returns result of test, 0/1, false/true
## arg: program to find in PATH
sub check_program {
	grep { -x "$_/$_[0]"}split /:/,$ENV{PATH};
}

sub cleanup {
	foreach my $fh ($fh_l, $fh_c, $fh_j, $fh_x){
		if ($fh){
			close $fh;
		}
	}
}

# returns count of files in directory, if 0, dir is empty
sub count_dir_files {
	return undef unless -d $_[0];
	opendir my $dh, $_[0] or error_handler('open-dir-failed', "$_[0]", $!); 
	my $count = grep { ! /^\.{1,2}/ } readdir $dh; # strips out . and ..
	return $count;
}

# arg 1: type to return
sub get_defaults {
	my ($type) = @_;
	my %defaults = (
	'ftp-upload' => 'ftp.techpatterns.com/incoming',
	# 'inxi-branch-1' => 'https://github.com/smxi/inxi/raw/one/',
	# 'inxi-branch-2' => 'https://github.com/smxi/inxi/raw/two/',
	'inxi-main' => 'https://github.com/smxi/inxi/raw/master/',
	'inxi-pinxi' => 'https://github.com/smxi/inxi/raw/inxi-perl/',
	'inxi-man' => "https://github.com/smxi/inxi/raw/master/$self_name.1.gz",
	);
	if ( exists $defaults{$type}){
		return $defaults{$type};
	}
	else {
		error_handler('bad-arg-int', $type);
	}
}

sub get_piece {
	my ($string, $num, $sep) = @_;
	$num--;
	$sep ||= ' ';
	my @temp = split $sep, $string, -1;
	if ( exists $temp[$num] ){
		return $temp[$num];
	}
}

# args: 1 - desktop/app command for --version; 2 - search string; 
# 3 - space print number
sub program_version {
	my ($app, $search, $num) = @_;
	my ($cmd,$line,$output);
	my $version_nu = '';
	my $version = '--version';
	if ( $num > 0 ){
		$num--;
	}
	if ( $app =~ /^dwm|ksh|scrotwm|spectrwm$/ ) {
		$version = '-v';
	}
	elsif ($app eq 'epoch' ){
		$version = 'version';
	}
	# note, some wm/apps send version info to stderr instead of stdout
	if ( $app =~ /^dwm|ksh|scrotwm$/ ) {
		$cmd = "$app $version 2>&1";
	}
	elsif ( $app eq 'csh' ){
		$cmd = "tcsh $version 2>/dev/null";
	}
	# debian/buntu hack until I find a universal way to get version for these
	elsif ( $app eq 'dash' ){
		$cmd = "dpkg -l $app 2>/dev/null";
	}
	else {
		$cmd = "$app $version 2>/dev/null";
	}
	log_data("app version command: $cmd");
	$output = qx($cmd);
	# sample: dwm-5.8.2, ©.. etc, why no space? who knows. Also get rid of v in number string
	# xfce, and other, output has , in it, so dump all commas and parentheses
	if ($output){
		open my $ch, '<', \$output or die "failed to open: error: $!";
		while (<$ch>){
			#chomp;
			if ( $_ =~ /$search/i ) {
				$_ = trimmer($_);
				# print "$_ ::$num\n";
				$version_nu = (split /\s+/, $_)[$num];
				$version_nu =~ s/(,|dwm-|wmii2-|wmii-|v|V|\(|\))//g;
				# print "$version_nu\n";
				last;
			}
		}
		close $ch if $ch;
	}
	log_data("Program version: $version_nu");
	return $version_nu;
}
# print program_version('bash', 'bash', 4) . "\n";

# calling it trimmer to avoid conflicts with existing trim stuff
# arg: 1 - string to be right left trimmed. Also slices off \n so no chomp needed
sub trimmer {
	my $str = shift;
	$str =~ s/^\s+|\s+$|\n$//g; 
	return $str;
}

#### -------------------------------------------------------------------
#### UPDATER
##### -------------------------------------------------------------------

# args: 1 - download url, not including file name; 2 - string to print out
# 3 - update type option
# note that 1 must end in / to properly construct the url path
sub update_me {
	eval $start;
	my ( $self_download, $download_id ) = @_;
	my $downloader_error=1;
	my $file_contents='';
	my $output = '';
	my $b_man = 0;
	my $full_self_path = "$self_path/$self_name";
	
	if ( $b_irc ){
		error_handler('not-in-irc', "-U/--update" )
	}
	if ( ! -w $full_self_path ){
		error_handler('not-writable', "$self_name", '');
	}
	$output = "${output}Starting $self_name self updater.\n";
	$output = "${output}Using $dl{'dl'} as downloader.\n";
	$output = "${output}Currently running $self_name version number: $self_version\n";
	$output = "${output}Current version patch number: $self_patch\n";
	$output = "${output}Current version release date: $self_date\n";
	$output = "${output}Updating $self_name in $self_path using $download_id as download source...\n";
	print $output;
	$output = '';
	$self_download = "$self_download/$self_name";
	$file_contents=download_file('stdout', $self_download);
	
	# then do the actual download
	if (  $file_contents ){
		# make sure the whole file got downloaded and is in the variable
		if ( $file_contents =~ /###\*\*EOF\*\*###/ ){
			open(my $fh, '>', $full_self_path);
			print $fh $file_contents or error_handler('write-error', "$full_self_path", "$!" );
			close $fh;
			qx( chmod +x '$self_path/$self_name' );
			set_version_data();
			$output = "${output}Successfully updated to $download_id version: $self_version\n";
			$output = "${output}New $download_id version patch number: $self_patch\n";
			$output = "${output}New $download_id version release date: $self_date\n";
			$output = "${output}To run the new version, just start $self_name again.\n";
			$output = "${output}$line3\n";
			$output = "${output}Starting download of man page file now.\n";
			print $output;
			$output = '';
			if ($b_man && $download_id eq 'main branch' ){
				update_man();
			}
			else {
				print "Skipping man download because branch version is being used.\n";
			}
			exit 1;
		}
		else {
			error_handler('file-corrupt', "$self_name");
		}
	}
	# now run the error handlers on any downloader failure
	else {
		error_handler('download-error', $self_download, $download_id);
	}
	eval $end;
}

sub update_man {
	my $man_file_url=get_defaults('inxi-man'); 
	my $man_file_location=set_man_location();
	my $man_file_path="$man_file_location/$self_name.1.gz" ;
	my $output = '';
	
	my $downloader_man_error=1;
	if ( ! -d $man_file_location ){
		print "The required man directory was not detected on your system.\n";
		print "Unable to continue: $man_file_location\n";
		return 0;
	}
	if ( -w $man_file_location ){
		print "Cannot write to $man_file_location! Are you root?\n";
		print "Unable to continue: $man_file_location\n";
		return 0;
	}
	if ( -f "/usr/share/man/man8/inxi.8.gz" ){
		print "Updating man page location to man1.\n";
		rename "/usr/share/man/man8/inxi.8.gz", "$man_file_location/inxi.1.gz";
		if ( check_program('mandb') ){
			system( 'mandb' );
		}
	}
	if ( $dl{'dl'} =~ /tiny|wget/){
		print "Checking Man page download URL...\n";
		download_file('spider', $man_file_url);
		$downloader_man_error = $?;
	}
	if ( $downloader_man_error == 1 ){
		if ( $dl{'dl'} =~ /tiny|wget/){
			print "Man file download URL verified: $man_file_url\n";
		}
		print "Downloading Man page file now.\n";
		download_file('file', $man_file_url,  $man_file_path );
		$downloader_man_error = $?;
		if ( $downloader_man_error == 0 ){
			print "Oh no! Something went wrong downloading the Man gz file at: $man_file_url\n";
			print "Check the error messages for what happened. Error: $downloader_man_error\n";
		}
		else {
			print "Download/install of man page successful. Check to make sure it works: man inxi\n";
		}
	}
	else {
		print "Man file download URL failed, unable to continue: $man_file_url\n";
	}
}

sub set_man_location {
	my $location='';
	my $default_location='/usr/share/man/man1';
	my $man_paths=qx(man --path 2>/dev/null);
	my $man_local='/usr/local/share/man';
	my $b_use_local=0;
	if ( $man_paths && $man_paths =~ /$man_local/ ){
		$b_use_local=1;
	}
	# for distro installs
	if ( -f "$default_location/inxi.1.gz" ){
		$location=$default_location;
	}
	else {
		if ( $b_use_local ){
			if ( ! -d "$man_local/man1" ){
				mkdir "$man_local/man1";
			}
			$location="$man_local/man1";
		}
	}
	if ( ! $location ){
		$location=$default_location;
	}
	return $location;
}

# update for updater output version info
# note, this is only now used for self updater function so it can get
# the values from the UPDATED file, NOT the running program!
sub set_version_data {
	open (my $fh, '<', "$self_path/$self_name");
	while( my $row = <$fh>){
		chomp $row;
		$row =~ s/'//g;
		if ($row =~ /^my \$self_name/ ){
			$self_name = (split /=/, $row)[1];
		}
		elsif ($row =~ /^my \$self_version/ ){
			$self_version = (split /=/, $row)[1];
		}
		elsif ($row =~ /^my \$self_date/ ){
			$self_date = (split /=/, $row)[1];
		}
		elsif ($row =~ /^my \$self_patch/ ){
			$self_patch = (split /=/, $row)[1];
		}
		elsif ($row =~ /infobash/){
			last;
		}
	}
	close $fh;
}


########################################################################
#### OPTIONS HANDLER
########################################################################

sub get_options{
	my (@args) = @_;
	# my @argv = @ARGV;
	$show{'short'} = 1;
	# $show{''} = 1;
	#$opt_parser->configure('no_ignore_case');
	# GetOptionsFromArray(\@argv, 
	GetOptions (
	'A|audio' => sub {
		$show{'short'} = 0;
		$show{'audio'} = 1;},
	'b|basic' => sub {
		$show{'short'} = 0;
		$show{'battery'} = 1;
		$show{'cpu-basic'} = 1;
		$show{'raid-basic'} = 1;
		$show{'disk-total'} = 1;
		$show{'graphics'} = 1;
		$show{'info'} = 1;
		$show{'machine'} = 1;
		$show{'network'} = 1;},
	'B|battery' => sub {
		$show{'short'} = 0;
		$show{'battery'} = 1;
		$show{'battery-forced'} = 1; },
	'c|color:i' => sub {
		$show{'short'} = 0;
		# $show{''} = 1; 
		},
	'C|cpu' => sub {
		$show{'short'} = 0;
		$show{'cpu'} = 1; },
	'd|disk-all' => sub {
		$show{'short'} = 0;
		$show{'disk'} = 1;
		$show{'optical-full'} = 1; },
	'D' => sub {
		$show{'short'} = 0;
		$show{'disk'} = 1; },
	'f|cpu-flags' => sub {
		$show{'short'} = 0;
		$show{'cpu'} = 1;
		$show{'cpu-flags'} = 1; },
	'F|full' => sub {
		$show{'short'} = 0;
		$show{'audio'} = 1;
		$show{'battery'} = 1;
		$show{'cpu'} = 1;
		$show{'disk'} = 1;
		$show{'graphics'} = 1;
		$show{'info'} = 1;
		$show{'machine'} = 1;
		$show{'network'} = 1;
		$show{'network-advanced'} = 1;
		$show{'partitions'} = 1;
		$show{'raid'} = 1;
		$show{'sensors'} = 1;
		$show{'system'} = 1; },
	'G|graphics' => sub {
		$show{'short'} = 0;
		$show{'graphics'} = 1; },
	'i|ip' => sub {
		$show{'short'} = 0;
		$show{'ip'} = 1;
		$show{'network'} = 1;
		$show{'network-advanced'} = 1; },
	'I|info' => sub {
		$show{'short'} = 0;
		$show{'info'} = 1; },
	'l|label' => sub {
		$show{'short'} = 0;
		$show{'labels'} = 1;
		$show{'partitions'} = 1; },
	'm|memory' => sub {
		$show{'short'} = 0;
		$show{'memory'} = 1; },
	'M|machine' => sub {
		$show{'short'} = 0;
		$show{'machine'} = 1; },
	'n|network-advanced' => sub {
		$show{'short'} = 0;
		$show{'network'} = 1;
		$show{'network-advanced'} = 1; },
	'N|network' => sub {
		$show{'short'} = 0;
		$show{'network'} = 1; },
	'o|unmounted' => sub {
		$show{'short'} = 0;
		$show{'unmounted'} = 1; },
	'p|partitions-full' => sub {
		$show{'short'} = 0;
		$show{'partitions'} = 1;
		$show{'partitions-full'} = 1; },
	'P|partitions' => sub {
		$show{'short'} = 0;
		$show{'partitions'} = 1; },
	'r|repos' => sub {
		$show{'short'} = 0;
		$show{'repos'} = 1; },
	'R|raid' => sub {
		$show{'short'} = 0;
		$show{'raid'} = 1;
		$show{'raid-forced'} = 1; },
	's|sensors' => sub {
		$show{'short'} = 0;
		$show{'sensors'} = 1; },
	'S|system' => sub {
		$show{'short'} = 0;
		$show{'system'} = 1; },
	't|processes:s' => sub {
		my ($opt,$arg) = @_;
		$show{'short'} = 0;
		if ( $arg =~ /^([cm]+)([1-9]|1[0-9]|20)?$/ ){
			if ($arg =~ /c/){
				$show{'ps-cpu'} = 1;
			}
			if ($arg =~ /m/){
				$show{'ps-mem'} = 1;
			}
			if ($arg =~ /([0-9]+)/ ){
				$ps_count = $1;
			}
		}
		else {
			error_handler('bad-arg',$opt,$arg);
		} },
	'u|uuid' => sub {
		$show{'short'} = 0;
		$show{'partitions'} = 1;
		$show{'uuids'} = 1; },
	'U|update:s' => sub { # 1,2,3 OR http://myserver/path/inxi
		my ($opt,$arg) = @_;
		$show{'short'} = 0;
		my ($self_download,$download_id);
		if ( $b_update ){
			if ( $arg =~ /^\d$/){
				$download_id = "branch $arg";
				$self_download = get_defaults("inxi-branch-$arg");
			}
			elsif ( $arg =~ /^http/){
				$download_id = 'alt server';
				$self_download = $arg;
			}
			else {
				$download_id = 'pinxi branch';
				$self_download = get_defaults('inxi-pinxi');
			}
# 			else {
# 				$download_id = 'main branch';
# 				$self_download = get_defaults('inxi-main');
# 			}
			if ($self_download){
				update_me( $self_download, $download_id );
			}
			else {
				error_handler('bad-arg', $opt, $arg);
			}
		}
		else {
			error_handler('distro-block', $opt);
		} },
	'v|verbosity:i' => sub {
		my ($opt,$arg) = @_;
		$show{'short'} = 0;
		if ( $arg =~ /^[0-7]$/ ){
			if ($arg == 0 ){
				$show{'short'} = 1;
			}
			if ($arg >= 1 ){
				$show{'cpu-basic'} = 1;
				$show{'disk-total'} = 1;
				$show{'graphics'} = 1;
				$show{'info'} = 1;
				$show{'system'} = 1;
			}
			if ($arg >= 2 ){
				$show{'battery'} = 1;
				$show{'disk-basic'} = 1;
				$show{'raid-basic'} = 1;
				$show{'machine'} = 1;
				$show{'network'} = 1;
			}
			if ($arg >= 3 ){
				$show{'network-advanced'} = 1;
				$show{'cpu'} = 1;
				$show{'extra'} = 1;
			}
			if ($arg >= 4 ){
				$show{'disk'} = 1;
				$show{'partitions'} = 1;
			}
			if ($arg >= 5 ){
				$show{'audio'} = 1;
				$show{'memory'} = 1;
				$show{'labels'} = 1;
				$show{'memory'} = 1;
				$show{'raid'} = 1;
				$show{'sensors'} = 1;
				$show{'uuid'} = 1;
			}
			if ($arg >= 6 ){
				$show{'optical-full'} = 1;
				$show{'partitions-full'} = 1;
				$show{'unmounted'} = 1;
				$show{'extra'} = 2;
			}
			if ($arg >= 7 ){
				$show{'ip'} = 1;
				$show{'raid-forced'} = 1;
				$show{'extra'} = 3;
			}
		}
		else {
			error_handler('bad-arg',$opt,$arg);
		} },
	'V|version' => sub { 
		$output_type = 'print-basic';
		show_version(); },
	'w|weather' => sub {
		my ($opt) = @_;
		$show{'short'} = 0;
		if ( $b_weather ){
			$show{'weather'} = 1;
		}
		else {
			error_handler('distro-block', $opt);
		} },
	'W|weather-location:s' => sub {
		my ($opt,$arg) = @_;
		$arg ||= '';
		$show{'short'} = 0;
		if ( $b_weather ){
			if ( $arg){
				$show{'weather'} = 1;
				$show{'weather-location'} = 1;
			}
			else {
				error_handler('bad-arg',$opt,$arg);
			}
		}
		else {
			error_handler('distro-block', $opt);
		} },
	'x|extra:i' => sub {
		my ($opt,$arg) = @_;
		if ($arg > 0){
			$show{'extra'} = $arg;
		}
		else {
			$show{'extra'}++;
		} },
	'y|width:i' => sub {
		my ($opt, $arg) = @_;
		if ( $arg =~ /\d/ && $arg >= 80 ){
			set_display_width($arg);
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'z|filter' => sub {
		$show{'filter'} = 1; },
	'Z|filter-override' => sub {
		$show{'filter-override'} = 1; },
	'h|help|?' => sub {
		$output_type = 'print-basic';
		show_options('standard'); },
	'H|help-full' => sub {
		$output_type = 'print-basic';
		show_options('full'); },
	'alt:i' => sub { 
		my ($opt,$arg) = @_;
		my %alts = (
		'0' => sub {$test{'1'} = 1;},
		'1' => sub {$test{'1'} = 1;},
		'2' => sub {$test{'2'} = 1;},
		'3' => sub {$test{'3'} = 1;},
		'30' => sub {$b_irc = 0;},
		'31' => sub {$show{'host'} = 0;},
		'32' => sub {$show{'host'} = 1;},
		'34' => sub {$dl{'no-ssl-opt'}=$dl{'no-ssl'};},
		'40' => sub {
			$dl{'tiny'} = 0;
			set_downloader();},
		'41' => sub {
			$dl{'curl'} = 0;
			set_downloader();},
		'42' => sub {
			$dl{'fetch'} = 0;
			set_downloader();},
		'43' => sub {
			$dl{'wget'} = 0;
			set_downloader();
		},
		'44' => sub {
			$dl{'curl'} = 0;
			$dl{'fetch'} = 0;
			$dl{'wget'} = 0;
			set_downloader();
		}
		);
		if ($alts{$arg}){
			$alts{$arg}->();
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		}
		# print "alt $arg\n"; 
		},
	'debug:i' => sub { 
		my ($opt,$arg) = @_;
		if ($arg =~ /^[1-3]|[1-2][0-2]$/){
			$debug=$arg;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'downloader:s' => sub { 
		my ($opt,$arg) = @_;
		$arg = lc($arg);
		if ($arg =~ /^(curl|fetch|ftp|perl|wget)$/){
			# this dumps all the other data and resets %dl for only the
			# desired downloader.
			$arg = set_perl_downloader($arg);
			%dl = ('dl' => $arg, $arg => 1);
			set_downloader();
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'ftp:s'  => sub { 
		my ($opt,$arg) = @_;
		# pattern: ftp.x.x/x
		if ($arg =~ /^ftp\..+\..+\/[^\/]+$/ ){
			$ftp_alt = $arg;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		}},
	'<>' => sub {
		my ($opt) = @_;
		error_handler('unknown-option', "$opt", "" ); }
	) ; #or error_handler('unknown-option', "@ARGV", '');
} 

sub show_optionsXX {
	print "stub: " . (caller(0))[3] . "\n";
	exit 1;
}

sub show_options {
	if ( $b_irc ){
		error_handler('not-in-irc', 'help');
	}
	my ($type) = @_;
	my (@row,@rows,@data);
	my $line = '';
	my $color_scheme_count=12; # $(( ${#A_COLOR_SCHEMES[@]} - 1 ));
	my $partition_string='partition';
	my $partition_string_u='Partition';
	if ( $bsd_type ){
		$partition_string='slice';
		$partition_string_u='Slice';
	}
	# fit the line to the screen!
	for my $i ( 0 .. ( ( $size{'max'} / 2 ) - 2 ) ){
		$line = $line . '- ';
	}
	@rows = (
	['0', '', '', "$self_name supports the following options. You can combine 
	them, or list them one by one. Examples: $self_name^-v4^-c6 OR 
	$self_name^-bDc^6. If you start $self_name with no arguments, it will show 
	the short form." ],
	[0, '', '', '' ],
	['0', '', '', "The following options if used without -F, -b, or -v will show 
	just option line(s): A, B, C, D, G, I, M, N, P, R, S, f, i, m, n, o, p, l, 
	u, r, s, t - you can use these alone or together to show just the line(s) 
	you want to see. If you use them with -v^[level], -b or -F, it will show the 
	full output for that line along with the output for the chosen verbosity level." ],
	['0', '', '', $line ],
	['0', '', '', "Output Control Options:" ],
	['1', '-A', '--audio', "Audio/sound card information." ],
	['1', '-b', '--basic', "Basic output, short form. Like $self_name^-v^2, only minus hard 
	disk names." ],
	['1', '-B', '--battery', "Battery info, shows charge, condition, plus extra information 
	(if battery present)." ],
	['1', '-c', '--color', "Color schemes. Scheme number is required. Color selectors run a 
	color selector option prior to $self_name starting which lets you set the 
	config file value for the selection." ],
	['1', '', '', "Supported color schemes: 0-$color_scheme_count 
	Example:^$self_name^-c^11" ],
	['1', '', '', "Color selectors for each type display (NOTE: irc and global only 
	show safe color set):" ],
	['2', '94', '', "Console, out of X" ],
	['2', '95', '', "Terminal, running in X - like xTerm" ],
	['2', '96', '', "Gui IRC, running in X - like Xchat, Quassel, Konversation etc." ],
	['2', '97', '', "Console IRC running in X - like irssi in xTerm" ],
	['2', '98', '', "Console IRC not in  X" ],
	['2', '99', '', "Global - Overrides/removes all settings. Setting specific 
	removes global." ],
	['1', '-C', '--cpu', "CPU output, including per CPU clockspeed and max CPU speed 
	(if available)." ],
	['1', '-d', '--optical', "Optical drive data (and floppy disks, if present). Same as -Dd. 
	See also -x and -xx." ],
	['1', '-D', '--disk', "Full hard Disk info, not only model, ie: /dev/sda ST380817AS 
	80.0GB. See also -x and -xx. Disk total used percentage includes swap 
	partition size(s)." ],
	['1', '-f', '--flags', "All cpu flags, triggers -C. Not shown with -F to avoid spamming. 
	ARM cpus show 'features'." ],
	['1', '-F', '--full', "Full output for $self_name. Includes all Upper Case line letters, 
	plus -s and -n. Does not show extra verbose options like 
	-d -f -l -m -o -p -r -t -u -x" ],
	['1', '-G', '--graphics', "Graphic card information (card, display server type/version, 
	resolution, renderer, OpenGL version)." ],
	['1', '-i', '--ip', "Wan IP address, and shows local interfaces (requires ifconfig 
	network tool). Same as -Nni. Not shown with -F for user security reasons, 
	you shouldn't paste your local/wan IP." ],
	['1', '-I', '--info', "Information: processes, uptime, memory, irc client (or shell type),
	$self_name version." ],
	['1', '-l', '--label', "$partition_string_u labels. Default: short $partition_string -P. 
	For full -p output, use: -pl (or -plu)." ],
	['1', '-m', '--memory', "Memory (RAM) data. Physical system memory array(s), capacity, 
	how many devices (slots) supported, and individual memory devices 
	(sticks of memory etc). For devices, shows device locator, size, speed, 
	type (like: DDR3). If neither -I nor -tm are selected, also shows 
	ram used/total. Also see -x, -xx, -xxx" ],
	['1', '-M', '--machine', "Machine data. Device type (desktop, server, laptop, VM etc.), 
	Motherboard, Bios, and if present, System Builder (Like Lenovo). 
	Shows UEFI/BIOS/UEFI [Legacy]. Older systems/kernels without the 
	required /sys data can use dmidecode instead, run as root. 
	Dmidecode can be forced with -! 33" ],
	['1', '-n', '--network-advanced', "Advanced Network card information. Same as -Nn. Shows interface, 
	speed, mac id, state, etc." ],
	['1', '-N', '--network', "Network card information. With -x, shows PCI BusID, Port number." ],
	['1', '-o', '--unmounted', "Unmounted $partition_string information (includes UUID and 
	LABEL if available). Shows file system type if you have file installed, 
	if you are root OR if you have added to /etc/sudoers (sudo v. 1.7 or 
	newer) Example:^<username>^ALL^=^NOPASSWD:^/usr/bin/file^" ],
	['1', '-p', '--partitions-full', "Full $partition_string information (-P plus all other 
	detected ${partition_string}s)." ],
	['1', '-P', '--partitions', "Basic $partition_string information (shows what -v^4 would 
	show, but without extra data). Shows, if detected: 
	/ /boot /home /opt /tmp /usr /var /var/log /var/tmp . 
	Use -p to see all mounted ${partition_string}s." ],
	['1', '-r', '--repos', "Distro repository data. Supported repo types: APK; APT; PACMAN; 
	PISI; PORTAGE; PORTS (BSDs); SLACKPKG; URPMQ; YUM; ZYPP." ],
	['1', '-R', '--raid', "RAID data. Shows RAID devices, states, levels, and components, 
	and extra data with -x/-xx. md-raid: If device is resyncing, shows resync 
	progress line as well." ],
	['1', '-s', '--sensors', "Sensors output (if sensors installed/configured): mobo/cpu/gpu temp; 
	detected fan speeds. Gpu temp only for Fglrx/Nvidia drivers. Nvidia shows 
	screen number for > 1 screens." ],
	['1', '-S', '--system', "System information: host name, kernel, desktop environment 
	(if in X), distro" ],
	['1', '-t', '--processes', "Processes. Requires extra options: c^(cpu) m^(memory) cm^(cpu+memory). 
	If followed by numbers 1-20, shows that number of processes for each type 
	(default:^$ps_count; if in irc, max:^5): -t^cm10" ],
	['1', '', '', "Make sure to have no space between letters and numbers 
	(-t^cm10 - right, -t^cm^10 - wrong)." ],
	['1', '-u', '--uuid', "$partition_string_u UUIDs. Default: short $partition_string -P. 
	For full -p output, use: -pu (or -plu)." ],
	['1', '-v', '--verbosity', "Script verbosity levels. Verbosity level number is required. 
	Should not be used with -b or -F" ],
	['1', '', '', "Supported levels: 0-7 Example: $self_name^-v^4" ],
	['2', '0', '', "Short output, same as: $self_name" ],
	['2', '1', '', "Basic verbose, -S + basic CPU + -G + basic Disk + -I." ],
	['2', '2', '', "Networking card (-N), Machine (-M) data, if present, Battery (-B), 
	basic hard disk data (names only), and, if present, basic raid (devices only, 
	and if inactive, notes that). similar to: $self_name^-b" ],
	['2', '3', '', "Advanced CPU (-C), battery, network (-n) data, and switches on 
	-x advanced data option." ],
	['2', '4', '', "$partition_string_u size/filled data (-P) for (if present): /, 
	/home, /var/, /boot. Shows full disk data (-D)." ],
	['2', '5', '', "Audio card (-A); sensors^(-s), memory/ram^(-m), 
	$partition_string label^(-l) and UUID^(-u), short form of optical drives, 
	standard raid data (-R)." ],
	['2', '6', '', "Full $partition_string (-p), unmounted $partition_string (-o), 
	optical drive (-d), full raid; triggers -xx." ],
	['2', '7', '', "Network IP data (-i); triggers -xxx."]
	);
	push @data, @rows;
	# if distro maintainers don't want the weather feature disable it
	if ( $b_weather ){
		@rows = (
		['1', '-w', '--weather', "Local weather data/time. To check an alternate location, 
		see: -W^<location>. For extra weather data options see -x, -xx, and -xxx."],
		['1', '-W', '--weather-location', "<location> Supported options for <location>: postal code; 
		city, state/country; latitude, longitude. Only use if you want the weather 
		somewhere other than the machine running $self_name. Use only ascii 
		characters, replace spaces in city/state/country names with '+'. 
		Example:^$self_name^-W^new+york,ny"]
		);
		push @data, @rows;
	}
	@rows = (
	['1', '-x', '-extra', "Adds the following extra data (only works with verbose or line 
	output, not short form):" ],
	['2', '-B', '', "Vendor/model, status (if available)" ],
	['2', '-C', '', "CPU Flags, Bogomips on Cpu;CPU microarchitecture / revision if 
	found, like: (Sandy Bridge rev.2)" ],
	['2', '-d', '', "Extra optical drive data; adds rev version to optical drive." ],
	['2', '-D', '', "Hdd temp with disk data if you have hddtemp installed, if you are 
	root OR if you have added to /etc/sudoers (sudo v. 1.7 or newer) 
	Example:^<username>^ALL^=^NOPASSWD:^/usr/sbin/hddtemp" ],
	['2', '-G', '', "Direct rendering status for Graphics (in X)." ],
	['2', '-G', '', "(for single gpu, nvidia driver) screen number gpu is running on." ],
	['2', '-i', '', "For IPv6, show additional IP v6 scope addresses: Global, Site, 
	Temporary, Unknown." ],
	['2', '-I', '', "System GCC, default. With -xx, also show other installed 
	GCC versions. If running in console, not in IRC client, shows shell 
	version number, if detected. Init/RC Type and runlevel (if available)." ],
	['2', '-m', '', "Part number; Max memory module size (if available)." ],
	['2', '-N -A', '', "Version/port(s)/driver version (if available) for Network/Audio;" ],
	['2', '-N -A -G', '', "Network, audio, graphics, shows PCI Bus ID/Usb ID 
	number of card." ],
	['2', '-R', '', "md-raid: Shows component raid id. Adds second RAID Info line: 
	raid level; report on drives (like 5/5); blocks; chunk size; bitmap (if present). 
	Resync line, shows blocks synced/total blocks. zfs-raid:	Shows raid array 
	full size; available size; portion allocated to RAID" ],
	['2', '-S', '', "Desktop toolkit if available (GNOME/XFCE/KDE only); Kernel 
	gcc version" ],
	['2', '-t', '', "Memory use output to cpu (-xt c), and cpu use to memory (-xt m)." ]
	);
	push @data, @rows;
	if ( $b_weather eq 1 ){
		@rows = (['2', '-w -W', '', "Wind speed and time zone (-w only)." ]);
		push @data, @rows;
	}
	@rows = (
	['1', '-xx', '--extra 2', "Show extra, extra data (only works with verbose or line output, 
	not short form):" ],
	['2', '-A', '', "Chip vendor:product ID for each audio device." ],
	['2', '-B', '', "serial number, voltage (if available)." ],
	['2', '-C', '', "Minimum CPU speed, if available." ],
	['2', '-D', '', "Disk serial number; Firmware rev. if available." ],
	['2', '-G', '', "Chip vendor:product ID for each video card; (mir/wayland only) 
	compositor (alpha test); OpenGL compatibility version, if free drivers and 
	available." ],
	['2', '-I', '', "Other detected installed gcc versions (if present). System 
	default runlevel. Adds parent program (or tty) for shell info if not in IRC
	(like Konsole or Gterm). Adds Init/RC (if found) version number." ],
	['2', '-m', '', "Manufacturer, Serial Number, single/double bank (if found)." ],
	['2', '-M', '', "Chassis information, bios rom size (dmidecode only), if data for 
	either is available." ],
	['2', '-N', '', "Chip vendor:product ID for each nic." ],
	['2', '-R', '', "md-raid: Superblock (if present); algorythm, U data. Adds 
	system info line (kernel support,read ahead, raid events). If present, 
	adds unused device line. Resync line, shows progress bar." ],
	['2', '-S', '', "Display manager (dm) in desktop output, if in X 
	(like kdm, gdm3, lightdm)." ],
	);
	push @data, @rows;
	if ( $b_weather ){
		@rows = (['2', '-w -W', '', "Humidity, barometric pressure." ]);
		push @data, @rows;
	}
	@rows = (
	['1', '-xxx', '--extra 3', "Show extra, extra, extra data (only works with verbose or 
	line output, not short form):" ],
	['2', '-B', '', "chemistry, cycles, location (if available)." ],
	['2', '-m', '', "Width of memory bus, data and total (if present and greater 
	than data); Detail, if present, for Type; module voltage, if available." ],
	['2', '-S', '', "Panel/shell information in desktop output, if in X 
	(like gnome-shell, cinnamon, mate-panel)." ]
	);
	push @data, @rows;
	if ( $b_weather ){
		@rows = (['2', '-w -W', '', "Location (uses -z/irc filter), weather 
		observation time, wind chill, heat index, dew point (shows extra lines 
		for data where relevant)." ] );
		push @data, @rows;
	}
	@rows = (
	['1', '-y', '--width', "Required extra option: integer, 80 or greater. Set the output 
	line width max. Overrides IRC/Terminal settings or actual widths. If used 
	with -h, put -y option first. Example:^inxi^-y^130" ],
	['1', '-z', '--filter', "Security filters for IP/Mac addresses, location, user home 
	directory name. Default on for irc clients." ],
	['1', '-Z', '--filter-override', "Absolute override for output filters. Useful for debugging 
	networking issues in irc for example." ],
	[0, '', '', "$line" ],
	[0, '', '', "Additional Options:" ],
	['1', '-h', '--help', "This help menu." ],
	['1', '-H', '--help-full', "This help menu, plus developer options. Do not use dev options in 
	normal operation!" ],
	['1', '', '--recommends', "Checks $self_name application dependencies + recommends, 
	and directories, then shows what package(s) you need to install to add support 
	for that feature. " ]
	);
	push @data, @rows;
	if ( $b_update ){
		@rows = (
		['1', '-U', '--update', "Auto-update script. Will also install/update man page. 
		Note: if you installed as root, you must be root to update, otherwise user 
		is fine. Man page installs require root user mode. No arguments downloads from main 
		$self_name git repo." ],
		['1', '', '', "Use alternate sources for updating $self_name" ],
		
		['2', '1', '', "Get the git branch one version." ],
		['2', '2', '', "Get the git branch two version." ],
		['2', '<http>', '', "Get a version of $self_name from your own server if you want, 
		put the full download path, like: $self_name -U https://myserver.com/inxi" ]
		);
		push @data, @rows;
		
	}
	@rows = (
	['1', '-V', '--version', "$self_name version information. Prints information 
	then exits." ],
	[0, '', '', "$line" ],
	[0, '', '', "Debugging Options:" ],
	
	['1', '', '--debug', "Triggers debugging modes." ],
	['2', '1-3', '', "On screen $self_name debugger output" ],
	['2', '10', '', "Basic $self_name logging." ],
	['2', '11', '', "Full file/system info logging" ],
	['2', '12', '', "Plus Color logging." ],
	['1', '', ,'', "The following create a tar.gz file of system data, plus collecting 
	the inxi output to file. To automatically upload debugger data tar.gz file 
	to ftp.techpatterns.com: inxi^--debug^21" ],
	['2', '20', '', "Full system data collection: /sys; xorg conf and 
	log data, xrandr, xprop, xdpyinfo, glxinfo etc.; data from dev, disks, 
	${partition_string}s, etc." ],
	['2', '21', '', "Upload debugger dataset to $self_name debugger server 
	automatically." ],
	['1', '', '--ftp', "Use with --debugger 21 to trigger an alternate FTP server for upload. Format:^[ftp.xx.xx/yy]. Must include a remote directory to upload to: Example:^ftp.myserver.com/incoming" ],
	[0, '', '', "$line" ],
	[0, '', '', "Advanced Options:" ],
	[1, '', '--alt', "Trigger for various advanced options:" ],
	['2', '0', '', "Overrides defective or corrupted data." ],
	['2', '31', '', "Turns off hostname in output. Useful if showing output from 
	servers etc." ],
	['2', '32', '', "Turns on hostname in output. Overrides global \$b_host'" ],
	['2', '33', '', "Forces use of dmidecode data instead of /sys where 
	relevant (-M)." ],
	['2', '34', '', "Skips SSL certificate checks for all downloader activies 
	(wget/fetch/curl only). Must go before other options." ],
	['2', '40', '', "Bypass Perl as a downloader option." ],
	['2', '41', '', "Bypass Curl as a downloader option." ],
	['2', '42', '', "Bypass Fetch as a downloader option." ],
	['2', '43', '', "Bypass Wget as a downloader option." ],
	['2', '44', '', "Bypass Curl, Fetch, and Wget as a downloader options. Forces 
	Perl if HTTP::Tiny present." ],
	['1', '', '--downloader', "Force $self_name to use [curl|fetch|perl|wget] for downloads." ],
	['0', '', '', $line ]
	);
	push @data, @rows;
	if ( $type eq 'full' ){
		@rows = (
		[0, '', '', "Developer and Testing Options (Advanced):" ],
		['1', '', '--alt', "Trigger for dev/test options:" ],
		['2', '1', '', "Sets testing flag test1=1 to trigger 
		testing condition 1." ],
		['2', '2', '', "Sets testing flag test2=1 to trigger 
		testing condition 2." ],
		['2', '3', '', "Sets flags test3=1." ],
		['0', '', '', $line ]
		);
		push @data, @rows;
	}
	output_handler(@data); 
}

########################################################################
#### STARTUP DATA
########################################################################


########################################################################
#### OUTPUT
########################################################################

#### -------------------------------------------------------------------
#### FILTERS
#### -------------------------------------------------------------------


sub print_patch_version {
	my $patch = $self_patch;
	$patch =~ s/^0+//; # strip leading zero(s)
	if ( $patch ne '' ){
		$patch="-$patch";
		# for cases where it was for example: 00-bsd cleaned to --bsd trim out one -
		$patch =~ s/--/-/;
	}
	return $patch;
}


#### -------------------------------------------------------------------
#### GENERATE OUTPUT
#### -------------------------------------------------------------------

sub output_handler {
	my @data = @_;
	# print Dumper \@data;
	if ($output_type eq 'print-basic'){
		print_basic(@data);
	}
	elsif ($output_type eq 'print-line'){
		print_line(@data);
	}
	elsif ($output_type eq 'csv'){
		generate_csv(@data);
	}
	elsif ($output_type eq 'json'){
		generate_json(@data);
	}
	elsif ($output_type eq 'xml'){
		generate_xml(@data);
	}
}


sub show_version {
	# if not in PATH could be either . or directory name, no slash starting
	my $working_path=$self_path;
	my (@data, @row, @rows, $link, $self_string);
	if ( $working_path eq '.' ){
		$working_path=getcwd;
	}
	elsif ( $working_path !~ /^\// ){
		$working_path= getcwd() . "/$working_path";
	}
	# handle if it's a symbolic link, rare, but can happen with directories 
	# in irc clients which would only matter if user starts inxi with -! 30 override 
	# in irc client
	if ( -l "$working_path/$self_name" ){
		$link="$working_path/$self_name";
		$working_path=readlink "$working_path/$self_name";
		$working_path=dirname( $working_path );
	}
	@row = [ 0, '', '', "$self_name $self_version-$self_patch ($self_date)"];
	push @data, @row;
	if ( ! $b_irc ){
		my $year = (split/-/, $self_date)[0];
		@row = [ 0, '', '', "Program Location: $working_path" ];
		push @data, @row;
		if ( $link ){
			@row = [ 0, '', '', "Started via symbolic link: $link" ];
			push @data, @row;
		}
		@rows = (
		[ 0, '', '', "Website:^https://github.com/smxi/inxi^or^http://smxi.org/" ],
		[ 0, '', '', "IRC:^irc.oftc.net channel:^#smxi" ],
		[ 0, '', '', "Forums:^http://techpatterns.com/forums/forum-33.html" ],
		[ 0, '', '', " " ],
		[ 0, '', '', "$self_name - the universal, portable, system information tool 
		for console and irc." ],
		[ 0, '', '', "Using Perl version: $]"],
		[ 0, '', '', " " ],
		[ 0, '', '', "This program started life as a fork of Infobash 3.02: 
		Copyright^(C)^2005-2007^Michiel^de^Boer^a.k.a.^locsmif." ],
		[ 0, '', '', "Subsequent changes and modifications (after Infobash 3.02): 
		Copyright^(C)^2008-$year^Harald^Hope^aka^h2. 
		CPU/Konversation^fixes:^Scott^Rogers^aka^trash80.
		USB^audio^fixes:^Steven^Barrett^aka^damentz." ],
		[ 0, '', '', '' ],
		[ 0, '', '', "This program is free software; you can redistribute it and/or modify 
		it under the terms of the GNU General Public License as published by the Free Software 
		Foundation; either version 3 of the License, or (at your option) any later version. 
		(http://www.gnu.org/licenses/gpl.html)" ]
		);
		push @data, @rows;
	}
	output_handler(@data); 
}

sub print_screen_line {
	my $line = shift;
	if ($client{'test-konvi'}){
		$client{'konvi'} = 3;
		$client{'qdbus'} = 1;
		$client{'dcop'} = 0;
		$client{'dobject'} = 'Konversation';
	}
	if ( $client{'konvi'} == 1 && $client{'dcop'} ){
		# konvi doesn't seem to like \n characters, it just prints them literally
		$line =~ s/\n//g;
		#qx('dcop "$client{'dport'}" "$client{'dobject'}" say "$client{'dserver'}" "$client{'dtarget'}" "$line 1");
		system('dcop', $client{'dport'}, $client{'dobject'}, 'say', $client{'dserver'}, $client{'dtarget'}, "$line 1");
	}
	elsif ($client{'konvi'} == 3 && $client{'qdbus'} ){
		
		# print $line;
		$line =~ s/\n//g;
		#qx(qdbus org.kde.konversation /irc say "$client{'dserver'}" "$client{'dtarget'}" "$line");
		system('qdbus', 'org.kde.konversation', '/irc', 'say', $client{'dserver'}, $client{'dtarget'}, $line);
	}
	else {
		print $line;
	}
}

sub print_basic {
	my @data = @_;
	my $indent = 18;
	my $indent_static = 18;
	my $indent1_static = 5;
	my $indent2_static = 8;
	my $indent1 = 5;
	my $indent2 = 8;
	my $length =  @data;
	my ($start,$aref,$i,$j,$line, $word);
	
	if ( $size{'max'} > 110 ){
		$indent_static = 22;
	}
	elsif ($size{'max'} < 90 ){
		$indent_static = 15;
	}
	# print $length . "\n";
	for $i (0 .. $#data){
		$aref = $data[$i];
		#print "0: $data[$i][0]\n";
		if ($data[$i][0] == 0 ){
			$indent = 0;
			$indent1 = 0;
			$indent2 = 0;
		}
		elsif ($data[$i][0] == 1 ){
			$indent = $indent_static;
			$indent1 = $indent1_static;
			$indent2= $indent2_static;
		}
		elsif ($data[$i][0] == 2 ){
			$indent = ( $indent_static + 7 );
			$indent1 = ( $indent_static + 5 );
			$indent2 = 0;
		}
		$data[$i][3] =~ s/\n/ /g;
		$data[$i][3] =~ s/\s+/ /g;
		if ($data[$i][1] && $data[$i][2]){
			$data[$i][1] = $data[$i][1] . ', ';
		}
		$start = sprintf("%${indent1}s%-${indent2}s",$data[$i][1],$data[$i][2]);
		if ($indent > 1 && ( length($start) > ( $indent - 1) ) ){
			$line = sprintf("%-${indent}s\n", "$start");
			print_screen_line($line);
			$start = '';
		}
		if ( ( $indent + length($data[$i][3]) ) < $size{'max'} ){
			$data[$i][3] =~ s/\^/ /g;
			$line = sprintf("%-${indent}s%s\n", "$start", $data[$i][3]);
			print_screen_line($line);
		}
		else {
			my $holder = '';
			my $sep = ' ';
			foreach $word (split / /, $data[$i][3]){
				#print "$word\n";
				if ( ( $indent + length($holder) + length($word) ) < $size{'max'} ) {
					$word =~ s/\^/ /g;
					$holder = $holder . $word . $sep;
				}
				elsif ( ( $indent + length($holder) + length($word) ) > $size{'max'}){
					$line = sprintf("%-${indent}s%s\n", "$start", $holder);
					print_screen_line($line);
					$start = '';
					$word =~ s/\^/ /g;
					$holder = $word . $sep;
				}
			}
			if ($holder !~ /^[ ]*$/){
				$line = sprintf("%-${indent}s%s\n", "$start", $holder);
				print_screen_line($line);
			}
		}
	}
}


########################################################################
#### DATA PROCESSORS
########################################################################

#### -------------------------------------------------------------------
#### GET DATA
#### -------------------------------------------------------------------

sub get_repo_data {}

#### -------------------------------------------------------------------
#### SPECIAL DATA HANDLERS - INITIALIZE DATA VALUES
#### -------------------------------------------------------------------


#### -------------------------------------------------------------------
#### SPECIAL DATA HANDLERS - UTILITIES FOR GET DATA/PRINT LINES
#### -------------------------------------------------------------------

sub get_hostname {
	eval $start;
	if ( $ENV{'HOSTNAME'} ){
		return $ENV{'HOSTNAME'};
	}
	else {
		return hostname;
	}
	eval $end;
}

########################################################################
#### GENERATE LINES
########################################################################

#### -------------------------------------------------------------------
#### DATA CONTROLLERS
#### -------------------------------------------------------------------

sub generate_data {
	eval $start;
	# log_data('cat', '/proc/mounts');
	print "stub: " . (caller(0))[3] . "\n";
	eval $end;
}

#### -------------------------------------------------------------------
#### LINE TRIGGERS
#### -------------------------------------------------------------------


#######################################################################
#### LAUNCH
########################################################################

main(); ## From the End comes the Beginning

## note: this EOF is needed for smxi handling, this is what triggers the full download ok
###**EOF**###
