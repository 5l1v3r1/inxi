#!/usr/bin/env perl
## INXI INFO ##
my $self_name = 'inxi';
my $self_version = '2.9.00';
my $self_date = '2017-12-08';
my $self_patch = '015-p';

## infobash: Copyright (C) 2005-2007  Michiel de Boer a.k.a. locsmif
## inxi: Copyright (C) 2008-2017 Harald Hope
##       Additional features (C) Scott Rogers - kde, cpu info
## Further fixes (listed as known): Horst Tritremmel <hjt at sidux.com>
## Steven Barrett (aka: damentz) - usb audio patch; swap percent used patch
## Jarett.Stevens - dmidecode -M patch for older systems with the /sys
##
## License: GNU GPL v3 or greater
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## If you don't understand what Free Software is, please read (or reread)
## this page: http://www.gnu.org/philosophy/free-sw.html

use strict;
use warnings;
# use diagnostics;
use 5.008;

use Cwd; # qw(abs_path);
# use Data::Dump qw(dump); # damn, not in core modules
use Data::Dumper qw(Dumper); # print_r
use File::Basename;
use File::Find;
# use Getopt::Long qw(GetOptionsFromArray); # :config no_ignore_case bundling_values
use Getopt::Long qw(GetOptions);
# Note: default auto_abbrev is enabled, that's fine
Getopt::Long::Configure ('bundling', 'no_ignore_case');
use Net::FTP;
# use Path::Class; # maybe use, maybe not, for ls /sys
use POSIX qw(uname strftime);
use Sys::Hostname;
use Term::ANSIColor;

# we only want to use HTTP::Tiny if it's present in user system.
# It is NOT part of core modules.
my $b_tiny = 'true';
eval "use HTTP::Tiny"; # if not found, return has error messages etc
if ( $@ ) {
	$b_tiny = '';
}
# print $@ . "\n";

# use feature qw(state);

### INITIALIZE VARIABLES ###

## Self data
my $self_config_dir='';
my $self_data_dir='';
my $self_download = '';
my $self_path='';

## Debuggers
my $debug=0;
my $fh_l; # log file handle
my $log_file = '';
my $end='log_data("fe", (caller(1))[3], "");';
my $start='log_data("fs", (caller(1))[3], @_);';

## Hashes
my %colors;
my %system_files;
my %sep;
my %size;
my %show;

#my $opt_parser = Getopt::Long::Parser->new;

## Booleans
my $b_display = '';
my $b_irc='';
my $b_log = '';
my $b_log_colors = '';
my $b_log_full = '';
my $b_root='';
my $b_running_in_display='';
my $b_update = 'true';
my $b_weather = 'true';

## System
my $bsd_type = '';
my $cpu_sleep = 0.3;
my $dl_timeout = 4;
my $os = '';
my $ps_count = 5;
my $sensors_cpu_nu = 0;

## irc
my $b_dcop = '';
my $b_qdbus = '';
my $konvi = 0;

## Output
my $filter_string = '<filter>';
my $line1 = "----------------------------------------------------------------------\n";
my $line2 = "======================================================================\n";
my $line3 = "----------------------------------------\n";
my $output_type = 'print-line';
# These two determine separators in single line output, to force irc clients 
# not to break off sections
$sep{'s-1'}='~';
$sep{'s-2'}=' ';
# these will assign a separator to non irc states. Important! Using ':' can 
# trigger stupid emoticon
# behaviors in output on IRC, so do not use those.
$sep{'irc'}='';
$sep{'console'}=':';
$show{'extra'}=0; # supported values: 0-3
$size{'console'} = 115;
# Default indentation level. NOTE: actual indent is 1 greater to allow for 
# spacing
$size{'indent'} = 10;
$size{'inner'}=0; # for width minus $indent
$size{'irc'} = 130;
$size{'max'}=0;
$size{'no-display'} = 130;

# these will be set dynamically in set_display_width()
$size{'term'}=80;
$size{'term-lines'}=100;

########################################################################
#### STARTUP
########################################################################

#### -------------------------------------------------------------------
#### MAIN
#### -------------------------------------------------------------------

sub main {
	# print Dumper \@ARGV;
	initialize();
	set_display_width('live');
	get_options();
	set_debugger(); # right after so it's set
	# print_it_out('fred', 'gus', 'sam');
	print_it_out();
}

#### -------------------------------------------------------------------
#### INITIALIZE
#### -------------------------------------------------------------------

sub initialize {
	set_os();
	set_path();
	set_user_paths();
	system_files('set');
	my @config_files = (
	qq(/etc/$self_name.conf), 
	qq($self_config_dir/$self_name.conf)
	);
	set_configs(@config_files);
	### LOCALIZATION - DO NOT CHANGE! ###
	# set to default LANG to avoid locales errors with , or .
	# Make sure every program speaks English.
	$ENV{'LANG'}='C';
	$ENV{'LC_ALL'}='C';
	if ( system('tty>/dev/null') ) {
		$b_irc='true';
	}
	# print "birc: $b_irc\n";
	if ( $ENV{'DISPLAY'} ){
		$b_display = 'true';
	}
	if ( $ENV{'HOME'} eq '/root' ){
		$b_root='true';
	}
}

sub set_configs {
	my ($file, $key, $val);
	# Config files should be passed in an array as a param to this function.
	# Default intended use: global @CONFIGS;
	foreach $file (@_) {
		next unless open (CONFIG, "$file");
		while (<CONFIG>) {
			chomp;
			s/#.*//;
			s/^\s+//;
			s/\s+$//;
			s/'//g;
			s/false//; # we want this empty so it trips boolean false
			next unless length;
			($key, $val) = split(/\s*=\s*/, $_, 2);
			set_config($key,$val);
			# print "f: $file key: $key val: $val\n";
		}
		
	}
}
# args: 0: key; 1: value
sub set_config {
	my ($key,$val) = @_;
	for ($key){
		if (/B_ALLOW_UPDATE/) {$b_update = $val}
		elsif (/B_ALLOW_WEATHER/) {$b_weather = $val}
		elsif (/CPU_SLEEP/) {$cpu_sleep = $val}
		elsif (/DL_TIMEOUT/) {$dl_timeout = $val}
		elsif (/FILTER_STRING/) {$filter_string = $val}
		elsif (/PS_COUNT/) {$ps_count = $val}
		elsif (/SENSORS_CPU_NO/) {$sensors_cpu_nu = $val}
		# layout
		elsif (/CONSOLE_COLOR_SCHEME/) {$colors{'console'} = $val}
		elsif (/IRC_CONS_COLOR_SCHEME/) {$colors{'console-irc'} = $val}
		elsif (/IRC_X_TERM_COLOR_SCHEME/) {$colors{'irc-x-term'} = $val}
		elsif (/IRC_COLOR_SCHEME/) {$colors{'irc'} = $val}
		elsif (/VIRT_TERM_COLOR_SCHEME/) {$colors{'virt-term'} = $val}
		elsif (/SEP1/) {$sep{'s-1'} = $val}
		elsif (/SEP2/) {$sep{'s-2'} = $val}
		elsif (/SEP3_IRC/) {$sep{'irc'} = $val}
		elsif (/SEP3_CONSOLE/) {$sep{'console'} = $val}
		# size
		elsif (/COLS_MAX_CONSOLE/) {$size{'console'} = $val}
		elsif (/COLS_MAX_IRC/) {$size{'irc'} = $val}
		elsif (/COLS_MAX_NO_DISPLAY/) {$size{'no-display'} = $val}
	}
	#  print "mc: key: $key val: $val\n";
	# print Dumper (keys %size) . "\n";
}

# args: $1 - default OR override default cols max integer count
sub set_display_width {
	my ($width_override)=@_;
	
	if ( $width_override eq 'live' ){
		## sometimes tput will trigger an error (mageia) if irc client
		if ( ! $b_irc ){
			if ( check_program('tput') ) {
				chomp($size{'term'}=qx/tput cols/);
				chomp($size{'term-lines'}=qx/tput lines/);
			}
			# print "tc: $size{'term'} cmc: $size{'console'}\n";
			# double check, just in case it's missing functionality or whatever
			if ( $size{'term'} == 0 || $size{'term'} !~ /\d/ ){ 
				$size{'term'}=80;
				$size{'term-lines'}=100;
			}
		}
		# this lets you set different size for in or out of display server
		# if ( ! $b_running_in_display && $configs{'COLS_MAX_NO_DISPLAY'} != 0 ){
		# 	$size{'console'}=$configs{'COLS_MAX_NO_DISPLAY'};
		# }
		# term_cols is set in top globals, using tput cols
		# print "tc: $size{'term'} cmc: $size{'console'}\n";
		if ( $size{'term'} < $size{'console'} ){
			$size{'console'}=$size{'term'};
		}
		# adjust, some terminals will wrap if output cols == term cols
		$size{'console'}=( $size{'console'} - 2 );
		# echo cmc: $size{'console'}
		# comes after source for user set stuff
		if ( ! $b_irc ){
			$size{'max'}=$size{'console'};
		}
		else {
			$size{'max'}=$size{'irc'};
		}
	}
	else {
		$size{'max'}=$width_override;
	}
	$size{'inner'}= ( $size{'max'} - $size{'indent'} - 1 );
	# print "tc: $size{'term'} cmc: $size{'console'} cm: $size{'max'} ci: $size{'inner'}\n";
}

sub set_os {
	my @uname = uname();
	$os = lc($uname[0]);
	if ( $os =~ /(bsd|dragonfly|darwin)/ ){
		if ( $os =~ /openbsd/ ){
			$os = 'openbsd';
		}
		elsif ($os =~ /darwin/){
			$os = 'darwin';
		}
		if ($os =~ /kfreebsd/){
			$bsd_type = 'debian-bsd';
		}
		else {
			$bsd_type = 'bsd';
		}
	}
}

sub set_path {
	my $added_paths = '';
	# Extra path variable to make execute failures less likely, merged below
	my @path = split ':', $ENV{'PATH'};
	my @extra_paths=split ':', '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/opt/local/bin';
	#print "PATH=$ENV{'PATH'}\n";
	# this needs to be set here because various options call the parent 
	# initialize function directly.
	$self_path=dirname "$0";
	# Create a difference of $PATH and $extra_paths and add that to $PATH:
	foreach (@extra_paths) {
		if ( ! grep(/$_/, @path) ){
			$added_paths="$added_paths:$_";
			# print "$path\n";
		}
	}
	$ENV{'PATH'} = $ENV{'PATH'} . $added_paths;
	# print "PATH=$ENV{'PATH'}\n";
	##/bin/sh -c 'echo "PATH in subshell=\"$PATH\""'
}

sub set_user_paths {
	my ( $b_conf, $b_data );
	
	if ( defined $ENV{'XDG_CONFIG_HOME'} && $ENV{'XDG_CONFIG_HOME'} ne '' ){
		$self_config_dir=$ENV{'XDG_CONFIG_HOME'};
		$b_conf='true';
	}
	elsif ( -d "$ENV{'HOME'}/.config" ){
		$self_config_dir="$ENV{'HOME'}/.config";
		$b_conf='true';
	}
	else {
		$self_config_dir="$ENV{'HOME'}/.$self_name";
	}
	if ( defined $ENV{'XDG_DATA_HOME'} && $ENV{'XDG_DATA_HOME'} ne '' ){
		$self_data_dir="$ENV{'XDG_DATA_HOME'}/$self_name";
		$b_data='true';
	}
	elsif ( -d "$ENV{'HOME'}/.local/share" ){
		$self_data_dir="$ENV{'HOME'}/.local/share/$self_name";
		$b_data='true';
	}
	else {
		$self_data_dir="$ENV{'HOME'}/.$self_name";
	}
	# note, this used to be created/checked in specific instance, but we'll just do it
	# universally so it's done at script start.
	if ( ! -d $self_data_dir ){
		#system 'mkdir', $self_data_dir;
		system "echo", "WOULD: $self_data_dir";
	}
	if ( $b_conf && -f "$ENV{'HOME'}/.$self_name/$self_name.conf" ){
		#system 'mv', "-f $ENV{'HOME'}/.$self_name/$self_name.conf", $self_config_dir;
		print "WOULD: Moved $self_name.conf from $ENV{'HOME'}/.$self_name to $self_config_dir\n";
	}
	if ( $b_data && -d "$ENV{'HOME'}/.$self_name" ){
		#system 'mv', '-f', "$ENV{'HOME'}/.$self_name/*", $self_data_dir;
		#system 'rm', '-Rf', "$ENV{'HOME'}/.$self_name";
		print "WOULD: Moved data dir $ENV{'HOME'}/.$self_name to $self_data_dir\n";
	}
	#system 'echo', "$ENV{'HOME'}/.$self_name/* $self_data_dir";
	# print "scd: $self_config_dir sdd: $self_data_dir \n";
}
# args: 1: set|hash key to return either null or path
sub system_files {
	my ($type) = @_;
	
	if ( $type eq 'set'){
		my %files = (
		'asound-cards' => '/proc/asound/cards',
		'asound-modules' => '/proc/asound/modules',
		'asound-version' => '/proc/asound/version',
		'cpuinfo' => '/proc/cpuinfo',
		'dmesg-boot' => '/var/run/dmesg.boot',
		'lsb-release' => '/etc/lsb-release',
		'mdstat' => '/proc/mdstat',
		'meminfo' => '/proc/meminfo',
		'modules' => '/proc/modules',
		'mounts' => '/proc/mounts',
		'os-release' => '/etc/os-release',
		'partitions' => '/proc/partitions',
		'scsi' => '/proc/scsi/scsi',
		'xorg-log' => '/var/log/Xorg.0.log'
		);
		foreach my $key ( keys %files ){
			$system_files{$key} = -e $files{$key} ? $files{$key} : '';
		}
		if ( ! $system_files{'xorg-log'} && check_program('xset') ){
			my $data = qx(xset q 2>/dev/null);
			foreach ( split /\n/, $data){
				if ($_ =~ /Log file/i){
					$system_files{'xorg-log'} = get_piece($_,3);
					last;
				}
			}
		}
	}
	else {
		return $system_files{$type};
	}
}


########################################################################
#### UTILITIES
########################################################################

#### -------------------------------------------------------------------
#### COLOR SELECTOR
#### -------------------------------------------------------------------


#### -------------------------------------------------------------------
#### DEBUGGERS
#### -------------------------------------------------------------------


sub set_debugger {
	if ( $debug < 10 || $debug > 12){
		$end = '';
		$start = '';
	}
	elsif ($debug =~ /^1[0-2]$/){
		$b_log = 'true';
		if ($debug == 11){
			$b_log_full = 'true';
		}
		elsif ($debug == 12){
			$b_log_colors = 'true';
		}
		begin_logging();
	}
}


#### -------------------------------------------------------------------
#### DOWNLOADER
#### -------------------------------------------------------------------


#### -------------------------------------------------------------------
#### ERROR HANDLER
#### -------------------------------------------------------------------

sub error_handler {
	my ( $num, $one, $two) = @_;
	print "Error $num: option: $one";
	if ($two){
		print " value: $two is incorrect.";
	}
	print "\nCheck -h for correct parameters.\n";
	exit $num;
}

#### -------------------------------------------------------------------
#### LOGGING
#### -------------------------------------------------------------------

# called in the initial -@ 10 script args setting so we can get logging 
# as soon as possible # will have max 3 files, inxi.log, inxi.1.log, 
# inxi.2.log
sub begin_logging {
	$log_file="$self_data_dir/$self_name.log";
	my $log_file_2="$self_data_dir/$self_name.1.log";
	my $log_file_3="$self_data_dir/$self_name.2.log";
	my $data = '';
	
	my $now = strftime "%Y-%m-%d %H:%M:%S", localtime;
	# do the rotation if logfile exists
	if ( -f $log_file ){
		# copy if present second to third
		if ( -f $log_file_2 ){
			rename $log_file_2, $log_file_3 or error_handler(3, "$log_file_2 -> $log_file_3", '');
		}
		# then copy initial to second
		rename $log_file, $log_file_2 or error_handler(3, "$log_file -> $log_file_2", '');
	}
	# now create the logfile
	# print "Opening log file for reading: $log_file\n";
	open $fh_l, '>', $log_file or error_handler(4, $log_file, '');
	# and echo the start data
	$data = $line2;
	$data = $data . "START $self_name LOGGING:\n";
	$data = $data . "$now\n";
	$data = $data .  $line2;
	print $fh_l $data;
}

# NOTE: no logging available until get_parameters is run, since that's what 
# sets logging # in order to trigger earlier logging manually set $b_log
# to true in top variables.
# arg: $one alone: logs data; $two with or without $three logs func start/end.
# arg: $one type (fs/fe/cat/raw) or logged data; 
# [$two is function name; [$three - function args]]
sub log_data {
	return if ! $b_log;
	my ($one, $two, @args) = @_;
	my $args = '';
	my $data = '';
	my $spacer = '   ';
	# print "1: $one 2: $two 3: $three\n";
	for ($one){
		if (/^fs$/) {
			if (@args){
				$args = "\n${spacer}Args: " . join(', ', @args) . '; ';
			}
			else {
				$args = "\n${spacer}Args: None; ";
			}
			$data = "Start: Function: $two$args\n";
			$spacer='';
		}
		elsif (/^fe$/) {
			$data = "End: Function: $two\n";
			$spacer='';
		}
		elsif (/^cat$/) {
			if ( $b_log_full ){
				for my $file ($two){
					my $contents = do { local( @ARGV, $/ ) = $file; <> }; # or: qx(cat $file)
					$data = "$data${line3}Full file data: $file\n\n$contents\n$line3\n";
				}
				$spacer='';
			}
		}
		elsif (/^raw$/) {
			if ( $b_log_full ){
				$data = "\n${line3}Raw System Data:\n\n$two\n$line3";
				$spacer='';
			}
		}
		else {
			$data = "$one\n";
		}
	}
	# print "d: $data";
	if ($data){
		print $fh_l "$spacer$data";
	}
}

#### -------------------------------------------------------------------
#### RECOMMENDS
#### -------------------------------------------------------------------


#### -------------------------------------------------------------------
#### TOOLS
#### -------------------------------------------------------------------

## returns result of test, 0/1, false/true
## arg: program to find in PATH
sub check_program {
	grep { -x "$_/$_[0]"}split /:/,$ENV{PATH};
}

sub get_piece {
	my ($string, $num, $sep) = @_;
	$num--;
	$sep ||= ' ';
	my @temp = split $sep, $string, -1;
	if ( exists $temp[$num] ){
		return $temp[$num];
	}
}

#### -------------------------------------------------------------------
#### UPDATER
##### -------------------------------------------------------------------

sub update_me {

}

########################################################################
#### OPTIONS HANDLER
########################################################################

sub get_options{
	my (@args) = @_;
	# my @argv = @ARGV;
	$show{'short'} = 'true';
	# $show{''} = 'true';
	#$opt_parser->configure('no_ignore_case');
	# GetOptionsFromArray(\@argv, 
	GetOptions (
	'A|audio' => sub {
		$show{'short'} = '';
		$show{'audio'} = 'true';},
	'b|basic' => sub {
		$show{'short'} = '';
		$show{'battery'} = 'true';
		$show{'cpu-basic'} = 'true';
		$show{'raid-basic'} = 'true';
		$show{'disk-total'} = 'true';
		$show{'graphics'} = 'true';
		$show{'info'} = 'true';
		$show{'machine'} = 'true';
		$show{'network'} = 'true';},
	'B|battery' => sub {
		$show{'short'} = '';
		$show{'battery'} = 'true';
		$show{'battery-forced'} = 'true'; },
	'c|color:i' => sub {
		$show{'short'} = '';
		# $show{''} = 'true'; 
		},
	'C|cpu' => sub {
		$show{'short'} = '';
		$show{'cpu'} = 'true'; },
	'd|disk-all' => sub {
		$show{'short'} = '';
		$show{'disk'} = 'true';
		$show{'optical-full'} = 'true'; },
	'D' => sub {
		$show{'short'} = '';
		$show{'disk'} = 'true'; },
	'f|cpu-flags' => sub {
		$show{'short'} = '';
		$show{'cpu'} = 'true';
		$show{'cpu-flags'} = 'true'; },
	'F|full' => sub {
		$show{'short'} = '';
		$show{'audio'} = 'true';
		$show{'battery'} = 'true';
		$show{'cpu'} = 'true';
		$show{'disk'} = 'true';
		$show{'graphics'} = 'true';
		$show{'info'} = 'true';
		$show{'machine'} = 'true';
		$show{'network'} = 'true';
		$show{'network-advanced'} = 'true';
		$show{'partitions'} = 'true';
		$show{'raid'} = 'true';
		$show{'sensors'} = 'true';
		$show{'system'} = 'true'; },
	'G|graphics' => sub {
		$show{'short'} = '';
		$show{'graphics'} = 'true'; },
	'i|internet' => sub {
		$show{'short'} = '';
		$show{'ip'} = 'true';
		$show{'network'} = 'true';
		$show{'network-advanced'} = 'true'; },
	'I|info' => sub {
		$show{'short'} = '';
		$show{'info'} = 'true'; },
	'l|labels' => sub {
		$show{'short'} = '';
		$show{'labels'} = 'true';
		$show{'partitions'} = 'true'; },
	'm|memory' => sub {
		$show{'short'} = '';
		$show{'memory'} = 'true'; },
	'M|machine' => sub {
		$show{'short'} = '';
		$show{'machine'} = 'true'; },
	'n|network-advanced' => sub {
		$show{'short'} = '';
		$show{'network'} = 'true';
		$show{'network-advanced'} = 'true'; },
	'N|network' => sub {
		$show{'short'} = '';
		$show{'network'} = 'true'; },
	'o|unmounted' => sub {
		$show{'short'} = '';
		$show{'unmounted'} = 'true'; },
	'p|partitions-full' => sub {
		$show{'short'} = '';
		$show{'partitions'} = 'true';
		$show{'partitions-full'} = 'true'; },
	'P|partitions' => sub {
		$show{'short'} = '';
		$show{'partitions'} = 'true'; },
	'r|repos' => sub {
		$show{'short'} = '';
		$show{'repos'} = 'true'; },
	'R|raid' => sub {
		$show{'short'} = '';
		$show{'raid'} = 'true';
		$show{'raid-forced'} = 'true'; },
	's|sensors' => sub {
		$show{'short'} = '';
		$show{'sensors'} = 'true'; },
	'S|system' => sub {
		$show{'short'} = '';
		$show{'system'} = 'true'; },
	't|processes:s' => sub {
		my ($opt,$arg) = @_;
		$show{'short'} = '';
		if ( $arg =~ /^([cm]+)([1-9]|1[0-9]|20)?$/ ){
			if ($arg =~ /c/){
				$show{'ps-cpu'} = 'true';
			}
			if ($arg =~ /m/){
				$show{'ps-mem'} = 'true';
			}
			if ($arg =~ /([0-9]+)/ ){
				$ps_count = $1;
			}
		}
		else {
			error_handler(100,$opt,$arg);
		} },
	'u|uuid' => sub {
		$show{'short'} = '';
		$show{'partitions'} = 'true';
		$show{'uuids'} = 'true'; },
	'U|update' => sub {
		my ($opt,$arg) = @_;
		$show{'short'} = '';
		if ( $b_update ){
			update_me( $self_download, 'source server', "$opt" );
		}
		else {
			error_handler(17, $opt);
		} },
	'v|verbosity:i' => sub {
		my ($opt,$arg) = @_;
		$show{'short'} = '';
		if ( $arg =~ /^[0-7]$/ ){
			if ($arg == 0 ){
				$show{'short'} = 'true';
			}
			if ($arg >= 1 ){
				$show{'cpu-basic'} = 'true';
				$show{'disk-total'} = 'true';
				$show{'graphics'} = 'true';
				$show{'info'} = 'true';
				$show{'system'} = 'true';
			}
			if ($arg >= 2 ){
				$show{'battery'} = 'true';
				$show{'disk-basic'} = 'true';
				$show{'raid-basic'} = 'true';
				$show{'machine'} = 'true';
				$show{'network'} = 'true';
			}
			if ($arg >= 3 ){
				$show{'network-advanced'} = 'true';
				$show{'cpu'} = 'true';
				$show{'extra'} = 1;
			}
			if ($arg >= 4 ){
				$show{'disk'} = 'true';
				$show{'partitions'} = 'true';
			}
			if ($arg >= 5 ){
				$show{'audio'} = 'true';
				$show{'memory'} = 'true';
				$show{'labels'} = 'true';
				$show{'memory'} = 'true';
				$show{'raid'} = 'true';
				$show{'sensors'} = 'true';
				$show{'uuid'} = 'true';
			}
			if ($arg >= 6 ){
				$show{'optical-full'} = 'true';
				$show{'partitions-full'} = 'true';
				$show{'unmounted'} = 'true';
				$show{'extra'} = 2;
			}
			if ($arg >= 7 ){
				$show{'ip'} = 'true';
				$show{'raid-forced'} = 'true';
				$show{'extra'} = 3;
			}
		}
		else {
			error_handler(100,$opt,$arg);
		} },
	'V|version' => sub { 
		$output_type = 'print-basic';
		show_version(); },
	'w|weather' => sub {
		$show{'short'} = '';
		if ( $b_weather ){
			$show{'weather'} = 'true';
		} },
	'W|weather-location' => sub {
		$show{'short'} = '';
		if ( $b_weather ){
			$show{'weather'} = 'true';
			$show{'weather-location'} = 'true';
		} },
	'x|extra:i' => sub {
		my ($opt,$arg) = @_;
		if ($arg > 0){
			$show{'extra'} = $arg;
		}
		else {
			$show{'extra'}++;
		} },
	'y|width:i' => sub {
		my ($opt, $arg) = @_;
		if ( $arg =~ /\d/ && $arg >= 80 ){
			set_display_width($arg);
		}
		else {
			error_handler(21, $opt, $arg);
		} },
	'z|filter-output' => sub {
		$show{'filter-output'} = 'true'; },
	'Z|filter-override' => sub {
		$show{'filter-override'} = 'true'; },
	'h|help|?' => sub {
		$output_type = 'print-basic';
		show_options('standard'); },
	'H|help-full' => sub {
		$output_type = 'print-basic';
		show_options('full'); },
	'debug:i' => sub { 
		my ($opt,$arg) = @_;
		if ($arg =~ /^[1-3]|[1-2][0-2]$/){
			$debug=$arg;
		}
		else {
			error_handler(21, $opt, $arg);
		} },
	'alt:i' => sub { 
		my ($opt,$arg) = @_;
		print "alt $arg\n"; },
	'<>' => sub {
		my ($opt) = @_;
		error_handler(2, "Unknown argument: $opt", "" ); }
	) or error_handler(3, 'Unknown Option', '');
# 	print "dump\n" . Dumper \@ARGV;
# 	if ( @ARGV ) {
# 		error_handler(1, "Uknown option $ARGV[0] given!", "" );
# 		@ARGV=undef;
# 	}
	#@ARGV = @argv; 
} 

sub show_options {
	
	print "stub: " . (caller(0))[3] . "\n";
	
	exit 1;
}


########################################################################
#### STARTUP DATA
########################################################################


########################################################################
#### OUTPUT
########################################################################

#### -------------------------------------------------------------------
#### FILTERS
#### -------------------------------------------------------------------


sub print_patch_version {
	my $patch = $self_patch;
	$patch =~ s/^0+//; # strip leading zero(s)
	if ( $patch ne '' ){
		$patch="-$patch";
		# for cases where it was for example: 00-bsd cleaned to --bsd trim out one -
		$patch =~ s/--/-/;
	}
	return $patch;
}


#### -------------------------------------------------------------------
#### GENERATE OUTPUT
#### -------------------------------------------------------------------

sub output_handler {
	my @data = @_;
	# print Dumper \@data;
	if ($output_type eq 'print-basic'){
		print_basic(@data);
	}
	elsif ($output_type eq 'print-line'){
		print_line(@data);
	}
	elsif ($output_type eq 'csv'){
		generate_csv(@data);
	}
	elsif ($output_type eq 'json'){
		generate_json(@data);
	}
	elsif ($output_type eq 'xml'){
		generate_xml(@data);
	}
}


sub show_version {
	# if not in PATH could be either . or directory name, no slash starting
	my $working_path=$self_path;
	my (@data, @row, $link, $self_string);
	if ( $working_path eq '.' ){
		$working_path=getcwd;
	}
	elsif ( $working_path !~ /^\// ){
		$working_path= getcwd() . "/$working_path";
	}
	# handle if it's a symbolic link, rare, but can happen with directories 
	# in irc clients which would only matter if user starts inxi with -! 30 override 
	# in irc client
	if ( -l "$working_path/$self_name" ){
		$link="$working_path/$self_name";
		$working_path=readlink "$working_path/$self_name";
		$working_path=dirname( $working_path );
	}
	@row = [ 0, '', '', "$self_name $self_version-$self_patch ($self_date)"];
	push @data, @row;
	
	if ( ! $b_irc ){
		@row = [ 0, '', '', "Program Location: $working_path" ];
		push @data, @row;
		if ( $link ){
			@row = [ 0, '', '', "Started via symbolic link: $link" ];
			push @data, @row;
		}
		@row = [ 0, '', '', "Website:^https://github.com/smxi/inxi^or^http://smxi.org/" ];
		push @data, @row;
		@row = [ 0, '', '', "IRC:^irc.oftc.net channel:^#smxi" ];
		push @data, @row;
		@row = [ 0, '', '', "Forums:^http://techpatterns.com/forums/forum-33.html" ];
		push @data, @row;
		@row = [ 0, '', '', " " ];
		push @data, @row;
		@row = [ 0, '', '', "$self_name - the universal, portable, system information tool 
		for console and irc." ];
		push @data, @row;
		@row = [ 0, '', '', " " ];
		push @data, @row;
		@row = [ 0, '', '', "This program started life as a fork of Infobash 3.02: 
		Copyright^(C)^2005-2007^Michiel^de^Boer^a.k.a.^locsmif." ];
		push @data, @row;
		my $year = (split/-/, $self_date)[0];
		@row = [ 0, '', '', "Subsequent changes and modifications (after Infobash 3.02): 
		Copyright^(C)^2008-$year^Harald^Hope^aka^h2. 
		CPU/Konversation^fixes:^Scott^Rogers^aka^trash80.
		USB^audio^fixes:^Steven^Barrett^aka^damentz." ];
		push @data, @row;
		@row = [ 0, '', '', '' ];
		push @data, @row;
		@row = [ 0, '', '', "This program is free software; you can redistribute it and/or modify 
		it under the terms of the GNU General Public License as published by the Free Software 
		Foundation; either version 3 of the License, or (at your option) any later version. 
		(http://www.gnu.org/licenses/gpl.html)" ];
		push @data, @row;
	}
	output_handler(@data); 
}

sub print_screen_line {
	my $line = shift;
	if ( $konvi == 1 && $b_dcop ){
	
	}
	elsif ($konvi == 3 && $b_qdbus){
	
	}
	else {
		print $line;
	}
}

sub print_basic {
	my @data = @_;
	my $indent = 20;
	my $indent1 = 4;
	my $indent2 = 7;
	my $length =  @data;
	my ($start,$aref,$i,$j,$line, $word);
	# print $length . "\n";
	for $i (0 .. $#data){
		$aref = $data[$i];
		#print "0: $data[$i][0]\n";
		if ($data[$i][0] == 0 ){
			$indent = 0;
			$indent1 = 0;
			$indent2 = 0;
		}
		elsif ($data[$i][0] == 1 ){
		
		}
		elsif ($data[$i][0] == 2 ){
			$indent = ( $indent + 6 );
			$indent1 = ( $indent + 2 );
			$indent2 = 0;
		}
		$data[$i][3] =~ s/\n/ /g;
		$data[$i][3] =~ s/\s+/ /g;
		$start = sprintf("%${indent1}s%${indent2}s",$data[$i][1],$data[$i][2]);
		if ( length($start) > $indent ){
			$line = sprintf("%-${indent}s\n", "$start");
			print_screen_line($line);
			$start = '';
		}
		if ( ( $indent + length($data[$i][3]) ) < $size{'max'} ){
			$data[$i][3] =~ s/\^/ /g;
			$line = sprintf("%-${indent}s%s\n", "$start", $data[$i][3]);
			print_screen_line($line);
		}
		else {
			my $holder = '';
			my $sep = ' ';
			foreach $word (split ' ', $data[$i][3]){
				#print "$word\n";
				if ( ( $indent + length($holder) + length($word) ) < $size{'max'} ) {
					$word =~ s/\^/ /g;
					$holder = $holder . $word . $sep;
				}
				elsif ( ( $indent + length($holder) + length($word) ) > $size{'max'}){
					$line = sprintf("%-${indent}s%s\n", "$start", $holder);
					print_screen_line($line);
					$start = '';
					$word =~ s/\^/ /g;
					$holder = $word . $sep;
				}
			}
			if ($holder){
				$line = sprintf("%-${indent}s%s\n", "$start", $holder);
				print_screen_line($line);
			}
		}
	}
}


########################################################################
#### DATA PROCESSORS
########################################################################

#### -------------------------------------------------------------------
#### GET DATA
#### -------------------------------------------------------------------


#### -------------------------------------------------------------------
#### SPECIAL DATA HANDLERS - INITIALIZE DATA VALUES
#### -------------------------------------------------------------------


#### -------------------------------------------------------------------
#### SPECIAL DATA HANDLERS - UTILITIES FOR GET DATA/PRINT LINES
#### -------------------------------------------------------------------

sub get_hostname {
	eval $start;
	if ( $ENV{'HOSTNAME'} ){
		return $ENV{'HOSTNAME'};
	}
	else {
		return hostname;
	}
	eval $end;
}

########################################################################
#### PRINT DATA
########################################################################

#### -------------------------------------------------------------------
#### PRINT CONTROLLERS
#### -------------------------------------------------------------------



sub print_it_out {
	eval $start;
	# log_data('cat', '/proc/mounts');
	print "stub: " . (caller(0))[3] . "\n";
	eval $end;
}

#### -------------------------------------------------------------------
#### PRINT LINES
#### -------------------------------------------------------------------



#######################################################################
#### LAUNCH
########################################################################

main(); ## From the End comes the Beginning

## note: this EOF is needed for smxi handling, this is what triggers the full download ok
###**EOF**###
